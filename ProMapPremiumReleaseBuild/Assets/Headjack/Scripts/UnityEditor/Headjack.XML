<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Headjack</name>
    </assembly>
    <members>
        <!-- Badly formed XML comment ignored for member "M:Headjack.Analytics.ResendCached" -->
        <member name="M:Headjack.AndroidDownloader.GetActiveJob(System.String)">
            <summary>
            returns Job Info if job associated with Media ID is active,
            otherwise returns null
            </summary>
        </member>
        <member name="M:Headjack.AndroidDownloader.GetApplicationContext(UnityEngine.AndroidJavaObject)">
            Returns the application context of the current Android Activity.
        </member>
        <member name="M:Headjack.AndroidDownloader.GetActivity">
            Returns the Android Activity used by the Unity device player. The caller is
            responsible for memory-managing the returned AndroidJavaObject.
        </member>
        <!-- Badly formed XML comment ignored for member "T:Headjack.App" -->
        <member name="F:Headjack.App.VrMode">
            <summary>
            false if on Cardboard and VrMode is not active
            </summary>
        </member>
        <member name="M:Headjack.App.CodecPriority(System.String)">
            <summary>
            false if on Cardboard and VrMode is not active
            </summary>
        </member>
        <member name="F:Headjack.App.OculusMenu">
            <summary>
            GearVR's oculus platform menu
            </summary>
        </member>
        <member name="F:Headjack.App.WaterMarkObject">
            <summary>
            Watermark instance
            </summary>
        </member>
        <member name="F:Headjack.App.Host">
            <summary>
            Url to server base
            </summary>
        </member>
        <member name="F:Headjack.App.BasePath">
            <summary>
            Filepath to local folders
            </summary>
        </member>
        <member name="F:Headjack.App.PopUp">
            <summary>
            Message object instance
            </summary>
        </member>
        <member name="F:Headjack.App.CurrentlyLoadedPlatform">
            <summary>
            Returns the currently loaded platform, the name says it all
            </summary>
        </member>
        <member name="F:Headjack.App.cinemaSupported">
            <summary>
            true if Cinema feature is supported and allowed
            </summary>
        </member>
        <member name="F:Headjack.App.AppId">
            <summary>
            App ID
            </summary>
        </member>
        <member name="F:Headjack.App.Authkey">
            <summary>
            Auth key
            </summary>
        </member>
        <member name="F:Headjack.App.AnalyticsManager">
            <summary>
            Analytics Object
            </summary>
        </member>
        <member name="F:Headjack.App.DataObject">
            <summary>
            Data Object
            </summary>
        </member>
        <member name="F:Headjack.App.VRCamera">
            <summary>
            Reference to top-level VR Camera gameobject
            </summary>
        </member>
        <member name="F:Headjack.App.Videosphere">
            <summary>
            The Mesh for the video player
            </summary>
        </member>
        <member name="F:Headjack.App.Downloader">
            <summary>
            The download manager
            </summary>
        </member>
        <member name="F:Headjack.App.Data">
            <summary>
            json data
            </summary>
        </member>
        <member name="F:Headjack.App.CurrentTrackingOrigin">
            <summary>
            The currently selected tracking origin (e.g. floor level or eye level)
            </summary>
        </member>
        <member name="M:Headjack.App.GetSubtitleFilename(System.String,System.String)">
            <summary>
            Return the url of the SRT file of given video and given language
            </summary>
        </member>
        <member name="M:Headjack.App.VideoGetSubtitles(System.String)">
            <summary>
            returns a list of all subtitles from given video id
            </summary>
        </member>
        <member name="M:Headjack.App.GetMediaUrl(System.String)">
            <summary>
            Url for media file "Id"
            </summary>
        </member>
        <member name="M:Headjack.App.GetMediaPath(System.String)">
            <summary>
            Local path for media file "Id"
            </summary>
        </member>
        <member name="M:Headjack.App.GetVideoStream(System.String,Headjack.AppData.FormatBlock)">
            <summary>
            stream url for video file "Id"
            </summary>
        </member>
        <member name="M:Headjack.App.GetVideoPath(System.String)">
            <summary>
            Local path for video file "Id"
            </summary>
        </member>
        <member name="M:Headjack.App.GetVideoUrl(System.String)">
            <summary>
            Url for video file "Id"
            </summary>
        </member>
        <member name="M:Headjack.App.GetVideoSize(System.String)">
            <summary>
            Size for video file "Id"
            </summary>
        </member>
        <member name="M:Headjack.App.GetJsonUrl(System.String,System.Boolean)">
            <summary>
            Url for json file "Id"
            </summary>
        </member>
        <member name="M:Headjack.App.GetJsonPath(System.String)">
            <summary>
            Local path for json file "Id"
            </summary>
        </member>
        <member name="M:Headjack.App.GotVideoFile(System.String)">
            <summary>
            Check if a Video file is already downloaded
            </summary>
        </member>
        <member name="M:Headjack.App.UpdateAvailableVideo(System.String)">
            <summary>
            Check if an update is available for video with given id
            </summary>
        </member>
        <member name="M:Headjack.App.GetProjectVideoIdList(System.String)">
            <summary>
            Returns a string[] of all videos in a project
            </summary>
        </member>
        <member name="M:Headjack.App.GetProjectMediaIdList(System.String)">
            <summary>
            Returns a string[] of all media in a project
            </summary>
        </member>
        <member name="M:Headjack.App.CreateVideoSphere">
            <summary>
            Delete all files in given project number
            </summary>
        </member>
        <member name="M:Headjack.App.CreateVideoplayer(System.Boolean)">
            <summary>
            Create Videoplayer
            </summary>
        </member>
        <member name="M:Headjack.App.GetVideoFormatData(System.String,System.Boolean,Headjack.AppData.FormatBlock)">
            <summary>
            Returns the correct video format block for this device, and all the metadata with it
            </summary>
        </member>
        <member name="P:Headjack.App.Guid">
            <summary>
            The unique identifier of this app on this device.
            This UID is reset when the app is deleted from the phone
            </summary>
        </member>
        <member name="P:Headjack.App.EnableOVRPlatformMenu">
                    <summary>
                    If true, the back button on the GearVR will open the Oculus Platform Menu. You can disable this when the user goes out of the menu and in a video. 
                    </summary>
                    <returns>If the platform menu is enabled</returns>
                    @note GearVR only
                    @warning If disabled, make sure that the back button will always bring you back to the "upper menu" where it is enabled. The user must always be able to reach the Oculus platform menu by keep pressing the back button.
                    <example> 
                    <b>Example</b>
                    <code>
                        //Disable when playing a video
                        void PlayVideo(string id)
                        {
                            App.EnableOVRPlatformMenu=false;
                            App.Play(id, true, true, null);
                        }
                    </code>
                    </example>
        </member>
        <member name="P:Headjack.App.IsPublished">
                    <summary>
                    Returns whether app has published state set in Headjack
                    </summary>
                    <returns>True if the app is set to published in Headjack (and is therefore available to use)</returns>
                    @warning If an app is set to unpublished in Headjack, the app will receive no media information, like projects, videos or thumbnails.
                     
                    <example> 
                    <b>Example</b>
                    <code>
                        // Show message to the user when app is unpublished
                        public void MessageUserUnpublished() 
                        {
                            if (!Headjack.App.IsPublished)
                            {
                                Headjack.App.ShowMessage("This app is not published and is currently unavailable!", 5);
                            }
                        }
                    </code>
                    </example>
        </member>
        <member name="P:Headjack.App.ShowCrosshair">
                   <summary>
                   Headjack's crosshair
                   </summary>
                   <returns>True if the crosshair is currently visible</returns>
                   <example> 
                   <b>Example</b>
                   <code>
                       public void HideCrosshair() 
                       {
                           App.ShowCrosshair=false;
                       }
                   </code>
                   </example>
        </member>
        <member name="P:Headjack.App.CurrentPlatform">
                    <summary>
                    Checks the current platform
                    </summary>
                    <returns>The current platform Headjack is running on</returns>
                    @note For testing: You can change this in the Headjack settings window
                    <example> 
                    <b>Example</b>
                    <code>
                       void LogCurrentPlatform
                       {
            #if UNITY_ANDROID
                           if (App.CurrentPlatform == App.VRPlatform.Oculus)
                           {
                               Debug.Log("This app is running on GearVR");
                           }
                           if (App.CurrentPlatform == App.VRPlatform.Cardboard)
                           {
                               Debug.Log("This app is running on Android Cardboard");
                           }
            #endif
            
            #if UNITY_IOS
                           if (App.CurrentPlatform == App.VRPlatform.Cardboard)
                           {
                               Debug.Log("This app is running on Ios Cardboard");
                           }
            #endif
            
            #if UNITY_STANDALONE
                           if (App.CurrentPlatform == App.VRPlatform.Oculus)
                           {
                               Debug.Log("This app is running on Oculus Rift");
                           }
                           if (App.CurrentPlatform == App.VRPlatform.OpenVR)
                           {
                               Debug.Log("This app is running on HTC Vive");
                           }
            			if (App.CurrentPlatform == App.VRPlatform.WindowsMixedReality)
                           {
                               Debug.Log("This app is running on Windows Mixed Reality");
                           }
            #endif
                       }
                    </code>
                    </example>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Headjack.App.ForceConservativeVideoSupport" -->
        <member name="M:Headjack.App.UpdateAvailableMedia(System.String)">
            <summary>
            Check if an update is available for media with given id
            </summary>
        </member>
        <member name="M:Headjack.App.GotMediaFile(System.String)">
            <summary>
            Check if a Media file is already downloaded
            </summary>
        </member>
        <member name="P:Headjack.App.CinemaSupported">
                     <summary>
                     Returns whether the current template supports Cinema, and if this app
                     is allowed to use it
                     </summary>
                     <returns>True if Cinema is supported and allowed</returns>
                     @note Only valid after initialization
                     <example> 
                     <b>Example</b>
                     <code>
                     // Enable a gameobject only if Cinema is allowed
                     public void ToggleGameObjectOnCinemaSupported(GameObject toggleThis) {
                         toggleThis.SetActive(App.CinemaSupported);
                     }
                     </code>
                     </example>
        </member>
        <member name="P:Headjack.App.CinemaConnected">
                    <summary>
                    Returns whether the Cinema server connection is live/online
                    </summary>
                    <returns>True if Cinema server connection is live, otherwise false</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                    // Enable a gameobject only if Cinema server connection is online
                    public void ToggleGameObjectOnCinemaConnect(GameObject toggleThis) {
                        toggleThis.SetActive(App.CinemaConnected);
                    }
                    </code>
                    </example>
        </member>
        <member name="P:Headjack.App.IsVRMode">
                    <summary>
                    Returns whether app is currently running in VR mode (e.g. stereo display), or not (e.g. fullscreen cardboard menu)
                    </summary>
                    <returns>True if the app is currently running in VR mode</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                       // Show message to the user when not in VR mode
                       public void MessageUserNotVR() 
                       {
                           if (!Headjack.App.IsVRMode)
                           {
                               Headjack.App.ShowMessage("You are currently not in VR mode", 5);
                           }
                       }
                    </code>
                    </example>
        </member>
        <member name="P:Headjack.App.CameraScale">
                    <summary>
                    Changing the camera scale will Shrink or Enlarge the world around you. Usefull if an interface needs to get just a little bigger or smaller
                    </summary>
                    <returns>Returns the current camera scale</returns>
                    @note Will clamp between 0.01 and 100
                    <example> 
                    <b>Example</b>
                    <code>
                        //Shrink or grow with the arrow keys
                        void Update()
                        {
                            if (Input.GetKeyDown(KeyCode.UpArrow))
                            {
                                App.CameraScale+=1;
                            }
                            if (Input.GetKeyDown(KeyCode.DownArrow))
                            {
                                App.CameraScale-=1;
                            }
                        }
                    </code>
                    </example>
        </member>
        <member name="T:Headjack.App.AppMetadata">
                    <summary>
                    Container class for app metadata, used by <see cref="M:Headjack.App.GetAppMetadata"/>.
                    </summary>
        </member>
        <member name="F:Headjack.App.AppMetadata.Published">
                        <summary>
                        True if the loaded application is published
                        </summary>
        </member>
        <member name="F:Headjack.App.AppMetadata.ProductName">
                        <summary>
                        The application's name
                        </summary>
        </member>
        <member name="F:Headjack.App.AppMetadata.CompanyName">
                        <summary>
                        Company name
                        </summary>
        </member>
        <member name="T:Headjack.App.VideoMetadata">
                    <summary>
                    Container class for video metadata, used by <see cref="M:Headjack.App.GetVideoMetadata(System.String)"/>.
                    </summary>
        </member>
        <member name="F:Headjack.App.VideoMetadata.id">
                        <summary>
                        Unique ID of the video, differs from projectId
                        </summary>
        </member>
        <member name="F:Headjack.App.VideoMetadata.ProjectionType">
                        <summary>
                        Dimensions tag
                        </summary>
        </member>
        <member name="F:Headjack.App.VideoMetadata.Duration">
                        <summary>
                        Duration of the video in milliseconds
                        </summary>
        </member>
        <member name="F:Headjack.App.VideoMetadata.Width">
                        <summary>
                        The video's dimensions
                        </summary>
        </member>
        <member name="F:Headjack.App.VideoMetadata.Height">
                        <summary>
                        The video's dimensions
                        </summary>
        </member>
        <member name="F:Headjack.App.VideoMetadata.AudioChannels">
                        <summary>
                        The video's dimensions
                        </summary>
        </member>
        <member name="F:Headjack.App.VideoMetadata.DurationMMSS">
                        <summary>
                        Formatted string of video duration
                        </summary>
        </member>
        <member name="F:Headjack.App.VideoMetadata.DurationHHMMSS">
                        <summary>
                        Formatted string of video duration
                        </summary>
        </member>
        <member name="T:Headjack.App.MediaMetadata">
                    <summary>
                    Container class with metadata about a media item (project thumbnail, custom media variable item)
                    </summary>
                    @note Get media metadata using function <see cref="M:Headjack.App.GetMediaMetadata(System.String)"/>
                    @note Some metadata fields are only relevant to particular media items (e.g. <see cref="!:App.MediaData.Width"/> for images)
        </member>
        <member name="F:Headjack.App.MediaMetadata.Id">
                        <summary>
                        Media ID of the item that this metadata describes
                        </summary>
        </member>
        <member name="F:Headjack.App.MediaMetadata.MimeType">
                        <summary>
                        MIME type of this media item (e.g. "image/png")
                        @note certain media items do not have an official MIME type, so they get an unofficial type (e.g. "audio/x-tbe" for a TBE spatial audio file)
                        </summary>
        </member>
        <member name="F:Headjack.App.MediaMetadata.Filename">
                        <summary>
                        Filename of the media item when downloaded (e.g. using <see cref="M:Headjack.App.DownloadSingleMedia(System.String,System.Boolean,Headjack.OnEnd)"/>)
                        @note This is a randomly generated filename and not the original name shown on the Headjack website
                        </summary>
        </member>
        <member name="F:Headjack.App.MediaMetadata.Width">
                        <summary>
                        Width (in pixels) of media item, for image files
                        </summary>
        </member>
        <member name="F:Headjack.App.MediaMetadata.Height">
                        <summary>
                        Height (in pixels) of media item, for image files
                        </summary>
        </member>
        <member name="F:Headjack.App.MediaMetadata.FileSize">
                        <summary>
                        Filesize (in bytes) of media item
                        </summary>
        </member>
        <member name="T:Headjack.App.CategoryMetadata">
                    <summary>
                    Container class for Category metadata, used by <see cref="!:App.GetCategoryMetadata(string categoryId)"/>.
                    </summary>
        </member>
        <member name="F:Headjack.App.CategoryMetadata.Id">
                        <summary>
                        Id of this category
                        </summary>
        </member>
        <member name="F:Headjack.App.CategoryMetadata.Name">
                        <summary>
                        Name of the Category
                        </summary>
        </member>
        <member name="F:Headjack.App.CategoryMetadata.Description">
                        <summary>
                        Additional description of the category
                        </summary>
        </member>
        <member name="F:Headjack.App.CategoryMetadata.ThumbnailId">
                        <summary>
                        Media ID of the thumbnail associated with this category
                        </summary>
        </member>
        <member name="F:Headjack.App.CategoryMetadata.ParentId">
                        <summary>
                        This category's parent category (null if this is not a sub-category)
                        </summary>
        </member>
        <member name="T:Headjack.App.ProjectMetadata">
                   <summary>
                   Container class with metadata about a Project
                   </summary>
                   @note Get Project metadata using function <see cref="!:App.GetProjectMetadata(string)"/>
                   @note Certain fields can be null when they arent uploaded on the server
        </member>
        <member name="F:Headjack.App.ProjectMetadata.Id">
                        <summary>
                        Id of the project
                        </summary>
        </member>
        <member name="F:Headjack.App.ProjectMetadata.Title">
                        <summary>
                        The project's title
                        </summary>
        </member>
        <member name="F:Headjack.App.ProjectMetadata.Description">
                        <summary>
                        The project's description (can be null)
                        </summary>
        </member>
        <member name="F:Headjack.App.ProjectMetadata.Category">
                        <summary>   
                        The category where the project can be found (can be null)
                        </summary>
        </member>
        <member name="F:Headjack.App.ProjectMetadata.ThumbnailId">
                        <summary>
                        The media id of the thumbnail that belongs to this project (can be null)
                        </summary>
        </member>
        <member name="F:Headjack.App.ProjectMetadata.VideoId">
                        <summary>
                        The video that is included in the project (can be null)
                        </summary>
        </member>
        <member name="F:Headjack.App.ProjectMetadata.AudioId">
                        <summary>
                        The external audio that is included in the project (can be null)
                        </summary>
        </member>
        <member name="F:Headjack.App.ProjectMetadata.TotalSize">
                        <summary>
                        Filesize (in <see cref="T:Headjack.App.ByteConversionType"/>) of all files in this project, when downloaded on current device
                        </summary>
        </member>
        <member name="F:Headjack.App.Player">
                     <summary>
                     The video player instance
                     </summary>
                     <returns>The video player instance with it's own functions and variables, see <see cref="T:Headjack.VideoPlayerBase"/> </returns>
        </member>
        <member name="F:Headjack.App.camera">
                    <summary>
                    Transform of headjack's camera
                    </summary>
                    <returns>Transform in the middle of both eyes</returns>
                    @note GameObject associated with this Transform does not have a Camera component
        </member>
        <member name="F:Headjack.App.Crosshair">
                    <summary>
                    Headjack's default crosshiar
                    </summary>
                    <returns>Crosshair class with all settings</returns>
        </member>
        <member name="F:Headjack.App.CrosshairHit">
                    <summary>
            		All raycast information about what the user is looking at
                    </summary>
                    <returns>RaycastHit information</returns>
                    @note Use <see cref="M:Headjack.App.IsCrosshairHit(UnityEngine.GameObject,UnityEngine.RaycastHit@,Headjack.App.RaycastSource)"/> to quickly check if an certain object is being looked at
                    <example> 
                    <b>Example</b>
                    <code>
                        public float DistanceToObjectLookingAt
                        {
                            return App.CrosshairHit.distance;
                        }
                    </code>
                    </example>
        </member>
        <member name="F:Headjack.App.LaserHit">
                    <summary>
            		All raycast information about what the user is pointing at with the motion controller
                    </summary>
                    <returns>RaycastHit information</returns>
                    @note Use <see cref="M:Headjack.App.IsCrosshairHit(UnityEngine.GameObject,UnityEngine.RaycastHit@,Headjack.App.RaycastSource)"/> to quickly check if an certain object is being aimed at
                    <example> 
                    <b>Example</b>
                    <code>
                        public Vector3 AimingLocation
                        {
                            return App.LaserHit.point;
                        }
                    </code>
                    </example>
        </member>
        <member name="F:Headjack.App.TouchHit">
                    <summary>
            		All raycast information about what the user is touching on screen (Cardboard)
                    </summary>
                    <returns>RaycastHit information</returns>
                    @note Use <see cref="M:Headjack.App.IsCrosshairHit(UnityEngine.GameObject,UnityEngine.RaycastHit@,Headjack.App.RaycastSource)"/> to quickly check if an certain object is being touched
                    <example> 
                    <b>Example</b>
                    <code>
                        public GameObject ObjectTouching
                        {
                            return App.TouchHit.collider.gameObject;
                        }
                    </code>
                    </example>
        </member>
        <member name="F:Headjack.App.CurrentVideo">
                    <summary>
                    The id of the video that is currently being played
                    </summary>
                    <returns>The id of the video that is currently being played</returns>
        </member>
        <member name="F:Headjack.App.CurrentProject">
                    <summary>
                    The id of the project that is currently being played
                    </summary>
                    <returns>The id of the project that is currently being played</returns>
        </member>
        <member name="F:Headjack.App.CameraParent">
                    <summary>
                    VR Camera GameObject
                    </summary>
                    <returns>GameObject of the active VR Camera</returns>
                    @note For Camera Position or Rotation, please use <see cref="!:App.Camera"/>. For Disabling or Enabling the Camera, please use <see cref="M:Headjack.App.SetCamera(System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Headjack.App.Initialize(Headjack.OnEnd,System.Boolean,System.Boolean)">
                    @summary Initialize the app and download necessary data
                    <param name="OnReady">Will be called when done</param>
                    <param name="autoCreateCamera">Also activate the VR camera</param>
                    <param name="cardboardStereoMode">(cardboard) VR Mode enabled for cardboard</param>
                    @note Must be called before all other Headjack operations
                    <example> 
                    <b>Example</b>
                    <code>
                    public void Initialize()
                    {
                        App.Initialize(OnReady);
                    }
            
                    public void OnReady(bool Succes)
                    {
                        if (Succes)
                        {
                            print("Initialized!");
                        }else
                        {
                            print("No internet connection");
                        }
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.Reset">
                    @summary Resets the initialization and configuration to allow for a different app initialization
        </member>
        <member name="M:Headjack.App.DownloadAllTextures(Headjack.OnEnd,System.Boolean,Headjack.OnImageProgress)">
            		<summary>
            		Download and import all textures
            		</summary>
            		<param name="OnLoaded">Will be called when done</param>
            		<param name="GenerateMipmaps">Automatically generate mipmaps after importing</param>
            		<param name="OnImageProgress">Will be called with current progress information</param>
            		@note Will only download textures once, or when they are updated on the server
            		<example> 
            		<b>Example</b>
            		<code>
            			public void LoadTextures()
            			{
            				App.LoadAllTextures(OnReady);
            			}
            
            			public void OnReady(bool Succes)
            			{
            				if (Succes)
            				{
            					print("Got all textures!");
            				}else
            				{
            					print("Could not load the textures");
            				}
            			}
            		</code>
            		</example>
        </member>
        <member name="M:Headjack.App.DownLoadSingleTexture(System.String,Headjack.OnEnd,System.Boolean,System.Boolean)">
                    <summary>
                    Download and import a texture
                    </summary>
                    <param name="MediaId">The media id of the texture file</param>
                    <param name="OnLoaded">Will be called when done</param>
            		<param name="UnscaledSlow">Get the raw image from the server</param>
            		<param name="GenerateMipmaps">Automatically generate mipmaps after importing</param>
                    @note Will only download the texture once, or when it is updated on the server
            		@warning Headjack automatically converts images, these have a maximum resolution of 1024x1024. 
            			You can download and import the original file by setting "UnscaledSlow" to true. However, 
            			keep in mind that this can generate CPU spikes and some devices do not support textures higher then 2048x2048. 
                    <example> 
                    <b>Example</b>
                    <code>
                        public void DownLoadSingleTexture()
                        {
                            App.LoadAllTextures("12345678",OnReady);
                        }
            
                        public void OnReady(bool Succes)
                        {
                            if (Succes)
                            {
                                print("Got the texture!");
                            }else
                            {
                                print("Could not download the texture");
                            }
                        }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.Play(System.String,System.Boolean,System.Boolean,Headjack.OnEnd)">
                    <summary>
                    Play a project
                    </summary>
                    <param name="ProjectId">The project you want to play</param>
                    <param name="Stream">Directly stream the video from the server</param>
                    <param name="WifiOnly">(Streaming) only stream when connected to a wifi network</param>
                    <param name="onEnd">Will be called when the video is finished</param>
                    @note Will automatically create and initialize the video player. If stream is false, the video won't play if it isn't downloaded first
                    @warning WifiOnly is strongly recommended when using Stream to avoid high mobile data costs
                    <example> 
                    <b>Example</b>
                    <code>
                    public void StreamFirstVideo()
                    {
                        string id = App.GetProjects()[0];
                        App.Play(id, true, true, onEnd);
                    }
            
                    public void onEnd(bool succes, string error)
                    {
                        print("Video has finished playing!");
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.Download(System.String,System.Boolean,Headjack.OnEnd)">
                     <summary>
                     Download all files in a project
                     </summary>
                     <param name="ProjectId">The project you want to download</param>
                     <param name="WifiOnly">Only download when connected to Wifi</param>
                     <param name="onEnd">Will be called when the download is finished</param>
                     @note Will call onEnd with (false,"NoWifi") if WifiOnly is true and there is no wifi connection
                     <example> 
                     <b>Example</b>
                     <code>
                     public string id;
                     public void DownloadAndPlayFirstVideo()
                     {
                         id = App.GetProjects()[0];
                         App.Download(id, true, OnDownloaded);
                     }
                     public void OnDownloaded(bool succes, string error)
                     {
                         if (succes)
                         {
                             App.Play(id, false, false, null);
                         }else{
            		        Debug.Log(error);
            	        }
                     }
                     </code>
                     </example>
        </member>
        <member name="M:Headjack.App.CanBeDownloaded(System.String)">
                    <summary>
                    Check if a project's contents can be downloaded.
                    </summary>
                    <param name="projectId">Project id</param>
                    <returns>true if the project can be downloaded</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                        public bool DownloadIfPossible(ProjectId)
                        {
            				if(App.CanBeDownloaded(ProjectId))
            				{
            					App.Download(ProjectId);
            					return true;
            				}else{
            					return false;
            				}
                        }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.Cancel(System.String)">
                    <summary>
                    Cancel an active download
                    </summary>
                    <param name="ProjectId">Project download to cancel</param>
                    <example> 
                    <b>Example</b>
                    <code>
                    public void CancelAllDownloads()
                    {
                        string[] projects = App.GetProjects();
                        foreach (string project in projects)
                        {
                            App.Cancel(project);
                        }
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.Delete(System.String)">
                    <summary>
                    Delete all local files of a project
                    </summary>
                    <param name="ProjectId">The project id</param>
                    <example> 
                    <b>Example</b>
                    <code>
                    public void DeleteAllProjects()
                    {
                        string[] projects = App.GetProjects();
                        foreach (string project in projects)
                        {
                            App.Delete(project);
                        }
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.GotFiles(System.String)">
                    <summary>
                    Check if you have all the files of a project
                    </summary>
                    <param name="ProjectId">Project to check</param>
                    <returns>True if you have all the files</returns>
                    @note Does not check if you have the latest version of the files, for that see <see cref="M:Headjack.App.UpdateAvailable(System.String)"/>
                    <example> 
                    <b>Example</b>
                    <code>
                    public void StreamOnlyWhenFilesAreNotPresent(string projectid)
                    {
                        if (App.GotFiles(projectid))
                        {
                            App.Play(projectid, false, false, null);
                        }
                        else
                        {
                            App.Play(projectid, true, true, null);
                        }
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.UpdateAvailable(System.String)">
                    <summary>
                    Check if a project or media file has an update available
                    </summary>
                    <param name="Id">Id to check</param>
                    <returns>True if there is an update available</returns>
                    @warning Will also return True if the files are not yet downloaded!
                    <example> 
                    <b>Example</b>
                    <code>
                    public void CheckForUpdates()
                    {
                        string[] projects = App.GetProjects();
                        foreach (string project in projects)
                        {
                            if(App.UpdateAvailable(project))
                            {
                                print(project + " has an update available!");
                            }
                        }
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.Fade(System.Boolean,System.Single,Headjack.OnEnd)">
                    <summary>
                    Fade screen to or from black
                    </summary>
                    <param name="ToBlack">True to fade to black (fade out), false to fade from black (fade in)</param>
                    <param name="Time">Duration of the fade effect in seconds</param>
                    <param name="OnFade">Event function that gets executed when fade is completed</param>
                    @note Use this function to hide stutter, by fading to black before heavy loading
            
                    @note The parameters of OnFade (bool success, string error) are unused
            
                    <example> 
                    <b>Example</b>
                    <code>
                        UnityEngine.GameObject interface;
                        // This function fades the screen to black for 1.5 seconds and then disables the 'interface' GameObject
                        // Another function has to fade the screen back in, or the screen will remain black
                        void FadeOutInterface()
                        {
                            App.Fade(true, 1.5f, delegate (bool success, string error) {interface.SetActive(false);});
                        }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.IsCrosshairHit(UnityEngine.GameObject,UnityEngine.RaycastHit@,Headjack.App.RaycastSource)">
                    <summary>
                    Returns true if the user is aiming at the target
                    </summary>
                    <param name="target">The object to check</param>
                    <param name="hitInfo">RaycastHit containing all information about the raycast</param>
                    <param name="raycastSource">Where the raycast is coming from</param>
                    <returns>True if the user is looking at the object</returns>
                    @note Object must have a collider (2d colliders won't work)
                    <example> 
                    <b>Example</b>
                    <code>
                        bool IsTheCameraLookingAtMe
                        {
                            return App.IsCrosshairHit(gameobject);
                        }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.IsCrosshairHit(UnityEngine.Collider,UnityEngine.RaycastHit@,Headjack.App.RaycastSource)">
                    <summary>
                    Returns true if the user is aiming at the target
                    </summary>
                    <param name="target">The collider to check</param>
                    <param name="hitInfo">RaycastHit containing all information about the raycast</param>
                    <param name="raycastSource">Where the raycast is coming from</param>
                    <returns>True if the user is looking at the collider</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                        bool IsTheCameraLookingAtMe
                        {
                            return App.IsCrosshairHit(gameobject);
                        }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.IsCrosshairHit(UnityEngine.GameObject,Headjack.App.RaycastSource)">
                    <summary>
                    Returns true if the user is aiming at the target
                    </summary>
                    <param name="target">The object to check</param>
                    <param name="raycastSource">Where the raycast is coming from</param>
                    <returns>True if the user is looking at the object</returns>
                    @note Object must have a collider (2d colliders won't work)
                    <example> 
                    <b>Example</b>
                    <code>
                        bool IsTheCameraLookingAtMe
                        {
                            return App.IsCrosshairHit(gameobject);
                        }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.IsCrosshairHit(UnityEngine.Collider,Headjack.App.RaycastSource)">
                    <summary>
                    Returns true if the user is aiming at the target
                    </summary>
                    <param name="target">The collider to check</param>
                    <param name="raycastSource">Where the raycast is coming from</param>
                    <returns>True if the user is looking at the collider</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                        bool IsTheCameraLookingAtMe
                        {
                            return App.IsCrosshairHit(gameobject);
                        }
                    </code>
                    </example>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Headjack.App.GetProjectMetadata(System.String,Headjack.App.ByteConversionType)" -->
        <member name="M:Headjack.App.GetCategories">
                    <summary>
                    Get all (sub)category IDs used in this app.
                    </summary>
                    <returns>a string array containing all category IDs</returns>
        </member>
        <member name="M:Headjack.App.DestroyVideoPlayer">
                    <summary>
                    Destroys the active videoplayer
                    </summary>
                    <example> 
                    <b>Example</b>
                    <code>
                    GameObject menuObject;
                    public void BackToMenu()
                    {
                       App.DestroyVideoPlayer();
                       menuObject.SetActive(true);
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.ProjectIsLiveStream(System.String)">
                    <summary>
                    Check if a project contains a live stream
                    </summary>
                    <returns>true if the project contains a live stream</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                        public string CheckIfLiveStream(ProjectId)
                        {
                            if(App.ProjectIsLiveStream(ProjectId))
                            {
                                return "Livestream!";
                            }else{
                                return "No Livestream";
                            }
                        }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.IsLiveStream(System.String)">
                    <summary>
                    Check if a project contains a live stream
                    </summary>
                    <returns>true if the project contains a live stream</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                        public string CheckIfLiveStream(ProjectId)
                        {
                            if(App.IsLiveStream(ProjectId))
                            {
                                return "Livestream!";
                            }else{
                                return "No Livestream";
                            }
                        }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.GetCustomVariable(System.String)">
                    <summary>
                    Access custom template variables, downloaded from Headjack
                    </summary>
                    <returns>Returns the string value corresponding to the custom variable key, or null of key does not exist</returns>
                    <param name="key">String key/name identifying the custom variable</param>
                    <example> 
                    <b>Example</b>
                    <code>
                    // Get a Texture object of an additional media item, whose id is passed to this
                    // template using a custom variable called "menu_background_image_id"
                    public Texture2D getBackgroundTexture()
                    {
                        return App.GetImage(App.GetCustomVariable("menu_background_image_id"));
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.GetColor(System.String,UnityEngine.Color)">
                    <summary>
                    Get the app colors, from the server
                    </summary>
                    <returns>Returns the color given in Key</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                    public Color GetBackgroundColor(string key)
                    {
                        return App.GetColor(key,Color.black);
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.ProjectIsDownloading(System.String)">
                    <summary>
                    Check if a project is currently downloading
                    </summary>
                    <param name="ProjectId">Project to check</param>
                    <returns>True if a project is currently downloading</returns>
                    @note To get the progress, use <see cref="M:Headjack.App.GetProjectProgress(System.String)"/>
                    <example> 
                    <b>Example</b>
                    <code>
                    public float GetProgress(string projectid)
                    {
                        if (App.ProjectIsDownloading(projectid))
                        {
                            return App.GetProjectProgress(projectid);
                        }
                        else
                        {
                            return -1;
                        }
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.GetProjectProgress(System.String)">
                    <summary>
                    Get the download progress of a project (0 to 100)
                    </summary>
                    <param name="ProjectId">The project to check</param>
                    <returns>The download progress from 0 to 100, -1 on fail</returns>
                    @note The returned value is not rounded, for displaying smooth loading bars
                    <example> 
                    <b>Example</b>
                    <code>
                    public string GetProgressText(string projectid)
                    {
                        if(!App.ProjectIsDownloading(projectid))
                        {
                            return null;
                        }
                        float progress = App.GetProjectProgress(projectid);
                        return Mathf.FloorToInt(progress).ToString() + "%";
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.RegisterCinemaListener(System.String,Headjack.PushEvent)">
                    <summary>
                    Register listener for a named event from the live Cinema feature
                    </summary>
                    <param name="eventName">Event name listener will be associated with</param>
                    <param name="listener">This delegate will be invoked when event with eventName is activated</param>
                    @note The listener takes a <see cref="!:TinyJSON.ProxyArray"/> parameter, which contains an array of event arguments (use <see cref="!:TinyJSON.ProxyObject.TryGetValue(string, out TinyJSON.Variant)"/> to get these arguments).
                    Cinema default events:
                        "changeAlias": string parameter is new device name/alias
                        "download": download project, string parameter is project ID
                        "play": play project, string parameter is project ID
                        "delete": delete project, string parameter is project ID
                        "stop": stop playback, no parameters
                        "pause": pause playback, no parameters
                        "resume": resume playback, no parameters
                        "view": show project details, string parameter is project ID
                        "stream": stream from url, string parameter is stream url
                        "message": show message to user, string parameter is message
                    <example> 
                    <b>Example</b>
                    <code>
                    public void Start() {
                        App.RegisterCinemaListener("pause", HandleCinemaPause);
                    }
                    // pause video playback
                    public void HandleCinemaPause() {
                        if (App.Player != null) {
                            App.Player.Pause();
                        }
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.RemoveCinemaListener(System.String,Headjack.PushEvent)">
                    <summary>
                    Remove a listener for a named Cinema event
                    </summary>
                    <param name="eventName">Event name listener is associated with</param>
                    <param name="listener">This delegate will be removed from the event's listeners</param>
                    @note See <see cref="M:Headjack.App.RegisterCinemaListener(System.String,Headjack.PushEvent)"/> for more information.
                    <example> 
                    <b>Example</b>
                    <code>
                    PushEvent previouslyRegisteredListener;
            
                    // remove previouslyRegisteredListener from "pause" event listeners
                    public void RemoveListener() {
                        App.RemoveCinemaListener("pause", previouslyRegisteredListener);
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.SendCinemaStatus(System.String,System.String,System.Single,System.Single,System.String)">
                    <summary>
                    Send an updated status to the Cinema server
                    </summary>
                    <param name="statusType">One of several pre-defined status type names</param>
                    <param name="message">A message further detailing the status</param>
                    Pre-defined status types:
                        "error": error occurred, message contains details
                        "playing": currently playing a project
                        "paused": playback of a project is paused
                        "downloading": downloading project/media
                        "idle": nothing active, waiting for command
                    <example> 
                    <b>Example</b>
                    <code>
                    // register listener to "pause" event that sends "paused" status back
                    public void RegisterPauseListener() {
                        App.RegisterCinemaListener("pause", delegate {
                            if (App.Player != null) {
                                App.Player.Pause();
                                App.SendCinemaStatus("paused", "Paused playback of " +
                                    App.GetProjectMetadata(App.CurrentProject).Title);
                            } else {
                                App.SendCinemaStatus("idle", "Nothing to pause");
                            }
                            
                        });
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.SetCamera(System.Boolean,System.Boolean)">
                    <summary>
                    Enable or Disable the default Headjack VR Camera and switch VR mode on Cardboard
                    </summary>
                    <param name="visible">Enable or Disable the VR Camera</param>
                    <param name="vrMode">(Cardboard) Enable or Disable VR mode</param>
                    <example> 
                    <b>Example</b>
                    <code>
                        public void GoFullScreen()
                        {
                            App.SetCamera(true,false);
                        }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.SetCameraBackground(UnityEngine.Color)">
                    <summary>
                    Set background color
                    </summary>
                    <param name="backgroundColor"><see cref="T:UnityEngine.Color"/> object containing new background color</param>
                    @note This sets the background color of the active VR camera, and persists between Unity scenes.
                    <example> 
                    <b>Example</b>
                    <code>
                        // Set backgound color to red
                        public void SetRedBackground()
                        {
                            Headjack.App.SetCameraBackground(Color.red);
                        }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.SetCameraBackground(UnityEngine.Material)">
                    <summary>
                    Set background skybox
                    </summary>
                    <param name="skybox"><see cref="T:UnityEngine.Material"/> object containing new skybox</param>
                    @note This sets the background skybox of the active VR camera, and persists between Unity scenes.
                    <example> 
                    <b>Example</b>
                    <code>
                        // Set the default Unity Skybox to the headjack camera
                        public void SetDefaultSkybox()
                        {
                            Headjack.App.SetCameraBackground(RenderSettings.skybox);
                        }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.Recenter(System.Boolean)">
                    <summary>
                    Recenter orientation and position on your device
                    </summary>
            		<param name="allowRoomScaleHeight">When true, (0,0,0) will be at floor level</param>
                    <example> 
                    <b>Example</b>
                    <code>
                    //Recenter when playing a video
                    void PlayVideo(string id)
                    {
                        App.Recenter();
                        App.Play(id, true, true, null);
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.SetTrackingOrigin(Headjack.App.TrackingOrigin)">
                    <summary>
                    Sets whether to Unity scene is centered on the floor level or the eye level
                    </summary>
                    @note For VR platforms that do not have an internal floor height, using 1.6m below current eye height
        </member>
        <member name="M:Headjack.App.GetTrackingOrigin">
                    <summary>
                    Gets whether to Unity scene is centered on the floor level or the eye level
                    </summary>
        </member>
        <member name="M:Headjack.App.GetTitle(System.String)">
                    <summary>
                    Get the title of the given project
                    </summary>
                    <param name="ProjectId">The project id</param>
                    <returns>The title of the project with ProjectId</returns>
                    @note To get a list with available projects, use <see cref="M:Headjack.App.GetProjects(System.String,System.Int32,System.Int32)"/>
                    <example> 
                    <b>Example</b>
                    <code>
                        public string GetFirstTitle()
                        {
                            string[] ids = App.GetProjects();
                            return App.GetTitle(ids[0]);
                        }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.GetDescription(System.String)">
                    <summary>
                    Get the Description of the given project
                    </summary>
                    <param name="ProjectId">The project id</param>
                    <returns>The description of the project with ProjectId, null if the project has no description</returns>
                    @note To get a list with available projects, use <see cref="M:Headjack.App.GetProjects(System.String,System.Int32,System.Int32)"/>
                    @warning When using this, make sure to check if the string is not null before using to avoid NullReference exceptions
                    <example> 
                    <b>Example</b>
                    <code>
                        public string GetFirstDescription()
                        {
                            string[] ids = App.GetProjects();
                            return App.GetDescription(ids[0]);
                        }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.GetProjects(System.String,System.Int32,System.Int32)">
                    <summary>
                    Contains all available projects from the server
                    </summary>
                    <param name="CategoryId">Only return projects that fit in this category filter</param>
                    <param name="MaxPageSize">Only return a part from the list</param>
                    <param name="CurrentPage">The part of the list to return. Starting at 0</param>
                    <returns>A list with project ids</returns>
                    @note Use <see cref="M:Headjack.App.GetCategories"/> To get all available categories.
                    <example> 
                    <b>Example</b>
                    <code>
                        //In this case, 5 projects per page
                        public string[] WhatsOnTheFirstPage
                        {
                            return App.GetProjects(null,5,0);
                        }
            
                        public string[] WhatsOnTheLastPage
                        {
                            return App.GetProjects(null,5,int.MaxValue);
                        }
                    </code>
                    </example>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Headjack.App.GetImage(System.String,System.Boolean)" -->
        <member name="M:Headjack.App.GetAdditionalMedia">
                   <summary>
                   Get IDs of extra media items from server
                   </summary>
                   <returns>List of ID strings of extra media items as entered on Headjack "Edit app" page</returns>
                   @note Download a media item from this list using <see cref="M:Headjack.App.DownloadSingleMedia(System.String,System.Boolean,Headjack.OnEnd)"/>
                   @note Load the downloaded media as texture using <see cref="!:App.DownLoadSingleTexture(string, OnEnd, bool, bool)(string, OnEnd)"/>
                   @note Get metadata for media item using <see cref="M:Headjack.App.GetMediaMetadata(System.String)"/>
                   <example> 
                   <b>Example</b>
                   <code>
                       // return number of extra media items
                       public int GetNumberOfExtraMedia()
                       {
                           return App.GetAdditionalMedia().Count;
                       }
                   </code>
                   </example>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Headjack.App.DownloadSingleMedia(System.String,System.Boolean,Headjack.OnEnd)" -->
        <member name="M:Headjack.App.ShowMessage(System.String,System.Single,Headjack.OnEnd)">
                    <summary>
                    PopUp Messages for displaying a text
                    </summary>
                    <example> 
                    <b>Example</b>
                    <code>
                        public void SayHello()
                        {
                            App.ShowMessage("Hello world", 1f);
                        }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.GetAppMetadata">
                    <summary>
                    Get metadata for the app
                    </summary>
                    <returns><see cref="T:Headjack.App.AppMetadata"/> class containing metadata for app</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                       bool IsMyAppPublished()
                       {
                           return Headjack.App.GetAppMetadata().Published;               
                       }
                    </code>
                    </example>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Headjack.App.GetVideoMetadata(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Headjack.App.GetMediaMetadata(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Headjack.App.GetCategoryMetadata(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Headjack.App.GetMediaFullPath(System.String)" -->
        <!-- Badly formed XML comment ignored for member "T:Headjack.App.ByteConversionType" -->
        <member name="T:Headjack.App.RaycastSource">
            	   <summary>
            	   Where the raycast is coming from
            	   </summary>
            	   @note Supported motion controllers are "Vive Controller", "Oculus Touch", "Daydream Controller"
        </member>
        <member name="T:Headjack.App.VRPlatform">
                    <summary>
                    VR platform that Headjack is running on
                    </summary>
                    @note For testing: You can change this in the Headjack settings window
            		@note Use <see cref="P:Headjack.App.CurrentPlatform"/> to get the currently loaded platform
        </member>
        <member name="T:Headjack.App.TrackingOrigin">
                    <summary>
                    Whether the Unity scene origin is set to VR eye level, floor level or the legacy behavior dependent on VR platform
                    </summary>
        </member>
        <member name="P:Headjack.CustomVariables.availableVariables">
            		<summary>
            		Get an array of all available variables in CustomVariables
            		</summary>
            		<returns>string[] containing all available variables in Custom Variables</returns>
            		<example> 
            		<b>Example</b>
            		<code>
            		void LogAllCustomVariables()
            		{
            			string[] allVariables = CustomVariables.availableVariables;
            			if (allVariables == null)
            			{
            				Debug.Log("No Custom Variables Found!");
            			}
            			else
            			{
            				foreach(string s in allVariables)
            				{
            					Debug.Log("Custom Variable Found: " + s);
            				}
            			}
            		}
            		</code>
            		</example>
        </member>
        <member name="M:Headjack.CustomVariables.GetReturnType(System.String)">
            		<summary>
            		The return type of a global variable
            		</summary>
            		<param name="variable">The variable to check</param>
            		<returns>System.Type of the variable</returns>
            		<example> 
            		<b>Example</b>
            		<code>
            		void LogFirstVariableType()
            		{
            			string[] allVariables = CustomVariables.availableVariables;
            			if (allVariables == null)
            			{
            				Debug.Log("No variables found");
            			}
            			else
            			{
            				System.Type variableType = CustomVariables.GetReturnType(allVariables[0]);
            				Debug.Log("First variable's type: " + variableType);
            			}
            		}
            		</code>
            		</example>
        </member>
        <member name="M:Headjack.CustomVariables.TryGetVariable``1(System.String,``0@,System.String)">
            		<summary>
            		Try getting a variable's value
            		</summary>
            		<returns>True if the variable was found and casted to the requisted type</returns>
            		<param name="variable">The variable's name</param>
            		<param name="result">The result will be set to this out parameter</param>
            		<param name="projectId">(Optional) When a "per project" variable, use this parameter</param>
            		@note result will be set to the requisted type's default value if failed
            		<example> 
            		<b>Example</b>
            		<code>
            		Color c;
            		if (CustomVariables.TryGetVariable&lt;Color&gt;("PrimaryColor", out c))
            		{
            			Debug.Log("Succes!");
            		}
            		string s;
            		if (CustomVariables.TryGetVariable&lt;string&gt;("App Title", out s))
            		{
            			Debug.Log("Succes!");
            		}
            		</code>
            		</example>
        </member>
        <member name="M:Headjack.CustomVariables.GetVariable``1(System.String,System.String)">
            		<summary>
            		Get a variable's value
            		</summary>
            		<returns>The value if it was found and casted to the requisted type, the type's default value on fail</returns>
            		<param name="variable">The variable to check</param>
            		<param name="projectId">(Optional) When a "per project" variable, use this parameter</param>
            		@warning Will throw an error on fail, but will return the default value so your code can continue
            		<example> 
            		<b>Example</b>
            		<code>
            		System.DateTime timeToStart = GetVariable&lt;System.DateTime&gt;("TimeToStart");
            		string LanguageOfFirstProject = GetVariable&lt;string&gt;("Language", App.GetProjects()[0]);
            		</code>
            		</example>
        </member>
        <member name="T:Headjack.DaydreamPermissions">
            <summary>
            Daydream apps require special app permission prompting/granting logic
            </summary>
        </member>
        <member name="M:Headjack.DaydreamPermissions.PromptPermissions(System.String[])">
            <summary>
            Uses the Google VR SDK app permission logic to
            ask the user for specific permissions
            </summary>
        </member>
        <member name="T:Headjack.Cinema.ServerMetadata">
            <summary>
            Data class to hold server metadata including server device ID and server time offset for synchronization
            </summary>
        </member>
        <member name="T:Headjack.Cinema.LocalClient">
            <summary>
            Local cinema client, which can discovery local cinema servers
            and handles the connection(s) and messages
            </summary>
        </member>
        <member name="P:Headjack.Cinema.LocalClient.Instance">
            <summary>
            Singleton instance of cinema client
            </summary>
        </member>
        <member name="P:Headjack.Cinema.LocalClient.Servers">
            <summary>
            Returns first peer/server in connection list (otherwise null), useful for looping through connections
            </summary>
        </member>
        <member name="M:Headjack.Cinema.LocalClient.RegisterMessageHandler(Headjack.Cinema.Messages.MessageBase)">
            <summary>
            Register a new message handler that will serialize/deserialize network messages with a particular type number
            </summary>
            <param name="handler">New message handler to register with this client</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Headjack.Cinema.LocalClient.SendMessage(Headjack.Cinema.Messages.MessageBase)" -->
        <!-- Badly formed XML comment ignored for member "M:Headjack.Cinema.LocalClient.SendMessage(LiteNetLib.NetPeer,Headjack.Cinema.Messages.MessageBase)" -->
        <member name="T:Headjack.Cinema.ClientMetadata">
            <summary>
            Data class to hold client metadata including device ID and whether this device can receive commands
            </summary>
        </member>
        <member name="T:Headjack.Cinema.LocalServer">
            <summary>
            Local cinema remote control server, which handles the server discovery 
            and handles the device connections
            </summary>
        </member>
        <member name="M:Headjack.Cinema.LocalServer.RegisterMessageHandler(Headjack.Cinema.Messages.MessageBase)">
            <summary>
            Register a new message handler that will serialize/deserialize network messages with a particular type number
            </summary>
            <param name="handler">New message handler to register with this server</param>
        </member>
        <member name="M:Headjack.Cinema.LocalServer.RegisterMessageCallback(Headjack.Cinema.Messages.MessageCallback)">
            <summary>
            Register a callback function that will be executed when a new message arrives
            </summary>
        </member>
        <member name="M:Headjack.Cinema.LocalServer.UnregisterMessageCallback(Headjack.Cinema.Messages.MessageCallback)">
            <summary>
            Unregister a registered callback function
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Headjack.Cinema.LocalServer.SendMessage(Headjack.Cinema.Messages.MessageBase)" -->
        <!-- Badly formed XML comment ignored for member "M:Headjack.Cinema.LocalServer.SendMessage(LiteNetLib.NetPeer,Headjack.Cinema.Messages.MessageBase)" -->
        <member name="M:Headjack.Cinema.LocalServer.GetMaxPing">
            <summary>
            Get maximum latency of all connected clients (max RTT/2 in ms)
            </summary>
        </member>
        <member name="M:Headjack.Cinema.LocalServer.StopServer(System.Boolean)">
            <summary>
            stop all connections and stop discovery responses
            </summary>
        </member>
        <member name="M:Headjack.Cinema.LocalServer.StartServer">
            <summary>
            Start server and network discovery
            </summary>
        </member>
        <member name="M:Headjack.Cinema.LocalServer.SendSyncResponse(LiteNetLib.NetPeer,Headjack.Cinema.Messages.MessageSync)">
            <summary>
            Sends back a response to a sync request by including the currently timestamp (in ms) of this server
            </summary>
            <param name="peer">peer/client that requested the sync message</param>
            <param name="messageSync">the data in the sync request</param>
        </member>
        <member name="T:Headjack.Cinema.Messages.DefaultMessages">
            <summary>
            The message IDs of the default messages included with Headjack Cinema,
            for custom message IDs, start at DefaultMessages.HighestDefault
            </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessageBase">
            <summary>
            Base class that all Cinema message (client->server and server->client) derive from
            </summary>
        </member>
        <member name="M:Headjack.Cinema.Messages.MessageBase.SanitizeText(System.String)">
            <summary>
            Ensures max text message length for cinema Messages
            </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessageCancelDownload">
             <summary>
            
             </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessageConnect">
             <summary>
            
             </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessageDeleteProject">
             <summary>
            
             </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessageDeviceHealth">
             <summary>
            
             </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessageDeviceInfo">
             <summary>
            
             </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessageDeviceNumber">
             <summary>
            
             </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessageDisconnect">
             <summary>
            
             </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessageDownloadProgress">
             <summary>
            
             </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessageDownloadProject">
             <summary>
            
             </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessageLog">
             <summary>
            
             </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessageName">
             <summary>
            
             </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessagePauseAt">
             <summary>
            
             </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessagePlayAt">
             <summary>
            
             </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessagePlayback">
            <summary>
            Video playback state (progress, player state, etc.)
            </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessagePrepareVideo">
             <summary>
            
             </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessageSeekTo">
             <summary>
            
             </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessageSetCinema">
             <summary>
            
             </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessageShowMessage">
             <summary>
            
             </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessageShowProject">
             <summary>
            
             </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessageStatus">
             <summary>
            
             </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessageStopPlayback">
             <summary>
            
             </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessageSync">
             <summary>
            
             </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessageSynced">
             <summary>
            
             </summary>
        </member>
        <member name="T:Headjack.Cinema.Messages.MessageViewDirection">
             <summary>
            
             </summary>
        </member>
        <member name="T:Headjack.Cinema.SyncedTime">
            <summary>
            Syncs time between this client and a server by analysing multiple sync events
            </summary>
        </member>
        <member name="T:Headjack.Utils.TimeStamp">
            <summary>
            Helper fpr Unix epoch timestamp
            </summary>
        </member>
        <member name="M:Headjack.Tools.CropTexture(UnityEngine.Material,System.String,System.Single,System.Single,System.String)">
                    <summary>
                    Set texture into a material and crop it to a specific aspect ratio
                    </summary>
                    <example> 
                    <b>Example</b>
                    <code>
                        void ApplyTexture(string id, Material material)
                        {
            				CropTexture(material,id,1920,1080,null);
                        }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.Tools.CropTexture(UnityEngine.Material,System.String,System.Single,System.String)">
                    <summary>
                    Set texture into a material and crop it to a specific aspect ratio
                    </summary>
                    <example> 
                    <b>Example</b>
                    <code>
                        void ApplyTexture(string id, Material material)
                        {
            				CropTexture(material,id,16f/9f,null);
                        }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.Tools.GenerateVideoSphere(System.Int32)">
                    <summary>
                    Generate a UV Sphere
                    </summary>
            		<param name="Resolution">Grid resolution</param>
                    <returns>The generated mesh</returns>
                    @note UV Spheres have correct uv coordinates for textures
        </member>
        <member name="M:Headjack.Tools.GenerateSortedSphere(System.Int32)">
                    <summary>
                    Generate a Normalized Cube
                    </summary>
            		<param name="Resolution">Grid resolution</param>
                    <returns>The generated mesh</returns>
                    @note Normalized cube has more spread out vertex positions
        </member>
        <member name="M:Headjack.Tools.FitTextToBounds(UnityEngine.TextMesh,System.String,UnityEngine.Vector2,UnityEngine.Vector2)">
                    <summary>
                    Resize a textmesh to fit certain bounds
                    </summary>
            		<param name="target">The target textmesh</param>
            		<param name="newText">The text to apply</param>
            		<param name="maxSize">Max physical size in Unity units</param>
            		<param name="minMaxFontSize">Minimal and Maximal font size. Too high will cause aliasing, to low will cause blurriness</param>
                    <returns>True on succes</returns>
                    @note To apply the correct font sharpness, there is a tool window under "Headjack/Tools/Font Bitmap Scaler"
                    <example> 
                    <b>Example</b>
                    <code>
            			Textmesh mesh;
                        void FitInSquaredMeter(string text)
                        {
                            FitTextToBounds(mesh,text,new Vector2(1,1),new Vector2(16,48));
                        }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.Tools.FitTextToBounds(UnityEngine.TextMesh,System.String,UnityEngine.Vector2,System.Int32,System.Int32)">
                    <summary>
                    Resize a textmesh to fit certain bounds
                    </summary>
            		<param name="target">The target textmesh</param>
            		<param name="newText">The text to apply</param>
            		<param name="maxSize">Max physical size in Unity units</param>
            		<param name="minFontSize">Minimal font size. To low will cause blurriness</param>
            		<param name="maxFontSize">Maximal font size. Too high will cause aliasing</param>
                    <returns>True on succes</returns>
                    @note To apply the correct font sharpness, there is a tool window under "Headjack/Tools/Font Bitmap Scaler"
                    <example> 
                    <b>Example</b>
                    <code>
            			Textmesh mesh;
                        void FitInSquaredMeter(string text)
                        {
                            FitTextToBounds(mesh,text,new Vector2(1,1),16,48);
                        }
                    </code>
                    </example>
        </member>
        <member name="T:Headjack.Tools.BlurQuality">
                    <summary>
                    Blurred image's color quality
                    </summary>
                    @note Default is always ARGB32, only use RGB565 by encountering memory issues
        </member>
        <member name="M:Headjack.Tools.BlurImage(UnityEngine.Texture,System.Boolean,Headjack.Tools.BlurQuality,System.Int32,System.Int32)">
                    <summary>
                    Apply Gaussian blur to a texture
                    </summary>
            		<param name="texture">The target texture</param>
            		<param name="Mipmaps">Also generate mipmaps</param>
            		<param name="Quality">Color Quality</param>
            		<param name="newWidth">The output texture's width</param>
            		<param name="newHeight">The output texture's height</param>
                    <returns>A rendertexture with the image blurred</returns>
                    @note Apply a few times for a more blurred effect
        </member>
        <member name="P:Headjack.Tools.VideoTexture">
                    <summary>
            		The active video's streaming texture
                    </summary>
                    <returns>The active video's streaming texture</returns>
        </member>
        <member name="M:Headjack.Tools.CleanUpPersistentDataPath">
                    <summary>
            		Remove unused Video folders in PersistentDataPath
                    </summary>
        </member>
        <member name="F:Headjack.UHDSupportInfo.useConservativeSupport">
            <summary>
            conservative support returns "not supported" on videos over a modest resolution,
            regardless of video source
            </summary>
        </member>
        <member name="T:Headjack.VideoPlayerBase.AudioConfig">
                    <summary>
                    Description of which audio tracks are playing, audio track in video file (internal) and/or external spatial audio file.
                    Get the current audio configuration using <see cref="M:Headjack.VideoPlayerBase.GetAudioConfig"/>, set the audio configuration using <see cref="M:Headjack.VideoPlayerBase.SetAudioConfig(System.Boolean,System.Boolean)"/>.
                    </summary>
        </member>
        <member name="F:Headjack.VideoPlayerBase.AudioConfig.Internal">
                        <summary>
                        Describes whether the audiotrack embedded in the video file is enabled
                        </summary>
        </member>
        <member name="F:Headjack.VideoPlayerBase.AudioConfig.External">
                        <summary>
                        Describes whether the audiotrack embedded in the video file is enabled
                        </summary>
        </member>
        <member name="T:Headjack.VideoPlayerBase.Status">
            		<summary>
            		Status codes of videoplayer returned by GetStatus()
            		</summary>
        </member>
        <member name="F:Headjack.VideoPlayerBase.Eyes">
                    <summary>
                    Left and Right Eye are accessible
                    </summary>
                    <returns>GameObject[2] with Left in 0 and Right in 1</returns>
        </member>
        <member name="P:Headjack.VideoPlayerBase.Buffering">
                    <summary>
                    True if the videoplayer is buffering
                    </summary>
                    <returns>If the videoplayer is buffering</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                    //Show buffering icon when buffering
                    void Update()
                    {
                    if(App.Player.Buffering)
                    {
            	        BufferingObject.SetActive(true);
                    }else{
            	        BufferingObject.SetActive(false);
                    }
                    }   
                    </code>
                    </example>
        </member>
        <member name="P:Headjack.VideoPlayerBase.Volume">
                    <summary>
                    Videoplayer volume
                    </summary>
                    <returns>The current volume of the videoplayer</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                    //Change volume with Arrow Keys
                    void Update()
                    {
                    if (Input.GetKeyDown(KeyCode.UpArrow))
                    {
                        App.Player.Volume += 0.1f;
                        }
                    if (Input.GetKeyDown(KeyCode.DownArrow))
                    {
                        App.Player.Volume -= 0.1f;
                    }
                    }   
                    </code>
                    </example>
        </member>
        <member name="P:Headjack.VideoPlayerBase.Seek">
                    <summary>
                    The video position (0.0 - 1.0)
                    </summary>
                    <returns>The current position of the video from 0.0 to 1.0</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                    //Change position with Arrow Keys
                    void Update()
                    {
                    if (Input.GetKeyDown(KeyCode.RightArrow))
                    {
                        App.Player.Seek += 0.05f;
                        }
                    if (Input.GetKeyDown(KeyCode.LeftArrow))
                    {
                        App.Player.Seek -= 0.05f;
                    }
                    }   
                    </code>
                    </example>
        </member>
        <member name="P:Headjack.VideoPlayerBase.SeekMs">
                    <summary>
                    The video position in milliseconds
                    </summary>
                    <returns>The current position of the video in milliseconds</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                    //Change position by 5 seconds with Arrow Keys
                    void Update()
                    {
                    if (Input.GetKeyDown(KeyCode.RightArrow))
                    {
                        App.Player.SeekMs += 5000;
                        }
                    if (Input.GetKeyDown(KeyCode.LeftArrow))
                    {
                        App.Player.SeekMs -= 5000;
                    }
                    }   
                    </code>
                    </example>
        </member>
        <member name="P:Headjack.VideoPlayerBase.Loop">
                    <summary>
                    If this is a looping video
                    </summary>
                    <returns>If the video is currently set to loop</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                    public void LoopButtonSwitch()
                    {
                    App.Player.Loop=!App.Player.Loop;
                    }
                    </code>
                    </example>
        </member>
        <member name="P:Headjack.VideoPlayerBase.Mute">
                    <summary>
                    If this video is muted
                    </summary>
                    <returns>If the video is currently muted</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                    public void MuteButtonSwitch()
                    {
                    App.Player.Mute=!App.Player.Mute;
                    }
                    </code>
                    </example>
        </member>
        <member name="P:Headjack.VideoPlayerBase.Duration">
                    <summary>
                    The total duration of the video
                    </summary>
                    <returns>The total duration of the video in milliseconds</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                    public float VideoLengthInSeconds()
                    {
                        return App.Player.Duration*0.001f;
                    }
                    </code>
                    </example>
        </member>
        <member name="P:Headjack.VideoPlayerBase.IsPlaying">
                    <summary>
                    If the video is being played right now
                    </summary>
                    <returns>True if the video is being played right now</returns>
                    @note False on pause
                    <example> 
                    <b>Example</b>
                    <code>
                    void Update()
                    {
                    //Don't show the crosshair if the video is playing
                    if(App.Player.IsPlaying)
                    {
                        App.ShowCrosshair=false;
                    }
                    }
                    </code>
                    </example>
        </member>
        <member name="P:Headjack.VideoPlayerBase.LastVideoTime">
            <summary> 
            The video timestamp of the latest command/function (e.g PauseAt or PlayAt)
            </summary>
        </member>
        <member name="P:Headjack.VideoPlayerBase.LastTimestamp">
            <summary> 
            The realtime local timestamp of the latest command/function (e.g PauseAt or PlayAt)
            </summary>
        </member>
        <member name="P:Headjack.VideoPlayerBase.IsStream">
                    <summary>
                    Whether the current video is streaming or not
                    </summary>
                    <returns>True if the video is being streamed right now</returns>
        </member>
        <member name="P:Headjack.VideoPlayerBase.CurrentStatus">
                    <summary>
                    The current playback status
                    </summary>
                    <returns>True if the video is being streamed right now</returns>
        </member>
        <member name="M:Headjack.VideoPlayerBase.SetAudioConfig(System.Boolean,System.Boolean)">
            		<summary>
            		Sets audio configuration, whether to play audio of video file and whether to play external (spatial) audio file
            		</summary>
            		<param name="internalAudio">set to true to enable video audio track</param>
            		<param name="externalAudio">set to true to enable external (spatial) audio track</param>
            		@note enabling both internal and external audio causes both tracks to play simultaneously
            
            		@note enabling the external audio track without an external audio file being present in the project has no effect
        </member>
        <member name="M:Headjack.VideoPlayerBase.GetAudioConfig">
                    <summary>
                    Gets the audio playing configuration, whether playing audio of video file (internal) and/or playing external (spatial) audio file (external)
                    </summary>
                    <returns><see cref="T:Headjack.VideoPlayerBase.AudioConfig"/> struct describing current audio configuration</returns>
                    @note use <see cref="M:Headjack.VideoPlayerBase.SetAudioConfig(System.Boolean,System.Boolean)"/> to change the audio configuration
        </member>
        <member name="M:Headjack.VideoPlayerBase.Play(System.String,System.Boolean,Headjack.OnEnd,System.String)">
                    <summary>
                    Play a new video
                    </summary>
                    <param name="FullPath">Full path to the mp4 file</param>
                    <param name="onEnd">Will be called when the video is finished</param>
                    @note onEnd overwrites current onEnd
                    @warning You need a full path to the mp4 file. To play videos from the server use <see cref="M:Headjack.App.Play(System.String,System.Boolean,System.Boolean,Headjack.OnEnd)"/>
        </member>
        <member name="M:Headjack.VideoPlayerBase.PlayAt(System.Int64,System.Int64)">
            <summary>
            Start playing the currently loaded video from a specific time, starting on a specific timestamp
            </summary>
            <param name="playTime">Realtime (local) timestamp to start playing</param>
            <param name="videoTime">Video timecode to start playing from</param>
        </member>
        <member name="M:Headjack.VideoPlayerBase.PauseAt(System.Int64)">
            <summary>
            Pause the video at a specific timestamp
            NOTE: video is paused on a timecode derived from the realtime timestamp
            </summary>
            <param name="pauseTime">Realtime (local) timestamp to pause playback</param>
        </member>
        <member name="M:Headjack.VideoPlayerBase.Pause">
                    <summary>
                    Pause the video
                    </summary>
                    @note Will set VideoPlayer.IsPlaying to false
                    <example> 
                    <b>Example</b>
                    <code>
                    void Update()
                    {
                    if (Input.GetKeyDown(KeyCode.Space))
                    {
                        App.Player.Pause();
                    }
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.VideoPlayerBase.Resume">
                    <summary>
                    Resume the video
                    </summary>
                    @note Will set VideoPlayer.IsPlaying to true
                    <example> 
                    <b>Example</b>
                    <code>
                    void Update()
                    {
                    if (Input.GetKeyDown(KeyCode.Space))
                    {
                        App.Player.Resume();
                    }
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.VideoPlayerBase.PauseResume">
                    <summary>
                    Switch between playing and paused
                    </summary>
                    <example> 
                    <b>Example</b>
                    <code>
                    void Update()
                    {
                    //Pause switch
                    if (Input.GetKeyDown(KeyCode.Space))
                    {
                        App.Player.PauseResume();
                    }
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.VideoPlayerBase.Clean">
                    <summary>
                    Clean up the video
                    </summary>
                    <example> 
                    <b>Example</b>
                    <code>
                    public void Release()
                    {
            			App.Player.Clean();
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.VideoPlayerBase.Stop">
                    <summary>
                    Stop the video
                    </summary>
                    <example> 
                    <b>Example</b>
                    <code>
                    public void StopVideo()
                    {
                    App.Player.Stop();
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.VideoPlayerBase.SetEyes(System.Boolean,System.Boolean)">
                    <summary>
                    Stereoscopic settings
                    </summary>
                    <param name="InputIsStereo">Is the video stereoscopic</param>
                    <param name="OutputIsStereo">Display in stereoscopic</param>
                    @warning This will be automatically set with <see cref="M:Headjack.App.Play(System.String,System.Boolean,System.Boolean,Headjack.OnEnd)"/>. Use <see cref="!:VideoPlayer.SetStereoscopicRendering(bool)"/> to switch enable/disable the stereoscopic rendering
        </member>
        <member name="M:Headjack.VideoPlayerBase.SetStereoscopicRendering(System.Boolean)">
            <summary>
            Stereoscopic video rendering
            </summary>
            <param name="Stereoscopic">Render stereoscopic</param>
            @note You can use this to disable the stereo effect if you want to display an interface
            <example> 
            <b>Example</b>
            <code>
            public void SwitchToMono()
            {
            App.Player.SetStereoscopicRendering(false);
            }
            </code>
            </example>
        </member>
        <member name="M:Headjack.VideoPlayerBase.FocusAt(System.Int32)">
            <summary>
            Focus at a certain direction in the video
            </summary>
            <param name="Degrees">Direction in degrees</param>
            @note You can use this to disable the stereo effect if you want to display an interface
        </member>
        <member name="F:Headjack.VideoPlayerBase.subtitles">
            <summary>
            Subtitle class
            </summary>
        </member>
        <member name="M:Headjack.VideoPlayer_EXO.GetActivity">
            Returns the Android Activity used by the Unity device player. The caller is
            responsible for memory-managing the returned AndroidJavaObject.
        </member>
        <member name="M:Headjack.VideoPlayer_EXO.GetApplicationContext(UnityEngine.AndroidJavaObject)">
            Returns the application context of the current Android Activity.
        </member>
        <member name="P:Headjack.VRInput.MotionControllerShow">
                    <summary>
                    Show the motion controller, it will be glass/seethrough if false
                    </summary>
                    <example> 
                    <b>Example</b>
                    <code>
                    public void ShowControllerWhenHoldingTrigger()
                    {
                    if (VRInput.Confirm.Hold)
                    {
                        VRInput.MotionControllerShow=true;
                    }else
                    {
                        VRInput.MotionControllerShow=false;
                    }
                    }
                    </code>
                    </example>
        </member>
        <member name="P:Headjack.VRInput.MotionControllerAvailable">
                    <summary>
                    Check if a motion controller is connected
                    </summary>
                    <returns>True if a motion controller is connected</returns>
        </member>
        <member name="P:Headjack.VRInput.MotionControllerColor">
                    <summary>
                    The color of the laser pointer, can be set or get
                    </summary>
            		<returns>Current color of the motion controller laser</returns>
        </member>
        <member name="P:Headjack.VRInput.LaserTransform">
                    <summary>
                    Get the transform of the motion controller laser (if available)
                    </summary>
                    <example> 
                    <b>Example</b>
                    <code>
                    public void GameObjectToLaserPosition(GameObject target)
                    {
                       target.transform.position = Headjack.VRInput.LaserTransform.position;
                    }
                    </code>
                    </example>
        </member>
        <member name="F:Headjack.VRInput.Confirm">
                    <summary>
                    VR Input button
                    </summary>
                    @note Left mouse button - Space - Screen tap - Oculus Remote Confirm - Gear VR touchpad tap - Vive Trigger
                    <example> 
                    <b>Example</b>
                    <code>
                    public void CheckIfClickedOnMe()
                    {
                    if (App.IsCrosshairHit(gameObject))
                    {
                        if (VRInput.Confirm.Pressed)
                        {
                            print("Clicked on me!");
                        }
                    }
                    }
                    </code>
                    </example>
        </member>
        <member name="F:Headjack.VRInput.Back">
                    <summary>
                    VR Back button
                    </summary>
                    @note Escape button - Android back button - Oculus Remote Return - Gear VR Back button - Vive Menu button
                    <example> 
                    <b>Example</b>
                    <code>
                    void Update()
                    {
            			//Destroy videoplayer when "Back button" is pressed
                        if (VRInput.Back.Pressed)
                        {
                            App.DestroyVideoPlayer();
                        }
                    
                    }
                    </code>
                    </example>
        </member>
        <member name="F:Headjack.VRInput.MotionControllerLaser">
                    <summary>
                    Show the laser of the motion controller
                    </summary>
                    <example> 
                    <b>Example</b>
                    <code>
                    public void ShowLaserWhenHoldingTrigger()
                    {
                       if (VRInput.Confirm.Hold)
                       {
                           VRInput.MotionControllerLaser=true;
                       }else
                       {
                           VRInput.MotionControllerLaser=false;
                       }
                    }
                    </code>
                    </example>
        </member>
        <member name="T:Headjack.VRInput.VrButton">
                    <summary>
                    Button class, Confirm and Back are universal across all platforms
                    </summary>
        </member>
        <member name="T:Headjack.VRInput.Remote">
            <summary>
            Class managing the motion controller
            </summary>
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_ApplicationLifecycle_LaunchIntentChanged">
            Sent when a launch intent is received (for both cold and warm starts). The
            payload is the type of the intent. ApplicationLifecycle.GetLaunchDetails()
            should be called to get the other details.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_AssetFile_DownloadUpdate">
            Sent to indicate download progress for asset files.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Cal_FinalizeApplication">
            Result of a leader picking an application for CAL launch.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Cal_ProposeApplication">
            Application that the group leader has proposed for a CAL launch.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_HTTP_Transfer">
            Sent to indicate that more data has been read or an error occured.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Livestreaming_StatusChange">
            Indicates that the livestreaming session has been updated. You can use this
            information to throttle your game performance or increase CPU/GPU
            performance. Use Message.GetLivestreamingStatus() to extract the updated
            livestreaming status.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Matchmaking_MatchFound">
            Indicates that a match has been found, for example after calling
            Matchmaking.Enqueue(). Use Message.GetRoom() to extract the matchmaking
            room.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Networking_ConnectionStateChange">
            Indicates that a connection has been established or there's been an error.
            Use NetworkingPeer.GetState() to get the result; as above,
            NetworkingPeer.GetID() returns the ID of the peer this message is for.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Networking_PeerConnectRequest">
            Indicates that another user is attempting to establish a P2P connection
            with us. Use NetworkingPeer.GetID() to extract the ID of the peer.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Networking_PingResult">
            Generated in response to Net.Ping(). Either contains ping time in
            microseconds or indicates that there was a timeout.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Party_PartyUpdate">
            Indicates that party has been updated
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Room_InviteAccepted">
             Indicates that the user has accepted an invitation, for example in Oculus
             Home. Use Message.GetString() to extract the ID of the room that the user
             has been inivted to as a string. Then call ovrID_FromString() to parse it
             into an ovrID.
            
             Note that you must call Rooms.Join() if you want to actually join the room.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Room_InviteReceived">
            Handle this to notify the user when they've received an invitation to join
            a room in your game. You can use this in lieu of, or in addition to,
            polling for room invitations via
            Notifications.GetRoomInviteNotifications().
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Room_RoomUpdate">
            Indicates that the current room has been updated. Use Message.GetRoom() to
            extract the updated room.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Voip_ConnectRequest">
            Sent when another user is attempting to establish a VoIP connection. Use
            Message.GetNetworkingPeer() to extract information about the user, and
            Voip.Accept() to accept the connection.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Voip_StateChange">
            Sent to indicate that the state of the VoIP connection changed. Use
            Message.GetNetworkingPeer() and NetworkingPeer.GetState() to extract the
            current state.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Voip_SystemVoipState">
             Sent to indicate that some part of the overall state of SystemVoip has
             changed. Use Message.GetSystemVoipState() and the properties of
             SystemVoipState to extract the state that triggered the notification.
            
             Note that the state may have changed further since the notification was
             generated, and that you may call the `GetSystemVoip...()` family of
             functions at any time to get the current state directly.
        </member>
        <member name="M:Oculus.Platform.Packet.ReadBytes(System.Byte[])">
            Copies all the bytes in the payload into byte[] destination.  ex:
              Package package ...
              byte[] destination = new byte[package.Size];
              package.ReadBytes(destination);
        </member>
        <member name="F:Oculus.Platform.PeerConnectionState.Connected">
            Connection to the peer is established.
        </member>
        <member name="F:Oculus.Platform.PeerConnectionState.Timeout">
            A timeout expired while attempting to (re)establish a connection. This can
            happen if peer is unreachable or rejected the connection.
        </member>
        <member name="F:Oculus.Platform.PeerConnectionState.Closed">
            Connection to the peer is closed. A connection transitions into this state
            when it is explicitly closed by either the local or remote peer calling
            Net.Close(). It also enters this state if the remote peer no longer
            responds to our keep-alive probes.
        </member>
        <member name="M:Oculus.Platform.Rooms.CreateAndJoinPrivate(Oculus.Platform.RoomJoinPolicy,System.UInt32,System.Boolean)">
             DEPRECATED. Use CreateAndJoinPrivate2.
             \param joinPolicy Specifies who can join the room without an invite.
             \param maxUsers The maximum number of users allowed in the room, including the creator.
             \param subscribeToUpdates If true, sends a message with type MessageType.Notification_Room_RoomUpdate when room data changes, such as when users join or leave.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.CreateAndJoinPrivate2(Oculus.Platform.RoomJoinPolicy,System.UInt32,Oculus.Platform.RoomOptions)">
             Creates a new private (client controlled) room and adds the caller to it.
             This type of room is good for matches where the user wants to play with
             friends, as they're primarially discoverable by examining which rooms your
             friends are in.
             \param joinPolicy Specifies who can join the room without an invite.
             \param maxUsers The maximum number of users allowed in the room, including the creator.
             \param roomOptions Additional room configuration for this request. Optional.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.Get(System.UInt64)">
             Allows arbitrary rooms for the application to be loaded.
             \param roomID The room to load.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.GetCurrent">
             Easy loading of the room you're currently in. If you don't want live
             updates on your current room (by using subscribeToUpdates), you can use
             this to refresh the data.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.GetCurrentForUser(System.UInt64)">
             Allows the current room for a given user to be loaded. Remember that the
             user's privacy settings may not allow their room to be loaded. Because of
             this, it's often possible to load the users in a room, but not to take
             those users and load their room.
             \param userID ID of the user for which to load the room.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.GetInvitableUsers">
             DEPRECATED. Use GetInvitableUsers2.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.GetInvitableUsers2(Oculus.Platform.RoomOptions)">
             Loads a list of users you can invite to a room. These are pulled from your
             friends list and recently met lists and filtered for relevance and
             interest. If the room cannot be joined, this list will be empty. By
             default, the invitable users returned will be for the user's current room.
            
             If your application grouping was created after September 9 2017, recently
             met users will be included by default. If your application grouping was
             created before then, you can go to edit the setting in the "Rooms and
             Matchmaking" section of Platform Services at dashboard.oculus.com
            
             Customization can be done via RoomOptions. Create this object with
             RoomOptions(). The params that could be used are:
            
             1. RoomOptions.SetRoomId()- will return the invitable users for this room
             (instead of the current room).
            
             2. RoomOptions.SetOrdering() - returns the list of users in the provided
             ordering (see UserOrdering enum).
            
             3. RoomOptions.SetRecentlyMetTimeWindow() - how long long ago should we
             include users you've recently met in the results?
            
             4. RoomOptions.SetMaxUserResults() - we will limit the number of results
             returned. By default, the number is unlimited, but the server may choose to
             limit results for performance reasons.
            
             5. RoomOptions.SetExcludeRecentlyMet() - Don't include users recently in
             rooms with this user in the result. Also, see the above comment.
            
             Example custom C++ usage:
            
               auto roomOptions = ovr_RoomOptions_Create();
               ovr_RoomOptions_SetOrdering(roomOptions, ovrUserOrdering_PresenceAlphabetical);
               ovr_RoomOptions_SetRoomId(roomOptions, roomID);
               ovr_Room_GetInvitableUsers2(roomOptions);
               ovr_RoomOptions_Destroy(roomOptions);
             \param roomOptions Additional configuration for this request. Optional.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.GetModeratedRooms">
             Fetches the list of moderated rooms created for the application.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.InviteUser(System.UInt64,System.String)">
             Invites a user to the specified room. They will receive a notification via
             MessageType.Notification_Room_InviteReceived if they are in your game,
             and/or they can poll for room invites using
             Notifications.GetRoomInviteNotifications().
             \param roomID The ID of your current room.
             \param inviteToken A user's invite token, returned by Rooms.GetInvitableUsers().
            
             <b>Error codes</b>
             - \b 100: The invite token has expired, the user will need to be reinvited to the room.
             - \b 100: The target user cannot join you in your current experience
             - \b 100: You cannot send an invite to a room you are not in
            
        </member>
        <member name="M:Oculus.Platform.Rooms.Join(System.UInt64,System.Boolean)">
             Joins the target room (leaving the one you're currently in).
             \param roomID The room to join.
             \param subscribeToUpdates If true, sends a message with type MessageType.Notification_Room_RoomUpdate when room data changes, such as when users join or leave.
            
             <b>Error codes</b>
             - \b 10: The room you're attempting to join is currently locked. Please try again later.
             - \b 10: You don't have permission to enter this room. You may need to be invited first.
             - \b 100: Invalid room_id: {room_id}. Either the ID is not a valid room or the user does not have permission to see or act on the room.
             - \b 100: The room you're attempting to join is full. Please try again later.
             - \b 100: This game isn't available. If it already started or was canceled, you can host a new game at any point.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.Join2(System.UInt64,Oculus.Platform.RoomOptions)">
             Joins the target room (leaving the one you're currently in).
             \param roomID The room to join.
             \param roomOptions Additional room configuration for this request. Optional.
            
             <b>Error codes</b>
             - \b 10: The room you're attempting to join is currently locked. Please try again later.
             - \b 10: You don't have permission to enter this room. You may need to be invited first.
             - \b 100: Invalid room_id: {room_id}. Either the ID is not a valid room or the user does not have permission to see or act on the room.
             - \b 100: The room you're attempting to join is full. Please try again later.
             - \b 100: This game isn't available. If it already started or was canceled, you can host a new game at any point.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.KickUser(System.UInt64,System.UInt64,System.Int32)">
             Allows the room owner to kick a user out of the current room.
             \param roomID The room that you currently own (check Room.GetOwner()).
             \param userID The user to be kicked (cannot be yourself).
             \param kickDurationSeconds Length of the ban, in seconds.
            
             <b>Error codes</b>
             - \b 10: Room {room_id}: The user does not have permission to {cannot_action} because the user is not in the room (or any room). Perhaps they already left, or they stopped heartbeating. If this is a test environment, make sure you are not using the deprecated initialization methods ovr_PlatformInitializeStandaloneAccessToken (C++)/StandalonePlatform.Initialize(accessToken) (C#).
             - \b 10: Room {room_id}: The user does not have permission to {cannot_action} because the user is not the owner of the room.
             - \b 100: You cannot remove yourself from room {room_id}
            
        </member>
        <member name="M:Oculus.Platform.Rooms.LaunchInvitableUserFlow(System.UInt64)">
             Launch the invitable user flow to invite to the logged in user's current
             room. This is intended to be a nice shortcut for developers not wanting to
             build out their own Invite UI although it has the same rules as if you
             build it yourself.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.Leave(System.UInt64)">
             Removes you from your current room. Returns the solo room you are now in if
             it succeeds
             \param roomID The room you're currently in.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.SetDescription(System.UInt64,System.String)">
             Allows the room owner to set the description of their room.
             \param roomID The room that you currently own (check Room.GetOwner()).
             \param description The new name of the room.
            
             <b>Error codes</b>
             - \b 10: Room {room_id}: The user does not have permission to {cannot_action} because the user is currently in another room (perhaps on another device), and thus is no longer in this room. Users can only be in one room at a time. If they are active on two different devices at once, there will be undefined behavior.
             - \b 10: Room {room_id}: The user does not have permission to {cannot_action} because the user is not in the room (or any room). Perhaps they already left, or they stopped heartbeating. If this is a test environment, make sure you are not using the deprecated initialization methods ovr_PlatformInitializeStandaloneAccessToken (C++)/StandalonePlatform.Initialize(accessToken) (C#).
             - \b 10: Room {room_id}: The user does not have permission to {cannot_action} because the user is not the owner of the room.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.UpdateMembershipLockStatus(System.UInt64,Oculus.Platform.RoomMembershipLockStatus)">
             Disallow new members from being able to join the room. This will prevent
             joins from Rooms.Join(), invites, 'Join From Home', etc. Users that are in
             the room at the time of lockdown WILL be able to rejoin.
             \param roomID The room whose membership you want to lock or unlock.
             \param membershipLockStatus The new LockStatus for the room
            
             <b>Error codes</b>
             - \b 10: Room {room_id}: The user does not have permission to {cannot_action} because the user is currently in another room (perhaps on another device), and thus is no longer in this room. Users can only be in one room at a time. If they are active on two different devices at once, there will be undefined behavior.
             - \b 10: Room {room_id}: The user does not have permission to {cannot_action} because the user is not in the room (or any room). Perhaps they already left, or they stopped heartbeating. If this is a test environment, make sure you are not using the deprecated initialization methods ovr_PlatformInitializeStandaloneAccessToken (C++)/StandalonePlatform.Initialize(accessToken) (C#).
             - \b 10: Room {room_id}: The user does not have permission to {cannot_action} because the user is not the owner of the room.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.UpdateOwner(System.UInt64,System.UInt64)">
             Allows the room owner to transfer ownership to someone else.
             \param roomID The room that the user owns (check Room.GetOwner()).
             \param userID The new user to make an owner; the user must be in the room.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.UpdatePrivateRoomJoinPolicy(System.UInt64,Oculus.Platform.RoomJoinPolicy)">
             Sets the join policy of the user's private room.
             \param roomID The room ID that the user owns (check Room.GetOwner()).
             \param newJoinPolicy The new join policy for the room.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.SetRoomInviteAcceptedNotificationCallback(Oculus.Platform.Message{System.String}.Callback)">
             Indicates that the user has accepted an invitation, for example in Oculus
             Home. Use Message.GetString() to extract the ID of the room that the user
             has been inivted to as a string. Then call ovrID_FromString() to parse it
             into an ovrID.
            
             Note that you must call Rooms.Join() if you want to actually join the room.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.SetRoomInviteReceivedNotificationCallback(Oculus.Platform.Message{Oculus.Platform.Models.RoomInviteNotification}.Callback)">
             Handle this to notify the user when they've received an invitation to join
             a room in your game. You can use this in lieu of, or in addition to,
             polling for room invitations via
             Notifications.GetRoomInviteNotifications().
            
        </member>
        <member name="M:Oculus.Platform.Rooms.SetUpdateNotificationCallback(Oculus.Platform.Message{Oculus.Platform.Models.Room}.Callback)">
             Indicates that the current room has been updated. Use Message.GetRoom() to
             extract the updated room.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.Browse(System.String,Oculus.Platform.Matchmaking.CustomQuery)">
             DEPRECATED. Use Browse2.
             \param pool A BROWSE type matchmaking pool.
             \param customQueryData Optional. Custom query data.
            
             <b>Error codes</b>
             - \b 100: Pool {pool_key} does not contain custom data key {key}. You can configure matchmaking custom data at https://dashboard.oculus.com/application/&lt;app_id&gt;/matchmaking
             - \b 12072: Unknown pool: {pool_key}. You can configure matchmaking pools at https://dashboard.oculus.com/application/&lt;app_id&gt;/matchmaking
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.Browse2(System.String,Oculus.Platform.MatchmakingOptions)">
             Modes: BROWSE
            
             See overview documentation above.
            
             Return a list of matchmaking rooms in the current pool filtered by skill
             and ping (if enabled). This also enqueues the user in the matchmaking
             queue. When the user has made a selection, call Rooms.Join2() on one of the
             rooms that was returned. If the user stops browsing, call
             Matchmaking.Cancel().
            
             In addition to the list of rooms, enqueue results are also returned. Call
             MatchmakingBrowseResult.GetEnqueueResult() to obtain them. See
             OVR_MatchmakingEnqueueResult.h for details.
             \param pool A BROWSE type matchmaking pool.
             \param matchmakingOptions Additional matchmaking configuration for this request. Optional.
            
             <b>Error codes</b>
             - \b 100: Pool {pool_key} does not contain custom data key {key}. You can configure matchmaking custom data at https://dashboard.oculus.com/application/&lt;app_id&gt;/matchmaking
             - \b 12072: Unknown pool: {pool_key}. You can configure matchmaking pools at https://dashboard.oculus.com/application/&lt;app_id&gt;/matchmaking
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.Cancel(System.String,System.String)">
             DEPRECATED. Use Cancel2.
             \param pool The pool in question.
             \param requestHash Used to find your entry in a queue.
            
             <b>Error codes</b>
             - \b 10: Room {room_id}: The user does not have permission to {cannot_action} because the user is currently in another room (perhaps on another device), and thus is no longer in this room. Users can only be in one room at a time. If they are active on two different devices at once, there will be undefined behavior.
             - \b 10: Room {room_id}: The user does not have permission to {cannot_action} because the user is not in the room (or any room). Perhaps they already left, or they stopped heartbeating. If this is a test environment, make sure you are not using the deprecated initialization methods ovr_PlatformInitializeStandaloneAccessToken (C++)/StandalonePlatform.Initialize(accessToken) (C#).
             - \b 10: Room {room_id}: The user does not have permission to {cannot_action} because the user is not the owner of the room.
             - \b 100: Invalid room_id: {room_id}. Either the ID is not a valid room or the user does not have permission to see or act on the room.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.Cancel">
             Modes: QUICKMATCH, BROWSE
            
             Makes a best effort to cancel a previous Enqueue request before a match
             occurs. Typically triggered when a user gives up waiting. For BROWSE mode,
             call this when a user gives up looking through the room list or when the
             host of a room wants to stop receiving new users. If you don't cancel but
             the user goes offline, the user/room will be timed out of the queue within
             30 seconds.
            
             <b>Error codes</b>
             - \b 10: Room {room_id}: The user does not have permission to {cannot_action} because the user is currently in another room (perhaps on another device), and thus is no longer in this room. Users can only be in one room at a time. If they are active on two different devices at once, there will be undefined behavior.
             - \b 10: Room {room_id}: The user does not have permission to {cannot_action} because the user is not in the room (or any room). Perhaps they already left, or they stopped heartbeating. If this is a test environment, make sure you are not using the deprecated initialization methods ovr_PlatformInitializeStandaloneAccessToken (C++)/StandalonePlatform.Initialize(accessToken) (C#).
             - \b 10: Room {room_id}: The user does not have permission to {cannot_action} because the user is not the owner of the room.
             - \b 100: Invalid room_id: {room_id}. Either the ID is not a valid room or the user does not have permission to see or act on the room.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.CreateAndEnqueueRoom(System.String,System.UInt32,System.Boolean,Oculus.Platform.Matchmaking.CustomQuery)">
             DEPRECATED. Use CreateAndEnqueueRoom2.
             \param pool The matchmaking pool to use, which is defined for the app.
             \param maxUsers Overrides the Max Users value, which is configured in pool settings of the Developer Dashboard.
             \param subscribeToUpdates If true, sends a message with type MessageType.Notification_Room_RoomUpdate when the room data changes, such as when users join or leave.
             \param customQueryData Optional.  See "Custom criteria" section above.
            
             <b>Error codes</b>
             - \b 100: Pool {pool_key} does not contain custom data key {key}. You can configure matchmaking custom data at https://dashboard.oculus.com/application/&lt;app_id&gt;/matchmaking
             - \b 12051: Pool '{pool_key}' is configured for Quickmatch mode. In Quickmatch mode, rooms are created on users' behalf when a match is found. Specify Advanced Quickmatch or Browse mode to use this feature.
             - \b 12072: Unknown pool: {pool_key}. You can configure matchmaking pools at https://dashboard.oculus.com/application/&lt;app_id&gt;/matchmaking
             - \b 12089: You have asked to enqueue {num_users} users together, but this must be less than the maximum number of users in a room, {max_users}.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.CreateAndEnqueueRoom2(System.String,Oculus.Platform.MatchmakingOptions)">
             Modes: BROWSE, QUICKMATCH (Advanced; Can Users Create Rooms = true)
            
             See overview documentation above.
            
             Create a matchmaking room, join it, and enqueue it. This is the preferred
             method. But, if you do not wish to automatically enqueue the room, you can
             call CreateRoom2 instead.
            
             Visit https://dashboard.oculus.com/application/[YOUR_APP_ID]/matchmaking to
             set up pools and queries
             \param pool The matchmaking pool to use, which is defined for the app.
             \param matchmakingOptions Additional matchmaking configuration for this request. Optional.
            
             <b>Error codes</b>
             - \b 100: Pool {pool_key} does not contain custom data key {key}. You can configure matchmaking custom data at https://dashboard.oculus.com/application/&lt;app_id&gt;/matchmaking
             - \b 12051: Pool '{pool_key}' is configured for Quickmatch mode. In Quickmatch mode, rooms are created on users' behalf when a match is found. Specify Advanced Quickmatch or Browse mode to use this feature.
             - \b 12072: Unknown pool: {pool_key}. You can configure matchmaking pools at https://dashboard.oculus.com/application/&lt;app_id&gt;/matchmaking
             - \b 12089: You have asked to enqueue {num_users} users together, but this must be less than the maximum number of users in a room, {max_users}.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.CreateRoom(System.String,System.UInt32,System.Boolean)">
             DEPRECATED. Use CreateRoom2.
             \param pool The matchmaking pool to use, which is defined for the app.
             \param maxUsers Overrides the Max Users value, which is configured in pool settings of the Developer Dashboard.
             \param subscribeToUpdates If true, sends a message with type MessageType.Notification_Room_RoomUpdate when room data changes, such as when users join or leave.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.CreateRoom2(System.String,Oculus.Platform.MatchmakingOptions)">
             Create a matchmaking room and join it, but do not enqueue the room. After
             creation, you can call EnqueueRoom2. However, Oculus recommends using
             CreateAndEnqueueRoom2 instead.
            
             Modes: BROWSE, QUICKMATCH (Advanced; Can Users Create Rooms = true)
            
             Create a matchmaking room and join it, but do not enqueue the room. After
             creation, you can call EnqueueRoom. Consider using CreateAndEnqueueRoom
             instead.
            
             Visit https://dashboard.oculus.com/application/[YOUR_APP_ID]/matchmaking to
             set up pools and queries
             \param pool The matchmaking pool to use, which is defined for the app.
             \param matchmakingOptions Additional matchmaking configuration for this request. Optional.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.Enqueue(System.String,Oculus.Platform.Matchmaking.CustomQuery)">
             DEPRECATED. Use Enqueue2.
             \param pool The pool to enqueue in.
             \param customQueryData Optional.  See "Custom criteria" section above.
            
             <b>Error codes</b>
             - \b 100: Pool {pool_key} does not contain custom data key {key}. You can configure matchmaking custom data at https://dashboard.oculus.com/application/&lt;app_id&gt;/matchmaking
             - \b 12072: Unknown pool: {pool_key}. You can configure matchmaking pools at https://dashboard.oculus.com/application/&lt;app_id&gt;/matchmaking
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.Enqueue2(System.String,Oculus.Platform.MatchmakingOptions)">
             Modes: QUICKMATCH
            
             See overview documentation above.
            
             Enqueue yourself to await an available matchmaking room. The platform
             returns a MessageType.Notification_Matchmaking_MatchFound message when a
             match is found. Call Rooms.Join2() on the returned room. The response
             contains useful information to display to the user to set expectations for
             how long it will take to get a match.
            
             If the user stops waiting, call Matchmaking.Cancel().
             \param pool The pool to enqueue in.
             \param matchmakingOptions Additional matchmaking configuration for this request. Optional.
            
             <b>Error codes</b>
             - \b 100: Pool {pool_key} does not contain custom data key {key}. You can configure matchmaking custom data at https://dashboard.oculus.com/application/&lt;app_id&gt;/matchmaking
             - \b 12072: Unknown pool: {pool_key}. You can configure matchmaking pools at https://dashboard.oculus.com/application/&lt;app_id&gt;/matchmaking
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.EnqueueRoom(System.UInt64,Oculus.Platform.Matchmaking.CustomQuery)">
             DEPRECATED. Please use Matchmaking.EnqueueRoom2() instead.
             \param roomID Returned either from MessageType.Notification_Matchmaking_MatchFound or from Matchmaking.CreateRoom().
             \param customQueryData Optional.  See the "Custom criteria" section above.
            
             <b>Error codes</b>
             - \b 10: Room {room_id}: The user does not have permission to {cannot_action} because the user is currently in another room (perhaps on another device), and thus is no longer in this room. Users can only be in one room at a time. If they are active on two different devices at once, there will be undefined behavior.
             - \b 10: Room {room_id}: The user does not have permission to {cannot_action} because the user is not in the room (or any room). Perhaps they already left, or they stopped heartbeating. If this is a test environment, make sure you are not using the deprecated initialization methods ovr_PlatformInitializeStandaloneAccessToken (C++)/StandalonePlatform.Initialize(accessToken) (C#).
             - \b 10: Room {room_id}: The user does not have permission to {cannot_action} because the user is not the owner of the room.
             - \b 100: Invalid room_id: {room_id}. Either the ID is not a valid room or the user does not have permission to see or act on the room.
             - \b 12051: Pool '{pool_key}' is configured for Quickmatch mode. In Quickmatch mode, rooms are created on users' behalf when a match is found. Specify Advanced Quickmatch or Browse mode to use this feature.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.EnqueueRoom2(System.UInt64,Oculus.Platform.MatchmakingOptions)">
             Modes: BROWSE (for Rooms only), ROOM
            
             See the overview documentation above. Enqueue yourself to await an
             available matchmaking room. MessageType.Notification_Matchmaking_MatchFound
             gets enqueued when a match is found.
            
             The response contains useful information to display to the user to set
             expectations for how long it will take to get a match.
            
             If the user stops waiting, call Matchmaking.Cancel().
             \param roomID Returned either from MessageType.Notification_Matchmaking_MatchFound or from Matchmaking.CreateRoom().
             \param matchmakingOptions Additional matchmaking configuration for this request. Optional.
            
             <b>Error codes</b>
             - \b 10: Room {room_id}: The user does not have permission to {cannot_action} because the user is currently in another room (perhaps on another device), and thus is no longer in this room. Users can only be in one room at a time. If they are active on two different devices at once, there will be undefined behavior.
             - \b 10: Room {room_id}: The user does not have permission to {cannot_action} because the user is not in the room (or any room). Perhaps they already left, or they stopped heartbeating. If this is a test environment, make sure you are not using the deprecated initialization methods ovr_PlatformInitializeStandaloneAccessToken (C++)/StandalonePlatform.Initialize(accessToken) (C#).
             - \b 10: Room {room_id}: The user does not have permission to {cannot_action} because the user is not the owner of the room.
             - \b 100: Invalid room_id: {room_id}. Either the ID is not a valid room or the user does not have permission to see or act on the room.
             - \b 12051: Pool '{pool_key}' is configured for Quickmatch mode. In Quickmatch mode, rooms are created on users' behalf when a match is found. Specify Advanced Quickmatch or Browse mode to use this feature.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.GetAdminSnapshot">
             Modes: QUICKMATCH, BROWSE
            
             Used to debug the state of the current matchmaking pool queue. This is not
             intended to be used in production.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.JoinRoom(System.UInt64,System.Boolean)">
             DEPRECATED. Use ovr_Room_Join2.
             \param roomID ID of a room previously returned from MessageType.Notification_Matchmaking_MatchFound or Matchmaking.Browse().
             \param subscribeToUpdates If true, sends a message with type MessageType.Notification_Room_RoomUpdate when room data changes, such as when users join or leave.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.StartMatch(System.UInt64)">
             Modes: QUICKMATCH, BROWSE (+ Skill Pool)
            
             For pools with skill-based matching. See overview documentation above.
            
             Call after calling Rooms.Join2() when the players are present to begin a
             rated match for which you plan to report the results (using
             Matchmaking.ReportResultInsecure()).
            
             <b>Error codes</b>
             - \b 100: There is no active match associated with the room {room_id}.
             - \b 100: You can only start matches, report matches, and track skill ratings in matchmaking rooms. {room_id} is a room, but it is not a matchmaking room.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.SetMatchFoundNotificationCallback(Oculus.Platform.Message{Oculus.Platform.Models.Room}.Callback)">
             Indicates that a match has been found, for example after calling
             Matchmaking.Enqueue(). Use Message.GetRoom() to extract the matchmaking
             room.
            
        </member>
        <member name="M:Oculus.Platform.Net.SetConnectionStateChangedCallback(Oculus.Platform.Message{Oculus.Platform.Models.NetworkingPeer}.Callback)">
             Indicates that a connection has been established or there's been an error.
             Use NetworkingPeer.GetState() to get the result; as above,
             NetworkingPeer.GetID() returns the ID of the peer this message is for.
            
        </member>
        <member name="M:Oculus.Platform.Net.SetPeerConnectRequestCallback(Oculus.Platform.Message{Oculus.Platform.Models.NetworkingPeer}.Callback)">
             Indicates that another user is attempting to establish a P2P connection
             with us. Use NetworkingPeer.GetID() to extract the ID of the peer.
            
        </member>
        <member name="M:Oculus.Platform.Net.SetPingResultNotificationCallback(Oculus.Platform.Message{Oculus.Platform.Models.PingResult}.Callback)">
             Generated in response to Net.Ping(). Either contains ping time in
             microseconds or indicates that there was a timeout.
            
        </member>
        <member name="M:Oculus.Platform.Leaderboards.GetEntries(System.String,System.Int32,Oculus.Platform.LeaderboardFilterType,Oculus.Platform.LeaderboardStartAt)">
             Requests a block of Leaderboard Entries.
             \param leaderboardName The name of the leaderboard whose entries to return.
             \param limit Defines the maximum number of entries to return.
             \param filter Allows you to restrict the returned values by friends.
             \param startAt Defines whether to center the query on the user or start at the top of the leaderboard.
            
             <b>Error codes</b>
             - \b 12074: You're not yet ranked on this leaderboard.
            
        </member>
        <member name="M:Oculus.Platform.Leaderboards.GetEntriesAfterRank(System.String,System.Int32,System.UInt64)">
             Requests a block of leaderboard Entries.
             \param leaderboardName The name of the leaderboard.
             \param limit The maximum number of entries to return.
             \param afterRank The position after which to start.  For example, 10 returns leaderboard results starting with the 11th user.
            
        </member>
        <member name="M:Oculus.Platform.Leaderboards.WriteEntry(System.String,System.Int64,System.Byte[],System.Boolean)">
             Writes a single entry to a leaderboard.
             \param leaderboardName The leaderboard for which to write the entry.
             \param score The score to write.
             \param extraData A 2KB custom data field that is associated with the leaderboard entry. This can be a game replay or anything that provides more detail about the entry to the viewer.
             \param forceUpdate If true, the score always updates.  This happens even if it is not the user's best score.
            
             <b>Error codes</b>
             - \b 100: Parameter {parameter}: invalid user id: {user_id}
            
        </member>
        <member name="M:Oculus.Platform.Voip.SetSystemVoipSuppressed(System.Boolean)">
             Sets whether SystemVoip should be suppressed so that this app's Voip can
             use the mic and play incoming Voip audio.
            
        </member>
        <member name="M:Oculus.Platform.Voip.SetVoipConnectRequestCallback(Oculus.Platform.Message{Oculus.Platform.Models.NetworkingPeer}.Callback)">
             Sent when another user is attempting to establish a VoIP connection. Use
             Message.GetNetworkingPeer() to extract information about the user, and
             Voip.Accept() to accept the connection.
            
        </member>
        <member name="M:Oculus.Platform.Voip.SetVoipStateChangeCallback(Oculus.Platform.Message{Oculus.Platform.Models.NetworkingPeer}.Callback)">
             Sent to indicate that the state of the VoIP connection changed. Use
             Message.GetNetworkingPeer() and NetworkingPeer.GetState() to extract the
             current state.
            
        </member>
        <member name="M:Oculus.Platform.Voip.SetSystemVoipStateNotificationCallback(Oculus.Platform.Message{Oculus.Platform.Models.SystemVoipState}.Callback)">
             Sent to indicate that some part of the overall state of SystemVoip has
             changed. Use Message.GetSystemVoipState() and the properties of
             SystemVoipState to extract the state that triggered the notification.
            
             Note that the state may have changed further since the notification was
             generated, and that you may call the `GetSystemVoip...()` family of
             functions at any time to get the current state directly.
            
        </member>
        <member name="M:Oculus.Platform.Achievements.AddCount(System.String,System.UInt64)">
             Add 'count' to the achievement with the given name. This must be a COUNT
             achievement. The largest number that is supported by this method is the max
             value of a signed 64-bit integer. If the number is larger than that, it is
             clamped to that max value before being passed to the servers.
            
        </member>
        <member name="M:Oculus.Platform.Achievements.AddFields(System.String,System.String)">
             Unlock fields of a BITFIELD achievement.
             \param name The name of the achievement to unlock
             \param fields A string containing either '0' or '1' characters. Every '1' will unlock the field in the corresponding position.
            
        </member>
        <member name="M:Oculus.Platform.Achievements.GetAllDefinitions">
             Request all achievement definitions for the app.
            
        </member>
        <member name="M:Oculus.Platform.Achievements.GetAllProgress">
             Request the progress for the user on all achievements in the app.
            
        </member>
        <member name="M:Oculus.Platform.Achievements.GetDefinitionsByName(System.String[])">
             Request the achievement definitions that match the specified names.
            
        </member>
        <member name="M:Oculus.Platform.Achievements.GetProgressByName(System.String[])">
             Request the user's progress on the specified achievements.
            
        </member>
        <member name="M:Oculus.Platform.Achievements.Unlock(System.String)">
             Unlock the achievement with the given name. This can be of any achievement
             type.
            
        </member>
        <member name="M:Oculus.Platform.Application.GetVersion">
             Requests version information, including the currently installed and latest
             available version name and version code.
            
        </member>
        <member name="M:Oculus.Platform.Application.LaunchOtherApp(System.UInt64,Oculus.Platform.ApplicationOptions)">
             Launches a different application in the user's library. If the user does
             not have that application installed, they will be taken to that app's page
             in the Oculus Store
             \param appID The ID of the app to launch
             \param deeplink_options Additional configuration for this requests. Optional.
            
        </member>
        <member name="M:Oculus.Platform.AssetFile.Delete(System.UInt64)">
             DEPRECATED. Use AssetFile.DeleteById()
            
        </member>
        <member name="M:Oculus.Platform.AssetFile.DeleteById(System.UInt64)">
             Removes an previously installed asset file from the device by its ID.
             Returns an object containing the asset ID and file name, and a success
             flag.
             \param assetFileID The asset file ID
            
        </member>
        <member name="M:Oculus.Platform.AssetFile.DeleteByName(System.String)">
             Removes an previously installed asset file from the device by its name.
             Returns an object containing the asset ID and file name, and a success
             flag.
             \param assetFileName The asset file name
            
        </member>
        <member name="M:Oculus.Platform.AssetFile.Download(System.UInt64)">
             DEPRECATED. Use AssetFile.DownloadById()
            
        </member>
        <member name="M:Oculus.Platform.AssetFile.DownloadById(System.UInt64)">
             Downloads an asset file by its ID on demand. Returns an object containing
             the asset ID and filepath. Sends periodic
             MessageType.Notification_AssetFile_DownloadUpdate to track the downloads.
             \param assetFileID The asset file ID
            
        </member>
        <member name="M:Oculus.Platform.AssetFile.DownloadByName(System.String)">
             Downloads an asset file by its name on demand. Returns an object containing
             the asset ID and filepath. Sends periodic
             {notifications.asset_file.download_update}} to track the downloads.
             \param assetFileName The asset file name
            
        </member>
        <member name="M:Oculus.Platform.AssetFile.DownloadCancel(System.UInt64)">
             DEPRECATED. Use AssetFile.DownloadCancelById()
            
        </member>
        <member name="M:Oculus.Platform.AssetFile.DownloadCancelById(System.UInt64)">
             Cancels a previously spawned download request for an asset file by its ID.
             Returns an object containing the asset ID and file path, and a success
             flag.
             \param assetFileID The asset file ID
            
        </member>
        <member name="M:Oculus.Platform.AssetFile.DownloadCancelByName(System.String)">
             Cancels a previously spawned download request for an asset file by its
             name. Returns an object containing the asset ID and file path, and a
             success flag.
             \param assetFileName The asset file name
            
        </member>
        <member name="M:Oculus.Platform.AssetFile.GetList">
             Returns an array of objects with asset file names and their associated IDs,
             and and whether it's currently installed.
            
        </member>
        <member name="M:Oculus.Platform.AssetFile.Status(System.UInt64)">
             DEPRECATED. Use AssetFile.StatusById()
            
        </member>
        <member name="M:Oculus.Platform.AssetFile.StatusById(System.UInt64)">
             Returns the details on a single asset: ID, file name, and whether it's
             currently installed
             \param assetFileID The asset file ID
            
        </member>
        <member name="M:Oculus.Platform.AssetFile.StatusByName(System.String)">
             Returns the details on a single asset: ID, file name, and whether it's
             currently installed
             \param assetFileName The asset file name
            
        </member>
        <member name="M:Oculus.Platform.AssetFile.SetDownloadUpdateNotificationCallback(Oculus.Platform.Message{Oculus.Platform.Models.AssetFileDownloadUpdate}.Callback)">
             Sent to indicate download progress for asset files.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.Delete(System.String,System.String)">
             Deletes the specified save data buffer. Conflicts are handled just like
             Saves.
             \param bucket The name of the storage bucket.
             \param key The name for this saved data.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.Load(System.String,System.String)">
             Loads the saved entry for the specified bucket and key. If a conflict
             exists with the key then an error message is returned.
             \param bucket The name of the storage bucket.
             \param key The name for this saved data.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.LoadBucketMetadata(System.String)">
             Loads all the metadata for the saves in the specified bucket, including
             conflicts.
             \param bucket The name of the storage bucket.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.LoadConflictMetadata(System.String,System.String)">
             Loads the metadata for this bucket-key combination that need to be manually
             resolved.
             \param bucket The name of the storage bucket
             \param key The key for this saved data.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.LoadHandle(System.String)">
             Loads the data specified by the storage handle.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.LoadMetadata(System.String,System.String)">
             load the metadata for the specified key
             \param bucket The name of the storage bucket.
             \param key The name for this saved data.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.ResolveKeepLocal(System.String,System.String,System.String)">
             Selects the local save for manual conflict resolution.
             \param bucket The name of the storage bucket.
             \param key The name for this saved data.
             \param remoteHandle The handle of the remote that the local file was resolved against.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.ResolveKeepRemote(System.String,System.String,System.String)">
             Selects the remote save for manual conflict resolution.
             \param bucket The name of the storage bucket.
             \param key The name for this saved data.
             \param remoteHandle The handle of the remote.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.Save(System.String,System.String,System.Byte[],System.Int64,System.String)">
             Note: Cloud Storage is only available for Rift apps.
            
             Send a save data buffer to the platform. CloudStorage.Save() passes a
             pointer to your data in an async call. You need to maintain the save data
             until you receive the message indicating that the save was successful.
            
             If the data is destroyed or modified prior to receiving that message the
             data will not be saved.
             \param bucket The name of the storage bucket.
             \param key The name for this saved data.
             \param data Start of the data block.
             \param counter Optional. Counter used for user data or auto-deconfliction.
             \param extraData Optional. String data that isn't used by the platform.
            
             <b>Error codes</b>
             - \b 100: The stored version has a later timestamp than the data provided. This cloud storage bucket's conflict resolution policy is configured to use the latest timestamp, which is configurable in the developer dashboard.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage2.GetUserDirectoryPath">
             Get the directory path for the current user/app pair that will be used
             during cloud storage synchronization
            
        </member>
        <member name="M:Oculus.Platform.Entitlements.IsUserEntitledToApplication">
             Returns whether the current user is entitled to the current app.
            
        </member>
        <member name="M:Oculus.Platform.IAP.ConsumePurchase(System.String)">
             Allow the consumable IAP product to be purchased again. Conceptually, this
             indicates that the item was used or consumed.
            
        </member>
        <member name="M:Oculus.Platform.IAP.GetProductsBySKU(System.String[])">
             Retrieve a list of IAP products that can be purchased.
             \param skus The SKUs of the products to retrieve.
            
        </member>
        <member name="M:Oculus.Platform.IAP.GetViewerPurchases">
             Retrieve a list of Purchase that the Logged-In-User has made. This list
             will also contain consumable purchases that have not been consumed.
            
        </member>
        <member name="M:Oculus.Platform.IAP.LaunchCheckoutFlow(System.String)">
             Launch the checkout flow to purchase the existing product. Oculus Home
             tries handle and fix as many errors as possible. Home returns the
             appropriate error message and how to resolveit, if possible. Returns a
             purchase on success, empty purchase on cancel, and an error on error.
             \param sku IAP sku for the item the user wishes to purchase.
            
        </member>
        <member name="M:Oculus.Platform.LanguagePack.GetCurrent">
             Returns currently installed and selected language pack for an app in the
             view of the `asset_details`. Use `language` field to extract neeeded
             language info. A particular language can be download and installed by a
             user from the Oculus app on the application page.
            
        </member>
        <member name="M:Oculus.Platform.LanguagePack.SetCurrent(System.String)">
             Sets the current language to specified. The parameter is the BCP47 language
             tag. If a language pack is not downloaded yet, spawns automatically the
             AssetFile.DownloadByName() request, and sends periodic
             MessageType.Notification_AssetFile_DownloadUpdate to track the downloads.
             Once the language asset file is downloaded, call LanguagePack.GetCurrent()
             to retrive the data, and use the language at runtime.
             \param tag BCP47 language tag
            
        </member>
        <member name="M:Oculus.Platform.Livestreaming.GetStatus">
             Return the status of the current livestreaming session if there is one.
            
        </member>
        <member name="M:Oculus.Platform.Livestreaming.PauseStream">
             Pauses the livestreaming session if there is one. NOTE: this function is
             safe to call if no session is active.
            
        </member>
        <member name="M:Oculus.Platform.Livestreaming.ResumeStream">
             Resumes the livestreaming session if there is one. NOTE: this function is
             safe to call if no session is active.
            
        </member>
        <member name="M:Oculus.Platform.Livestreaming.SetStatusUpdateNotificationCallback(Oculus.Platform.Message{Oculus.Platform.Models.LivestreamingStatus}.Callback)">
             Indicates that the livestreaming session has been updated. You can use this
             information to throttle your game performance or increase CPU/GPU
             performance. Use Message.GetLivestreamingStatus() to extract the updated
             livestreaming status.
            
        </member>
        <member name="M:Oculus.Platform.Media.ShareToFacebook(System.String,System.String,Oculus.Platform.MediaContentType)">
             Launch the Share to Facebook modal via a deeplink to Home on Gear VR,
             allowing users to share local media files to Facebook. Accepts a
             postTextSuggestion string for the default text of the Facebook post.
             Requires a filePath string as the path to the image to be shared to
             Facebook. This image should be located in your app's internal storage
             directory. Requires a contentType indicating the type of media to be shared
             (only 'photo' is currently supported.)
             \param postTextSuggestion this text will prepopulate the facebook status text-input box within the share modal
             \param filePath path to the file to be shared to facebook
             \param contentType content type of the media to be shared
            
        </member>
        <member name="M:Oculus.Platform.Notifications.GetRoomInviteNotifications">
             Retrieve a list of all pending room invites for your application (for
             example, notifications that may have been sent before the user launched
             your game). You can also get push notifications with
             MessageType.Notification_Room_InviteReceived.
            
        </member>
        <member name="M:Oculus.Platform.Notifications.MarkAsRead(System.UInt64)">
             Mark a notification as read. This causes it to disappear from the Universal
             Menu, the Oculus App, Oculus Home, and in-app retrieval.
            
        </member>
        <member name="M:Oculus.Platform.Parties.GetCurrent">
             Load the party the current user is in.
            
        </member>
        <member name="M:Oculus.Platform.Parties.SetPartyUpdateNotificationCallback(Oculus.Platform.Message{Oculus.Platform.Models.PartyUpdateNotification}.Callback)">
             Indicates that party has been updated
            
        </member>
        <member name="M:Oculus.Platform.RichPresence.Clear">
             Clear rich presence for running app
            
        </member>
        <member name="M:Oculus.Platform.RichPresence.Set(Oculus.Platform.RichPresenceOptions)">
             Set rich presence for running app
            
        </member>
        <member name="M:Oculus.Platform.Users.Get(System.UInt64)">
             Retrieve the user with the given ID. This might fail if the ID is invalid
             or the user is blocked.
            
             NOTE: Users will have a unique ID per application.
             \param userID User ID retrieved with this application.
            
        </member>
        <member name="M:Oculus.Platform.Users.GetAccessToken">
             Return an access token for this user, suitable for making REST calls
             against graph.oculus.com.
            
        </member>
        <member name="M:Oculus.Platform.Users.GetLoggedInUser">
             Retrieve the currently signed in user. This call is available offline.
            
             NOTE: This will not return the user's presence as it should always be
             'online' in your application.
            
             NOTE: Users will have a unique ID per application.
            
        </member>
        <member name="M:Oculus.Platform.Users.GetLoggedInUserFriends">
             Retrieve a list of the logged in user's friends.
            
        </member>
        <member name="M:Oculus.Platform.Users.GetLoggedInUserFriendsAndRooms">
             Retrieve a list of the logged in user's friends and any rooms they might be
             in.
            
        </member>
        <member name="M:Oculus.Platform.Users.GetLoggedInUserRecentlyMetUsersAndRooms(Oculus.Platform.UserOptions)">
             Returns a list of users that the logged in user was in a room with
             recently, sorted by relevance, along with any rooms they might be in. All
             you need to do to use this method is to use our Rooms API, and we will
             track the number of times users are together, their most recent encounter,
             and the amount of time they spend together.
            
             Customization can be done via UserOptions. Create this object with
             UserOptions(). The params that could be used are:
            
             1. UserOptions.SetTimeWindow() - how recently should the users have played?
             The default is TimeWindow.ThirtyDays.
            
             2. UserOptions.SetMaxUsers() - we will limit the number of results
             returned. By default, the number is unlimited, but the server may choose to
             limit results for performance reasons.
             \param userOptions Additional configuration for this request. Optional.
            
        </member>
        <member name="M:Oculus.Platform.Users.GetOrgScopedID(System.UInt64)">
             returns an ovrID which is unique per org. allows different apps within the
             same org to identify the user.
             \param userID to load the org scoped id of
            
        </member>
        <member name="M:Oculus.Platform.Users.GetSdkAccounts">
             Returns all accounts belonging to this user. Accounts are the Oculus user
             and x-users that are linked to this user.
            
        </member>
        <!-- Badly formed XML comment ignored for member "M:Oculus.Platform.Users.GetUserProof" -->
        <member name="M:Oculus.Platform.Users.LaunchFriendRequestFlow(System.UInt64)">
             Launch the flow for sending a friend request to a user.
             \param userID User ID of user to send a friend request to
            
        </member>
        <member name="M:Oculus.Platform.Users.LaunchProfile(System.UInt64)">
             Launch the profile of the given user. The profile surfaces information
             about the user and supports relevant actions that the viewer may take on
             that user, e.g. sending a friend request.
             \param userID User ID for profile being viewed
            
        </member>
        <member name="M:Oculus.Platform.Request.RunCallbacks(System.UInt32)">
            This will run callbacks on all messages that returned from the server.
            If too many message are coming back at once, then a limit can be passed in
            as an arg to limit the number of messages to run callbacks on at a time
        </member>
        <member name="F:Oculus.Platform.SendPolicy.Unreliable">
             Sends a message using an unreliable data channel (UDP-based). No delivery
             or ordering guarantees are provided. Sending will fail unless a connection
             to the peer is already established, either via a previous call to
             Net.SendPacket() or an explicit Net.Connect().
            
             Ideally, each message should fit into a single packet. Therefore, it is
             recommended to keep them under 1200 bytes.
        </member>
        <member name="F:Oculus.Platform.SendPolicy.Reliable">
            Messages are delivered reliably and in order. The networking layer retries
            until each message is acknowledged by the peer. Outgoing messages are
            buffered until a working connection to the peer is established.
        </member>
        <member name="F:Oculus.Platform.UserOrdering.None">
            No preference for ordering (could be in any or no order)
        </member>
        <member name="F:Oculus.Platform.UserOrdering.PresenceAlphabetical">
            Orders by online users first and then offline users. Within each group the
            users are ordered alphabetically by display name
        </member>
        <member name="F:Oculus.Platform.VoipBitrate.B16000">
            Very low audio quality for minimal network usage. This may not give the
            full range of Hz for audio, but it will save on network usage.
        </member>
        <member name="F:Oculus.Platform.VoipBitrate.B24000">
            Lower audio quality but also less network usage.
        </member>
        <member name="F:Oculus.Platform.VoipBitrate.B32000">
            This is the default bitrate for voip connections. It should be the best
            tradeoff between audio quality and network usage.
        </member>
        <member name="F:Oculus.Platform.VoipBitrate.B64000">
            Higher audio quality at the expense of network usage. Good if there's music
            being streamed over the connections
        </member>
        <member name="F:Oculus.Platform.VoipBitrate.B96000">
            Even higher audio quality for music streaming or radio-like quality.
        </member>
        <member name="F:Oculus.Platform.VoipBitrate.B128000">
            At this point the audio quality should be preceptually indistinguishable
            from the uncompressed input.
        </member>
        <member name="T:TBE.AudioEngineManager">
            <summary>
            Manage the audio engine.
            It should be used via the FBAudioBootstrapper or the soon to be deprecated AudioEngineManager.Instance.
            </summary>
        </member>
        <member name="T:TBE.AudioEngineManager.Client">
            <summary>
            A helper class to hold a reference to AudioEngineManager. The reference is notified and set to null
            when the AudioEngineManager is destroyed.
            Any objects that depend on the lifetime of AudioEngineManager should access it via this Client object. A new
            instance can be created via AudioEngineManager.NewClient
            </summary>
        </member>
        <member name="T:TBE.AudioObject">
            <summary>
            Spatialise a sound in space
            </summary>
        </member>
        <member name="M:TBE.AudioObject.open(System.String)">
            <summary>
            Opens an asset for playback. Currently .wav and .opus formats are supported. If no path is specified,
            the asset will be loaded from Assets/StreamingAssets.
            While the asset is opened synchronously, it is loaded into the streaming buffer asynchronously. An
            event (Event.DECODER_INIT) will be dispatched to the event listener when the streaming buffer is ready for the
            asset to play.
            </summary>
            <param name="fileToplay">Name of the file in StreamAssets or the full path</param>
            <returns>true if the file was found and successfully opened</returns>
        </member>
        <member name="M:TBE.AudioObject.open(TBE.IOStream)">
            <summary>
            Open an asset for playback using an IOStream abstraction.
            </summary>
            <returns>true if the file was found and successfully opened</returns>
            <param name="streamObject">Stream object used to open the audio asset.</param>
        </member>
        <member name="M:TBE.AudioObject.open(TBE.IOStream,UnityEngine.Vector3,System.Single)">
            <summary>
            Open a stream with a specific gain value at a specific position
            </summary>
            <param name="streamObject"></param>
            <param name="newPosition"></param>
            <param name="newVolume"></param>
            <returns>true if the file was found and successfully opened</returns>
        </member>
        <member name="M:TBE.AudioObject.close">
            <summary>
            Close an opened file.
            </summary>
        </member>
        <member name="M:TBE.AudioObject.isOpen">
            <summary>
            Returns true if a file is open and ready.
            </summary>
            <returns>Returns true if a file is open and ready.</returns>
        </member>
        <member name="M:TBE.AudioObject.play">
            <summary>
            Begin playback of an opened file.
            Any subsequent call to this function or any play function
            will disregard this event if it hasn't already been triggered.
            </summary>
        </member>
        <member name="M:TBE.AudioObject.playScheduled(System.Single)">
            <summary>
            Schedule playback x milliseconds from now.
            Any subsequent call to this function or any play function
            will disregard this event if it hasn't already been triggered.
            </summary>
            <param name="millisecondsFromNow">Time from now in milliseconds</param>
        </member>
        <member name="M:TBE.AudioObject.playScheduled(System.Single,System.Single)">
            <summary>
            Schedule playback x milliseconds from now with a fade in.
            Any subsequent call to this function or any play function
            will disregard this event if it hasn't already been triggered.
            </summary>
            <param name="millisecondsFromNow">Time from now in milliseconds</param>
            <param name="fadeTimeInMs">Fade in time in ms</param>
        </member>
        <member name="M:TBE.AudioObject.playWithFade(System.Single)">
            <summary>
            Begin playback with a fade.
            Any subsequent call to this function or any play function
            will disregard this event if it hasn't already been triggered.
            </summary>
            <param name="fadeDurationInMs">Duration of the fade in milliseconds</param>
        </member>
        <member name="M:TBE.AudioObject.stop">
            <summary>
            Stop playback.
            Any subsequent call to this function or any stop function
            will disregard this event if it hasn't already been triggered.
            </summary>
        </member>
        <member name="M:TBE.AudioObject.stopScheduled(System.Single)">
            <summary>
            Schedule to stop playback x milliseconds from now.
            Any subsequent call to this function or any stop function
            will disregard this event if it hasn't already been triggered.
            </summary>
            <param name="millisecondsFromNow">Time from now in milliseconds</param>
        </member>
        <member name="M:TBE.AudioObject.stopScheduled(System.Single,System.Single)">
            <summary>
            Schedule to stop playback x milliseconds from now.
            Any subsequent call to this function or any stop function
            will disregard this event if it hasn't already been triggered.
            </summary>
            <param name="millisecondsFromNow">Time from now in milliseconds</param>
            <param name="fadeTimeInMs">Fade out time in ms</param>
        </member>
        <member name="M:TBE.AudioObject.stopWithFade(System.Single)">
            <summary>
            Fadeout and stop playback.
            Any subsequent call to this function or any stop function
            will disregard this event if it hasn't already been triggered.
            </summary>
            <param name="fadeDurationInMs">Duration of the fade in milliseconds.</param>
        </member>
        <member name="M:TBE.AudioObject.pause">
            <summary>
             Pause playback.
            Any subsequent call to this function or any pause function
            will disregard this event if it hasn't already been triggered.
            </summary>
        </member>
        <member name="M:TBE.AudioObject.pauseScheduled(System.Single)">
            <summary>
            Schedule playback to be paused x milliseconds from now.
            Any subsequent call to this function or any pause function
            will disregard this event if it hasn't already been triggered.
            </summary>
            <param name="millisecondsFromNow">Time from now in milliseconds</param>
        </member>
        <member name="M:TBE.AudioObject.pauseScheduled(System.Single,System.Single)">
            <summary>
            Schedule playback to be paused x milliseconds from now.
            Any subsequent call to this function or any pause function
            will disregard this event if it hasn't already been triggered.
            </summary>
            <param name="millisecondsFromNow">Time from now in milliseconds</param>
            <param name="fadeTimeInMs">Fade out time in ms</param>
        </member>
        <member name="M:TBE.AudioObject.pauseWithFade(System.Single)">
            <summary>
            Fadeout and pause playback.
            Any subsequent call to this function or any pause function
            will disregard this event if it hasn't already been triggered.
            </summary>
            <param name="fadeDurationInMs">Duration of the fade in milliseconds.</param>
        </member>
        <member name="M:TBE.AudioObject.seekToMs(System.Single)">
            <summary>
            Seek playback to an absolute point in milliseconds.
            </summary>
            <param name="ms">Time in milliseconds.</param>
        </member>
        <member name="M:TBE.AudioObject.getElapsedTimeInMs">
            <summary>
            Returns elapsed playback time in milliseconds.
            </summary>
            <returns>Returns elapsed playback time in milliseconds.</returns>
        </member>
        <member name="M:TBE.AudioObject.getDurationInMs">
            <summary>
            Returns the total duration of the asset in milliseconds.
            </summary>
            <returns>Returns the total duration of the asset in milliseconds.</returns>
        </member>
        <member name="M:TBE.AudioObject.getAssetDurationInMs">
            <summary>
            Returns the total duration of the asset in milliseconds.
            </summary>
            <returns>Returns the total duration of the asset in milliseconds.</returns>
        </member>
        <member name="M:TBE.AudioObject.getPlayState">
            <summary>
            Gets the play back state.
            </summary>
            <returns>The play back state.</returns>
        </member>
        <member name="M:TBE.AudioObject.cancelScheduledParams">
            <summary>
            Cancels any scheduled play states on the object
            </summary>
        </member>
        <member name="P:TBE.AudioObject.volume">
            <summary>
            Set the volume in linear gain
            </summary>
        </member>
        <member name="P:TBE.AudioObject.volumeDecibels">
            <summary>
            Set the volume in decibels
            </summary>
        </member>
        <member name="P:TBE.AudioObject.pitch">
            <summary>
            Set the pitch
            </summary>
        </member>
        <member name="P:TBE.AudioObject.loop">
            <summary>
            Toggle looping. Use this for sample accurate looping rather than manually
            seeking the file to 0 when it finishes playing.
            </summary>
        </member>
        <member name="P:TBE.AudioObject.minDistance">
            <summary>
            Minimum distance: the distance after which the attenuation effect kicks in
            </summary>
        </member>
        <member name="P:TBE.AudioObject.maxDistance">
            <summary>
            Maximum distance: the distance after which the attenuation stops
            </summary>
        </member>
        <member name="P:TBE.AudioObject.maxDistanceMute">
            <summary>
            Mute when maximum distance is reached (applicable when attenMode is set AttenuationMode.LOGARITHMIC)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:TBE.AudioObject.attenFactor" -->
        <member name="P:TBE.AudioObject.attenMode">
            <summary>
            The attenuation mode: LOGARITHMIC, LINEAR, DISABLE
            </summary>
        </member>
        <member name="P:TBE.AudioObject.directionality">
            <summary>
            Toggle directional filtering
            </summary>
        </member>
        <member name="P:TBE.AudioObject.directionalityLevel">
            <summary>
            A multiplier for the directionl filter, between 0 and 1,
            which changes how subtle or exaggerated the effect is.
            </summary>
        </member>
        <member name="P:TBE.AudioObject.directionalityConeArea">
            <summary>
            The directional cone area (in angles, between 0 and 359) where
            the sound is not modified. The area outside this will be filtered.
            </summary>
        </member>
        <member name="P:TBE.AudioObject.spatialise">
            <summary>
            If the sound must be spatialised or not
            </summary>
        </member>
        <member name="P:TBE.AudioObject.customTransform">
            <summary>
            Setting this to a non-null value will cause the component to use this
            Transform, rather that the GameObject it is attached to.
            </summary>
            <value>The custom transform.</value>
        </member>
        <member name="P:TBE.AudioObject.nativeObject">
            <summary>
            Returns the native object interface to access advanced features
            </summary>
            <value>The native object.</value>
        </member>
        <member name="M:TBE.ObbExtractor.getStreamingAssetsPath">
            <summary>
            Returns the path to streaming assets -- either persistent data path
            if assets are extracted from a obb or the default streamingAssetsPath
            </summary>
            <returns>The path to the file</returns>
        </member>
        <member name="M:TBE.ObbExtractor.streamingAssetsAreInObb">
            <summary>
            Returns true if the streaming assets are in an obb file
            </summary>
            <returns><c>true</c>, if the streaming assets are in an obb <c>false</c> otherwise.</returns>
        </member>
        <member name="M:TBE.ObbExtractor.extractFromObb(System.String[],System.Boolean)">
            <summary>
            Extracts files from .obb to the persistent data path.
            </summary>
            <param name="assetNames">Asset names to extract.</param>
            <param name="forceReplace">If set to <c>true</c> the file will be extracted even if a similar file already exists in the persistent data path.</param>
        </member>
        <member name="T:TBE.SpatDecoderFile">
            <summary>
            An object for playing back pre-baked spatial audio files.
            </summary>
        </member>
        <member name="F:TBE.SpatDecoderFile.file">
            File that must be played back
        </member>
        <member name="F:TBE.SpatDecoderFile.playOnStart">
            Play when Start() is called
        </member>
        <member name="M:TBE.SpatDecoderFile.init">
            Internal. Initialise the native object.
        </member>
        <member name="M:TBE.SpatDecoderFile.open(System.String,TBE.ChannelMap)">
            <summary>
            Opens an asset for playback. Currently .wav and .tbe file formats are supported. If no path is specified, 
            the asset will be loaded from Assets/StreamingAssets.
            While the asset is opened synchronously, it is loaded into the streaming buffer asynchronously. An
            event (Event.DECODER_INIT) will be dispatched to the event listener when the streaming buffer is ready for the
            asset to play.
            </summary>
            <param name="fileToplay">Name of the file in StreamAssets or the full path</param>
            <param name="map">Channel map/conifiguration of the file. If set to ChannelMap.UNKNOWN, the ChannelMap will be determined by parsing metadata</param>
            <returns>true if the file was found and successfully opened</returns>
        </member>
        <member name="M:TBE.SpatDecoderFile.open(TBE.IOStream,TBE.IOStream,TBE.ChannelMap)">
            <summary>
            Open an asset for playback using an IOStream abstraction. SpatDecoderFile uses two IOStream instances
            as it cross-fades between two streams during every seek or external synchronization call. 
            </summary>
            <returns>true if the file was found and successfully opened</returns>
            <param name="streamObjectA">Stream object used to open the audio asset.</param>
            <param name="streamObjectB">Stream object used to open the audio asset. Must point to the same asset used by <paramref name="streamObjectA"/></param>
            <param name="map">Channel map/conifiguration of the file. If set to ChannelMap.UNKNOWN, the ChannelMap will be determined by parsing metadata</param>
            <returns>true if the file was found and successfully opened</returns>
        </member>
        <member name="M:TBE.SpatDecoderFile.open(System.String,TBE.AssetDescriptor,TBE.ChannelMap)">
            <summary>
            Opens an asset for playback with additional information, such as the size and offset specified through
            assetDescriptor. Currently .wav and .tbe file formats are supported. If no path is specified, 
            the asset will be loaded from Assets/StreamingAssets.
            While the asset is opened synchronously, it is loaded into the streaming buffer asynchronously. An
            event (Event.DECODER_INIT) will be dispatched to the event listener when the streaming buffer is ready for the
            asset to play.
            </summary>
            <param name="fileToplay">Name of the file in StreamAssets or the full path</param>
            <param name="assetDescriptor">Custom file offset and size. Any or both values can be zero if unknown.</param>
            <param name="map">Channel map/conifiguration of the file. If set to ChannelMap.UNKNOWN, the ChannelMap will be determined by parsing metadata</param>
            <returns>true if the file was found and successfully opened</returns>
        </member>
        <member name="M:TBE.SpatDecoderFile.close">
            <summary>
            Close an opened file.
            </summary>
        </member>
        <member name="M:TBE.SpatDecoderFile.isOpen">
            <summary>
            Returns true if a file is open and ready.
            </summary>
            <returns>Returns true if a file is open and ready.</returns>
        </member>
        <member name="M:TBE.SpatDecoderFile.play">
            <summary>
            Begin playback of an opened file.
            Any subsequent call to this function or any play function
            will disregard this event if it hasn't already been triggered.
            </summary>
        </member>
        <member name="M:TBE.SpatDecoderFile.playScheduled(System.Single)">
            <summary>
            Schedule playback x milliseconds from now.
            Any subsequent call to this function or any play function
            will disregard this event if it hasn't already been triggered.
            </summary>
            <param name="millisecondsFromNow">Time from now in milliseconds</param>
        </member>
        <member name="M:TBE.SpatDecoderFile.playWithFade(System.Single)">
            <summary>
            Begin playback with a fade.
            Any subsequent call to this function or any play function
            will disregard this event if it hasn't already been triggered.
            </summary>
            <param name="fadeDurationInMs">Duration of the fade in milliseconds</param>
        </member>
        <member name="M:TBE.SpatDecoderFile.stop">
            <summary>
            Stop playback.
            Any subsequent call to this function or any stop function
            will disregard this event if it hasn't already been triggered.
            </summary>
        </member>
        <member name="M:TBE.SpatDecoderFile.stopScheduled(System.Single)">
            <summary>
            Schedule to stop playback x milliseconds from now.
            Any subsequent call to this function or any stop function
            will disregard this event if it hasn't already been triggered.
            </summary>
            <param name="millisecondsFromNow">Time from now in milliseconds</param>
        </member>
        <member name="M:TBE.SpatDecoderFile.stopWithFade(System.Single)">
            <summary>
            Fadeout and stop playback.
            Any subsequent call to this function or any stop function
            will disregard this event if it hasn't already been triggered.
            </summary>
            <param name="fadeDurationInMs">Duration of the fade in milliseconds.</param>
        </member>
        <member name="M:TBE.SpatDecoderFile.pause">
            <summary>
             Pause playback.
            Any subsequent call to this function or any pause function
            will disregard this event if it hasn't already been triggered.
            </summary>
        </member>
        <member name="M:TBE.SpatDecoderFile.pauseScheduled(System.Single)">
            <summary>
            Schedule playback to be paused x milliseconds from now.
            Any subsequent call to this function or any pause function
            will disregard this event if it hasn't already been triggered.
            </summary>
            <param name="millisecondsFromNow">Time from now in milliseconds</param>
        </member>
        <member name="M:TBE.SpatDecoderFile.pauseWithFade(System.Single)">
            <summary>
            Fadeout and pause playback.
            Any subsequent call to this function or any pause function
            will disregard this event if it hasn't already been triggered.
            </summary>
            <param name="fadeDurationInMs">Duration of the fade in milliseconds.</param>
        </member>
        <member name="M:TBE.SpatDecoderFile.getPlayState">
            <summary>
            Returns the current play state (Eg. playing, paused, stopped).
            </summary>
            <returns>Returns the current play state.</returns>
        </member>
        <member name="M:TBE.SpatDecoderFile.seekToMs(System.Single)">
            <summary>
            Seek playback to an absolute point in milliseconds.
            </summary>
            <param name="ms">Time in milliseconds.</param>
        </member>
        <member name="M:TBE.SpatDecoderFile.seekToSample(System.UInt32)">
            <summary>
            /// Seek playback to an absolute point in samples.
            </summary>
            <param name="sample">Time in samples</param>
        </member>
        <member name="M:TBE.SpatDecoderFile.getElapsedTimeInMs">
            <summary>
            Returns elapsed playback time in milliseconds.
            </summary>
            <returns>Returns elapsed playback time in milliseconds.</returns>
        </member>
        <member name="M:TBE.SpatDecoderFile.getElapsedTimeInSamples">
            <summary>
            Returns elapsed playback time in samples.
            </summary>
            <returns>Returns elapsed playback time in samples.</returns>
        </member>
        <member name="M:TBE.SpatDecoderFile.getAssetDurationInMs">
            <summary>
            Returns the total duration of the asset in milliseconds.
            </summary>
            <returns>Returns the total duration of the asset in milliseconds.</returns>
        </member>
        <member name="M:TBE.SpatDecoderFile.getAssetDurationInSamples">
            <summary>
            Returns the total duration of the asset in samples.
            </summary>
            <returns>Returns the total duration of the asset in samples.</returns>
        </member>
        <member name="M:TBE.SpatDecoderFile.setExternalClockInMs(System.Double)">
            <summary>
            Set the external time source in milliseconds. The audio asset will chase this time
            source. Only applicable when the SyncMode is set to SyncMode.EXTERNAL
            </summary>
            <param name="externalClockInMs">External time in milliseconds, to be updated every frame.</param>
        </member>
        <member name="M:TBE.SpatDecoderFile.setFreewheelTimeInMs(System.Double)">
            <summary>
            Set how often the engine tries to synchronise to the external clock. Very low values can result in stutter,
            very high values can result in synchronisation latency.
            This method along with setResyncThresholdMs() can be used to fine-tune synchronisation.
            </summary>
            <param name="freewheelInMs"></param>
        </member>
        <member name="M:TBE.SpatDecoderFile.getFreewheelTimeInMs">
            <summary>
            Returns the free wheel time in milliseconds
            </summary>
            <returns>Returns the free wheel time in milliseconds</returns>
        </member>
        <member name="M:TBE.SpatDecoderFile.setResyncThresholdMs(System.Double)">
            <summary>
            The time threshold after which the engine will synchronise to the external clock.
            This method along with setFreewheelTimeInMs() can be used to fine-tune synchronisation.
            </summary>
            <param name="resyncThresholdMs">Synchronisation threshold in milliseconds</param>
        </member>
        <member name="M:TBE.SpatDecoderFile.getResyncThresholdMs">
            <summary>
            Returns the current synchronisation threshold.
            </summary>
            <returns>Returns the current synchronisation threshold.</returns>
        </member>
        <member name="P:TBE.SpatDecoderFile.volume">
            <summary>
            Set the volume in linear gain
            </summary>
        </member>
        <member name="P:TBE.SpatDecoderFile.volumeDecibels">
            <summary>
            Set the volume in decibels
            </summary>
        </member>
        <member name="P:TBE.SpatDecoderFile.syncMode">
            <summary>
            Set synchronisation mode. Default is SyncMode.INTERNAL. When set to
            SyncMode.EXTERNAL, setExternalClockInMs() can be used to get the audio
            asset to chase an external time source.
            </summary>
        </member>
        <member name="P:TBE.SpatDecoderFile.focus">
            <summary>
            Enable mix focus. This gets a specified area of the mix to be more audible than surrounding areas, by reducing
            the volume of the area that isn't in focus.
            </summary>
        </member>
        <member name="P:TBE.SpatDecoderFile.offFocusLeveldB">
            <summary>
            The attenuation level in dB outside of the focus area. Between 0dB and -24dB.
            </summary>
        </member>
        <member name="P:TBE.SpatDecoderFile.focusWidth">
            <summary>
            Set the width angle in degrees of the focus area, between 40 and 120 degrees.
            </summary>
        </member>
        <member name="P:TBE.SpatDecoderFile.loop">
            <summary>
            Toggle looping. Use this for sample accurate looping rather than manually 
            seeking the file to 0 when it finishes playing.
            </summary>
        </member>
        <member name="P:TBE.SpatDecoderFile.useObjectRotation">
            <summary>
            Use the GameObject's rotation to rotate the ambisonic field
            </summary>
        </member>
        <member name="P:TBE.SpatDecoderFile.customTransform">
            <summary>
            Setting this to a non-null value will cause the component to use this 
            Transform, rather that the GameObject it is attached to.
            </summary>
            <value>The custom transform.</value>
        </member>
        <member name="P:TBE.SpatDecoderFile.nativeObject">
            <summary>
            Returns the native object interface to access advanced features
            </summary>
            <value>The native object.</value>
        </member>
        <member name="M:TBE.SpatDecoderFile.createOnObject(UnityEngine.GameObject,System.String,TBE.ChannelMap)">
            <summary>
            Helper method to create an instance of SpatDecoderFile on a GameObject
            </summary>
            <param name="ga">GameObject instance</param>
            <param name="file">File to be played back</param>
            <param name="map">Channel map/spatial format of the file</param>
            <returns></returns>
        </member>
        <member name="M:TBE.RuntimeOptions.Create(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a RuntimeOptions struct (used in AudioManager/Boostrapper initialization) to setup the engine to work
            in legacy mode.
            </summary>
            <param name="objectPoolSize">Number of <code>NativeAudioObject</code> in the pool</param>
            <param name="spatFilePoolSize">Number of <code>NativeSpatDecoderFile</code> in the pool</param>
            <param name="queuePoolSize">Number of <code>NativeSpatDecoderQueue</code> in the pool</param>
            <returns></returns>
        </member>
        <member name="M:TBE.Utils.resolvePath(System.String,TBE.PathType)">
            Resolve streaming assets path.
        </member>
        <member name="T:Gvr.Internal.gvr_feature">
            <summary>Maps to  gvr_feature in the C API.</summary>
        </member>
        <member name="T:Gvr.Internal.gvr_property_type">
            <summary>Maps to gvr_property_type in the C API.</summary>
        </member>
        <member name="F:Gvr.Internal.gvr_property_type.TrackingFloorHeight">
            <summary>float; `GVR_PROPERTY_TRACKING_FLOOR_HEIGHT`</summary>
        </member>
        <member name="F:Gvr.Internal.gvr_property_type.RecenterTransform">
            <summary>gvr_mat4f, `GVR_PROPERTY_RECENTER_TRANSFORM`</summary>
        </member>
        <member name="F:Gvr.Internal.gvr_property_type.SafetyRegion">
            <summary>int (`gvr_safety_region_type`), `GVR_PROPERTY_SAFETY_REGION`</summary>
        </member>
        <member name="F:Gvr.Internal.gvr_property_type.SafetyCylinderInnerRadius">
            <summary>float, `GVR_PROPERTY_SAFETY_CYLINDER_INNER_RADIUS`</summary>
        </member>
        <member name="F:Gvr.Internal.gvr_property_type.SafetyCylinderOuterRadius">
            <summary>float, `GVR_PROPERTY_SAFETY_CYLINDER_OUTER_RADIUS`</summary>
        </member>
        <member name="T:Gvr.Internal.gvr_value_type">
            <summary>Maps to gvr_value_type in the C API.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Gvr.Internal.gvr_value_type.None" -->
        <!-- Badly formed XML comment ignored for member "F:Gvr.Internal.gvr_value_type.Float" -->
        <!-- Badly formed XML comment ignored for member "F:Gvr.Internal.gvr_value_type.Double" -->
        <!-- Badly formed XML comment ignored for member "F:Gvr.Internal.gvr_value_type.Int" -->
        <!-- Badly formed XML comment ignored for member "F:Gvr.Internal.gvr_value_type.Int64" -->
        <!-- Badly formed XML comment ignored for member "F:Gvr.Internal.gvr_value_type.Flags" -->
        <!-- Badly formed XML comment ignored for member "F:Gvr.Internal.gvr_value_type.Sizei" -->
        <!-- Badly formed XML comment ignored for member "F:Gvr.Internal.gvr_value_type.Recti" -->
        <!-- Badly formed XML comment ignored for member "F:Gvr.Internal.gvr_value_type.Rectf" -->
        <!-- Badly formed XML comment ignored for member "F:Gvr.Internal.gvr_value_type.Vec2f" -->
        <!-- Badly formed XML comment ignored for member "F:Gvr.Internal.gvr_value_type.Vec3f" -->
        <!-- Badly formed XML comment ignored for member "F:Gvr.Internal.gvr_value_type.Quat" -->
        <!-- Badly formed XML comment ignored for member "F:Gvr.Internal.gvr_value_type.Mat4f" -->
        <!-- Badly formed XML comment ignored for member "F:Gvr.Internal.gvr_value_type.ClockTimePoint" -->
        <!-- Badly formed XML comment ignored for member "T:Gvr.Internal.gvr_recenter_flags" -->
        <!-- Badly formed XML comment ignored for member "F:Gvr.Internal.gvr_recenter_flags.None" -->
        <member name="T:Gvr.Internal.ControllerProviderFactory">
            Factory that provides a concrete implementation of IControllerProvider for the
            current platform.
        </member>
        <member name="M:Gvr.Internal.ControllerProviderFactory.CreateControllerProvider(GvrControllerInput)">
            Provides a concrete implementation of IControllerProvider appropriate for the current
            platform. This method never returns null. In the worst case, it might return a dummy
            provider if the platform is not supported. For demo purposes the emulator controller
            is returned in the editor and in Standalone buids, for use inside the desktop player.
        </member>
        <member name="T:Gvr.Internal.ControllerState">
             Internal representation of the controller's current state.
             This representation is used by controller providers to represent the controller's state.
            
             The fields in this class have identical meanings to their correspondents in the GVR C API,
             so they are not redundantly documented here.
        </member>
        <member name="M:Gvr.Internal.ControllerState.ClearTransientState">
            Resets the transient state (the state variables that represent events, and which are true
            for only one frame).
        </member>
        <member name="F:Gvr.Internal.ControllerUtils.AllHands">
            Convenience array of all hands.
        </member>
        <member name="M:Gvr.Internal.ControllerUtils.AnyButton(GvrControllerButton)">
            Returns true while the user holds down any of buttons specified in `buttons` on
            any controller.
        </member>
        <member name="M:Gvr.Internal.ControllerUtils.AnyButtonDown(GvrControllerButton)">
            Returns true in the frame the user starts pressing down any of buttons specified
            in `buttons` on any controller.
        </member>
        <member name="M:Gvr.Internal.ControllerUtils.AnyButtonUp(GvrControllerButton)">
            Returns true the frame after the user stops pressing down any of buttons specified
            in `buttons` on any controller.
        </member>
        <member name="T:Gvr.Internal.DummyControllerProvider">
            Dummy controller provider.
            Used in platforms that do not support controllers.
        </member>
        <member name="T:Gvr.Internal.EditorCameraOriginDict">
            <summary>A class module for providing Camera origin position and rotation.</summary>
            <remarks>
            A VR camera's position and rotation at start-time should be the center of its experience.
            To accomodate this, this module saves their initial localPosition and localRotation as
            localOriginPosition and localOriginRotation, allowing those to be applied every Update.
            </remarks>
        </member>
        <member name="M:Gvr.Internal.EditorCameraOriginDict.Get(UnityEngine.Camera)">
            <summary>A lazy getter for the Camera's origin.</summary>
        </member>
        <member name="T:Gvr.Internal.EditorControllerProvider">
            Controller provider used when playing in the Unity Editor.
            Supports the Controller Emulator and Mouse input to mock the controller.
        </member>
        <member name="T:Gvr.Internal.EmulatorControllerProvider">
            Controller provider that connects to the controller emulator to obtain controller events.
        </member>
        <member name="F:Gvr.Internal.EmulatorControllerProvider.yawCorrection">
            Yaw correction due to recentering.
        </member>
        <member name="F:Gvr.Internal.EmulatorControllerProvider.initialRecenterDone">
            True if we performed the initial recenter.
        </member>
        <member name="F:Gvr.Internal.EmulatorControllerProvider.lastRawOrientation">
            The last (uncorrected) orientation received from the emulator.
        </member>
        <member name="M:Gvr.Internal.EmulatorControllerProvider.#ctor(GvrControllerInput.EmulatorConnectionMode)">
            Creates a new EmulatorControllerProvider with the specified settings.
        </member>
        <member name="T:Gvr.Internal.EmulatorKeyboardProvider">
            Keyboard subclass to run in the Unity editor
        </member>
        <member name="T:Gvr.Internal.GvrBetaHeadsetProvider">
            <summary>Daydream headset beta provider.</summary>
        </member>
        <member name="T:Gvr.Internal.GvrBetaSettingsProvider">
            <summary>Daydream headset beta provider.</summary>
        </member>
        <member name="T:Gvr.Internal.GvrCursorHelper">
            <summary>
            Manages cursor lock state while developer is using editor head and controller emulation.
            </summary>
        </member>
        <member name="F:Gvr.Internal.GvrCursorHelper.cachedHeadEmulationActive">
            <summary>Whether MouseControllerProvider is currently tracking mouse movement.</summary>
        </member>
        <member name="F:Gvr.Internal.GvrCursorHelper.cachedControllerEmulationActive">
            <summary>Whether GvrEditorEmulator is currently tracking mouse movement.</summary>
        </member>
        <member name="P:Gvr.Internal.GvrCursorHelper.HeadEmulationActive">
            <summary>Sets a value indicating whether head emulation is active.</summary>
        </member>
        <member name="P:Gvr.Internal.GvrCursorHelper.ControllerEmulationActive">
            <summary>Sets a value indicating whether controller emulation is active.</summary>
        </member>
        <member name="T:Gvr.Internal.HeadsetProviderFactory">
            <summary>
            Factory that provides a concrete implementation of `IHeadsetProvider` for the current
            platform.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Gvr.Internal.HeadsetProviderFactory.CreateProvider" -->
        <member name="M:Gvr.Internal.HeadsetState.Initialize">
            <summary>
            An initialization method for this struct to set its values to their defaults.
            </summary>
        </member>
        <member name="T:Gvr.Internal.IControllerProvider">
             Internal interface that abstracts an implementation of a controller.
            
             Each platform has a different concrete implementation of a Controller Provider.
             For example, if running on the Unity Editor, we use an implementation that
             communicates with the controller emulator via USB or WiFi. If running on a real
             Android device, we use an implementation that uses the underlying Daydream controller API.
        </member>
        <member name="P:Gvr.Internal.IControllerProvider.SupportsBatteryStatus">
            True if controller has battery status support.
        </member>
        <member name="P:Gvr.Internal.IControllerProvider.MaxControllerCount">
            Reads the number of controllers the system is configured to use.  This does not
            indicate the number of currently connected controllers.
        </member>
        <member name="M:Gvr.Internal.IControllerProvider.OnPause">
            Notifies the controller provider that the application has paused.
        </member>
        <member name="M:Gvr.Internal.IControllerProvider.OnResume">
            Notifies the controller provider that the application has resumed.
        </member>
        <member name="M:Gvr.Internal.IControllerProvider.ReadState(Gvr.Internal.ControllerState,System.Int32)">
            Reads the controller's current state and stores it in outState.
        </member>
        <member name="P:Gvr.Internal.IHeadsetProvider.SupportsPositionalTracking">
            <summary>
            Gets a value indicating whether the current headset supports positionally tracked,
            6DoF head poses.
            </summary>
            <value>
            Value `true` if the current headset supports positionally tracked, 6DoF head poses,
            `false` otherwise.
            </value>
        </member>
        <member name="M:Gvr.Internal.IHeadsetProvider.PollEventState(Gvr.Internal.HeadsetState@)">
            <summary>Polls for GVR headset events.</summary>
        </member>
        <member name="M:Gvr.Internal.IHeadsetProvider.TryGetFloorHeight(System.Single@)">
            <summary>
            Populates `floorHeight` with the detected height, if one is available.
            </summary>
            <remarks>This may be unavailable if the underlying GVR API call fails.</remarks>
            <returns>
            Returns `true` if value retrieval was successful, `false` otherwise.
            </returns>
            <param name="floorHeight">
            If this call returns `true`, this value is set to the retrieved `floorHeight`.
            Otherwise leaves the value unchanged.
            </param>
        </member>
        <member name="M:Gvr.Internal.IHeadsetProvider.TryGetRecenterTransform(UnityEngine.Vector3@,UnityEngine.Quaternion@)">
            <summary>
            Populates position and rotation with the last recenter transform, if one is available.
            </summary>
            <remarks>This may be unavailable if the underlying GVR API call fails.</remarks>
            <returns>Returns `true` if value retrieval was successful, `false` otherwise.</returns>
            <param name="position">
            If this call returns `true`, this value is set to the retrieved position.
            </param>
            <param name="rotation">
            If this call returns `true`, this value is set to the retrieved rotation.
            </param>
        </member>
        <member name="M:Gvr.Internal.IHeadsetProvider.TryGetSafetyRegionType(GvrSafetyRegionType@)">
            <summary>
            Populates `safetyType` with the safety region type, if one is available.
            </summary>
            <remarks>
            Populates `safetyType` with the available safety region feature on the currently-running
            device.  This may be unavailable if the underlying GVR API call fails.
            </remarks>
            <returns>Returns `true` if value retrieval was successful, `false` otherwise.</returns>
            <param name="safetyType">
            If this call returns `true`, this value is set to the retrieved `safetyType`.
            </param>
        </member>
        <member name="M:Gvr.Internal.IHeadsetProvider.TryGetSafetyCylinderInnerRadius(System.Single@)">
            <summary>
            Populates `innerRadius` with the safety cylinder inner radius, if one is available.
            </summary>
            <remarks>
            If the safety region is of type `GvrSafetyRegionType.Cylinder`, populates `innerRadius`
            with the inner radius size of the safety cylinder in meters.  Before using, confirm that
            the safety region type is `GvrSafetyRegionType.Cylinder`.  This may be unavailable if
            the underlying GVR API call fails.
            <para>
            This is the radius at which safety management (e.g. safety fog) may cease taking effect.
            </para></remarks>
            <returns>Returns `true` if value retrieval was successful, `false` otherwise.</returns>
            <param name="innerRadius">
            If this call returns `true`, this value is set to the retrieved `innerRadius`.
            </param>
        </member>
        <member name="M:Gvr.Internal.IHeadsetProvider.TryGetSafetyCylinderOuterRadius(System.Single@)">
            <summary>
            Populates `outerRadius` with the safety cylinder outer radius, if one is available.
            </summary>
            <remarks>
            If the safety region is of type `GvrSafetyRegionType.Cylinder`, populates `outerRadius`
            with the outer radius size of the safety cylinder in meters.  Before using, confirm that
            the safety region type is `GvrSafetyRegionType.Cylinder`.  This may be unavailable if
            the underlying GVR API call fails.
            <para>
            This is the radius at which safety management (e.g. safety fog) may start to take
            effect.
            </para></remarks>
            <returns>Returns `true` if value retrieval was successful, `false` otherwise.</returns>
            <param name="outerRadius">
            If this call returns `true`, this value is set to the retrieved `outerRadius`.
            </param>
        </member>
        <member name="T:Gvr.Internal.IKeyboardProvider">
             Internal interface that abstracts an implementation of a keyboard.
            
             Each platform has a different concrete implementation of a Keyboard Provider.
             For example, if running on the Unity Editor, we use an implementation that
             emulates the keyboard behaviour. If running on a real Android device,
             we use an implementation that uses the underlying Daydream keyboard API.
        </member>
        <member name="M:Gvr.Internal.IKeyboardProvider.OnPause">
            Notifies the controller provider that the application has paused.
        </member>
        <member name="M:Gvr.Internal.IKeyboardProvider.OnResume">
            Notifies the controller provider that the application has resumed.
        </member>
        <member name="M:Gvr.Internal.IKeyboardProvider.ReadState(KeyboardState)">
            Reads the controller's current state and stores it in outState.
        </member>
        <member name="T:Gvr.Internal.InstantPreview">
            <summary>A class module for handling Instant Preview.</summary>
            <remarks><para>
            Handles connecting to the Instant Preview Unity plugin.
            </para><para>
            Serves as an interface for retrieving many headset-oriented fields.
            </para><para>
            Streams video data to the Instant Preview Unity plugin.
            </para></remarks>
        </member>
        <member name="P:Gvr.Internal.InstantPreview.IsActive">
            <summary>
            Gets whether Instant Preview is currently connected to and running on a remote device.
            </summary>
        </member>
        <member name="P:Gvr.Internal.InstantPreview.Instance">
            <summary>Gets or sets this singleton's instance.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.dllName">
            <summary>The .dll filename of the Instant Preview Unity plugin.</summary>
        </member>
        <member name="T:Gvr.Internal.InstantPreview.Resolutions">
            <summary>Video resolutions for streaming to the connected device.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.Resolutions.Big">
            A high-resolution image.
        </member>
        <member name="F:Gvr.Internal.InstantPreview.Resolutions.Regular">
            A regular-resolution image.
        </member>
        <member name="F:Gvr.Internal.InstantPreview.Resolutions.WindowSized">
            A window-sized image.
        </member>
        <member name="F:Gvr.Internal.InstantPreview.OutputResolution">
            <summary>Resolution of video stream.</summary>
            <remarks>Higher = more expensive / better visual quality.</remarks>
        </member>
        <member name="T:Gvr.Internal.InstantPreview.MultisampleCounts">
            <summary>Options for anti-aliasing sampling.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.MultisampleCounts.One">
            <summary>Take one sample per frame.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.MultisampleCounts.Two">
            <summary>Take two samples per frame.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.MultisampleCounts.Four">
            <summary>Take four samples per frame.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.MultisampleCounts.Eight">
            <summary>Take eight samples per frame.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.MultisampleCount">
            <summary>Anti-aliasing for video preview.</summary>
            <remarks>Higher = more expensive / better visual quality.</remarks>
        </member>
        <member name="T:Gvr.Internal.InstantPreview.BitRates">
            <summary>Bit rates for video codec streaming.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.BitRates._2000">
            <summary>A bit rate of 2000kb/s.  The lowest available bit rate.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.BitRates._4000">
            <summary>A bit rate of 4000kb/s.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.BitRates._8000">
            <summary>A bit rate of 8000kb/s.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.BitRates._16000">
            <summary>A bit rate of 16000kb/s.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.BitRates._24000">
            <summary>A bit rate of 24000kb/s.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.BitRates._32000">
            <summary>A bit rate of 32000kb/s.  The highest available bit rate</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.BitRate">
            <summary>Video codec streaming bit rate.</summary>
            <remarks>Higher = more expensive / better visual quality.</remarks>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.InstallApkOnRun">
            <summary>
            If true, installs the Instant Preview app if it isn't found on the connected device.
            </summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.InstantPreviewApk">
            <summary>An .apk file containing the Instant Preview app.</summary>
            <remarks>
            Will be installed on connected devices which don't already have it, or which have an
            out-of-date version.
            </remarks>
        </member>
        <member name="T:Gvr.Internal.InstantPreview.UnityBoolAtom">
            <summary>A Unity C#-compliant wrapper for a boolean.</summary>
            <remarks><para>
            This is also defined on the Instant Preview plugin in native C++.
            </para><para>
            If `isValid` is `false`, `value` should be ignored.
            </para></remarks>
        </member>
        <member name="T:Gvr.Internal.InstantPreview.UnityFloatAtom">
            <summary>A Unity C#-compliant wrapper for a float.</summary>
            <remarks><para>
            This is also defined on the Instant Preview plugin in native C++.
            </para><para>
            If `isValid` is `false`, `value` should be ignored.
            </para></remarks>
        </member>
        <member name="T:Gvr.Internal.InstantPreview.UnityIntAtom">
            <summary>A Unity C#-compliant wrapper for an integer.</summary>
            <remarks><para>
            This is also defined on the Instant Preview plugin in native C++.
            </para><para>
            If `isValid` is `false`, `value` should be ignored.
            </para></remarks>
        </member>
        <member name="T:Gvr.Internal.InstantPreview.UnityGvrMat4fAtom">
            <summary>A Unity C#-compliant wrapper for a 4x4 matrix.</summary>
            <remarks><para>
            This is also defined on the Instant Preview plugin in native C++.
            </para><para>
            If `isValid` is `false`, `value` should be ignored.
            </para></remarks>
        </member>
        <member name="T:Gvr.Internal.InstantPreview.GvrEventType">
            <summary>GVR Event Types. Associated with ephemeral (one-frame-long) events.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.GvrEventType.GVR_EVENT_NONE">
            <summary>A default value. If this is seen, something has gone wrong.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.GvrEventType.GVR_EVENT_RECENTER">
            <summary>Indicates a recenter event.</summary>
            <remarks>
            This should always be accompanied by a`GvrRecenterEventType` providing additional
            details.
            </remarks>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.GvrEventType.GVR_EVENT_SAFETY_REGION_EXIT">
            <summary>Indicates that the safety region has been exited.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.GvrEventType.GVR_EVENT_SAFETY_REGION_ENTER">
            <summary>Indicates that the safety region has been entered.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.GvrEventType.GVR_EVENT_HEAD_TRACKING_RESUMED">
            <summary>Indicates that head tracking has resumed.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.GvrEventType.GVR_EVENT_HEAD_TRACKING_PAUSED">
            <summary>Indicates that head tracking has paused.</summary>
        </member>
        <member name="T:Gvr.Internal.InstantPreview.GvrRecenterEventType">
            <summary>
            GVR Recenter Event Types. Provides details for `GvrEventType.GVR_EVENT_RECENTER`.
            </summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.GvrRecenterEventType.GVR_RECENTER_EVENT_NONE">
            <summary>A default value. If this is seen, something has gone wrong.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.GvrRecenterEventType.GVR_RECENTER_EVENT_RESTART">
            <summary>Indicates that the recenter event occurred because of a restart.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.GvrRecenterEventType.GVR_RECENTER_EVENT_ALIGNED">
            <summary>Indicates that the recenter event occurred because of a realign.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.GvrRecenterEventType.GVR_RECENTER_EVENT_DON">
            <summary>
            Indicates that the recenter event occurred because the headset was donned.
            </summary>
        </member>
        <member name="T:Gvr.Internal.InstantPreview.UnityGvrRecenterEventData">
            <summary>
            Accompanies a `GvrEventType.GVR_EVENT_RECENTER`.  Provides additional details about
            the recenter event.
            </summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.UnityGvrRecenterEventData.recenter_type">
            <summary>The type of recenter event.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.UnityGvrRecenterEventData.recenter_event_flags">
            <summary>Recenter event flags.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Gvr.Internal.InstantPreview.UnityGvrRecenterEventData.start_space_from_tracking_space_transform" -->
        <member name="T:Gvr.Internal.InstantPreview.UnityGvrEvent">
            <summary>GVR event details, received any time an event occurs.</summary>
            <remarks>This is also defined on the Instant Preview plugin in native C++.</remarks>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.UnityGvrEvent.timestamp">
            <summary>Timestamp in nanoseconds.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.UnityGvrEvent.type">
            <summary>The event type.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.UnityGvrEvent.flags">
            <summary>The event's flags.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.UnityGvrEvent.gvr_recenter_event_data">
            <summary>Additional details on recenter events.</summary>
            <remarks>Not null if and only if event type is `GVR_EVENT_RECENTER`.</remarks>
        </member>
        <member name="T:Gvr.Internal.InstantPreview.UnityGvrUserPreferences">
            <summary>GVR User Preferences.</summary>
            <remarks>
            Associated with options set by the user in the Daydream app.</remarks>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.UnityGvrUserPreferences.handedness">
            <summary>The user's handedness preference.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.overrideDeviceUserPrefs">
            <summary>If `true`, overrides user preferences received from remote device with those
            set in the InstantPreview editor inspector.</summary>
        </member>
        <member name="P:Gvr.Internal.InstantPreview.deviceUserPrefs">
            <summary>The User Preferences to use if `overrideDeviceUserPrefs` is `false`.</summary>
        </member>
        <member name="P:Gvr.Internal.InstantPreview.IsCurrentlyConnected">
            <summary>
            Gets whether this module is currently connected to a running Instant Preview app.
            </summary>
            <value>
            Value `true` if this module is currently connected to a running Instant Preview app,
            `false` otherwise.
            </value>
        </member>
        <member name="P:Gvr.Internal.InstantPreview.supportsPositionalHeadTracking">
            <summary>Gets whether the connected device supports positional tracking.</summary>
        </member>
        <member name="P:Gvr.Internal.InstantPreview.supportsSeeThrough">
            <summary>Gets whether the connected device supports see-through mode.</summary>
        </member>
        <member name="P:Gvr.Internal.InstantPreview.floorHeight">
            <summary>Gets the current height the headset is off its perceived floor.</summary>
            <remarks>The `value` is valid only if `floorHeight.isValid == true`.</remarks>
        </member>
        <member name="P:Gvr.Internal.InstantPreview.recenterTransform">
            <summary>Gets the last recenter's offset transform.</summary>
            <remarks>The `value` is valid only if `recenterTransform.isValid == true`.</remarks>
        </member>
        <member name="P:Gvr.Internal.InstantPreview.safetyRegionType">
            <summary>Gets the type of the safety region.</summary>
            <remarks>The `value` is valid only if `safetyRegionType.isValid == true`.</remarks>
        </member>
        <member name="P:Gvr.Internal.InstantPreview.safetyCylinderEnterRadius">
            <summary>Gets the reentry radius of a cylindrical safety region.</summary>
            <remarks><para>
            Entering the safety cylinder means stepping close enough to its center to suppress an
            active warning.
            </para><para>
            The `value` is valid only if `safetyCylinderEnterRadius.isValid == true`.
            </para></remarks>
        </member>
        <member name="P:Gvr.Internal.InstantPreview.safetyCylinderExitRadius">
            <summary>Gets the exit radius of a cylindrical safety region.</summary>
            <remarks><para>
            Exiting the safety cylinder means stepping far enough from its center to prompt a
            warning.
            </para><para>
            The `value` is valid only if `safetyCylinderExitRadius.isValid == true`.
            </para></remarks>
        </member>
        <member name="P:Gvr.Internal.InstantPreview.handedness">
            <summary>Gets the user's handedness preference.</summary>
        </member>
        <member name="F:Gvr.Internal.InstantPreview.events">
            <summary>A queue for active GVR events.</summary>
            <remarks>
            This is used because events only trigger for one frame, and in some high-CPU edge cases
            the Instant Preview stream may run at a different speed than the Unity player.
            Because they are stored on a queue, the Unity player can guarantee it will eventually
            trigger them all.</remarks>
        </member>
        <member name="T:Gvr.Internal.KeyboardProviderFactory">
            Factory that provides a concrete implementation of IKeyboardProvider for the
            current platform.
        </member>
        <member name="T:Gvr.Internal.MouseControllerProvider">
            Mocks controller input by using the mouse.
            The controller is connected when holding left shift.
            Move the mouse to control gyroscope and orientation.
            The left mouse button is used for the clickButton.
            The right mouse button is used for the appButton.
            The middle mouse button is used for the homeButton.
        </member>
        <member name="F:Gvr.Internal.MouseControllerProvider.wasTouching">
            Need to store the state of the buttons from the previous frame.
            This is because Input.GetMouseButtonDown and Input.GetMouseButtonUp
            don't work when called after WaitForEndOfFrame, which is when ReadState is called.
        </member>
        <member name="T:Gvr.Internal.SuppressMemoryAllocationErrorAttribute">
            <summary>
            A custom Attribute class to annotate functions that are allowed to allocate memory.
            </summary>
        </member>
        <member name="M:Gvr.Internal.SuppressMemoryAllocationErrorAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GoogleVR.Internal.SuppressMemoryAllocationErrorAttribute"/> class.
            </summary>
        </member>
        <member name="P:Gvr.Internal.SuppressMemoryAllocationErrorAttribute.IsWarning">
            <summary>
            Gets or sets a value indicating whether to show a warning instead of an error.
            </summary>
        </member>
        <member name="P:Gvr.Internal.SuppressMemoryAllocationErrorAttribute.Reason">
            <summary>
            Gets or sets the reason for suppressing the memory allocation error.
            </summary>
        </member>
        <member name="M:LiteNetLib.ConnectionRequest.Accept">
            <summary>
            Accept connection and get new NetPeer as result
            </summary>
            <returns>Connected NetPeer</returns>
        </member>
        <member name="M:LiteNetLib.Utils.NetDataWriter.FromBytes(System.Byte[],System.Boolean)">
            <summary>
            Creates NetDataWriter from existing ByteArray
            </summary>
            <param name="bytes">Source byte array</param>
            <param name="copy">Copy array to new location or use existing</param>
        </member>
        <member name="M:LiteNetLib.Utils.NetDataWriter.FromBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates NetDataWriter from existing ByteArray (always copied data)
            </summary>
            <param name="bytes">Source byte array</param>
            <param name="offset">Offset of array</param>
            <param name="length">Length of array</param>
        </member>
        <member name="M:LiteNetLib.Utils.NetPacketProcessor.RegisterNestedType``1">
            <summary>
            Register nested property type
            </summary>
            <typeparam name="T">INetSerializable structure</typeparam>
            <returns>True - if register successful, false - if type already registered</returns>
        </member>
        <member name="M:LiteNetLib.Utils.NetPacketProcessor.RegisterNestedType``1(System.Action{LiteNetLib.Utils.NetDataWriter,``0},System.Func{LiteNetLib.Utils.NetDataReader,``0})">
            <summary>
            Register nested property type
            </summary>
            <param name="writeDelegate"></param>
            <param name="readDelegate"></param>
            <returns>True - if register successful, false - if type already registered</returns>
        </member>
        <member name="M:LiteNetLib.Utils.NetPacketProcessor.RegisterNestedType``1(System.Func{``0})">
            <summary>
            Register nested property type
            </summary>
            <typeparam name="T">INetSerializable class</typeparam>
            <returns>True - if register successful, false - if type already registered</returns>
        </member>
        <member name="M:LiteNetLib.Utils.NetPacketProcessor.ReadAllPackets(LiteNetLib.Utils.NetDataReader)">
            <summary>
            Reads all available data from NetDataReader and calls OnReceive delegates
            </summary>
            <param name="reader">NetDataReader with packets data</param>
        </member>
        <member name="M:LiteNetLib.Utils.NetPacketProcessor.ReadAllPackets(LiteNetLib.Utils.NetDataReader,System.Object)">
            <summary>
            Reads all available data from NetDataReader and calls OnReceive delegates
            </summary>
            <param name="reader">NetDataReader with packets data</param>
            <param name="userData">Argument that passed to OnReceivedEvent</param>
            <exception cref="T:LiteNetLib.Utils.ParseException">Malformed packet</exception>
        </member>
        <member name="M:LiteNetLib.Utils.NetPacketProcessor.ReadPacket(LiteNetLib.Utils.NetDataReader)">
            <summary>
            Reads one packet from NetDataReader and calls OnReceive delegate
            </summary>
            <param name="reader">NetDataReader with packet</param>
            <exception cref="T:LiteNetLib.Utils.ParseException">Malformed packet</exception>
        </member>
        <member name="M:LiteNetLib.Utils.NetPacketProcessor.ReadPacket(LiteNetLib.Utils.NetDataReader,System.Object)">
            <summary>
            Reads one packet from NetDataReader and calls OnReceive delegate
            </summary>
            <param name="reader">NetDataReader with packet</param>
            <param name="userData">Argument that passed to OnReceivedEvent</param>
            <exception cref="T:LiteNetLib.Utils.ParseException">Malformed packet</exception>
        </member>
        <member name="M:LiteNetLib.Utils.NetPacketProcessor.Subscribe``1(System.Action{``0},System.Func{``0})">
            <summary>
            Register and subscribe to packet receive event
            </summary>
            <param name="onReceive">event that will be called when packet deserialized with ReadPacket method</param>
            <param name="packetConstructor">Method that constructs packet intead of slow Activator.CreateInstance</param>
            <exception cref="T:LiteNetLib.Utils.InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        </member>
        <member name="M:LiteNetLib.Utils.NetPacketProcessor.Subscribe``2(System.Action{``0,``1},System.Func{``0})">
            <summary>
            Register and subscribe to packet receive event (with userData)
            </summary>
            <param name="onReceive">event that will be called when packet deserialized with ReadPacket method</param>
            <param name="packetConstructor">Method that constructs packet intead of slow Activator.CreateInstance</param>
            <exception cref="T:LiteNetLib.Utils.InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        </member>
        <member name="M:LiteNetLib.Utils.NetPacketProcessor.SubscribeReusable``1(System.Action{``0})">
            <summary>
            Register and subscribe to packet receive event
            This metod will overwrite last received packet class on receive (less garbage)
            </summary>
            <param name="onReceive">event that will be called when packet deserialized with ReadPacket method</param>
            <exception cref="T:LiteNetLib.Utils.InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        </member>
        <member name="M:LiteNetLib.Utils.NetPacketProcessor.SubscribeReusable``2(System.Action{``0,``1})">
            <summary>
            Register and subscribe to packet receive event
            This metod will overwrite last received packet class on receive (less garbage)
            </summary>
            <param name="onReceive">event that will be called when packet deserialized with ReadPacket method</param>
            <exception cref="T:LiteNetLib.Utils.InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        </member>
        <member name="M:LiteNetLib.Utils.NetPacketProcessor.RemoveSubscription``1">
            <summary>
            Remove any subscriptions by type
            </summary>
            <typeparam name="T">Packet type</typeparam>
            <returns>true if remove is success</returns>
        </member>
        <member name="M:LiteNetLib.Utils.NetSerializer.RegisterNestedType``1">
            <summary>
            Register nested property type
            </summary>
            <typeparam name="T">INetSerializable structure</typeparam>
            <returns>True - if register successful, false - if type already registered</returns>
        </member>
        <member name="M:LiteNetLib.Utils.NetSerializer.RegisterNestedType``1(System.Func{``0})">
            <summary>
            Register nested property type
            </summary>
            <typeparam name="T">INetSerializable class</typeparam>
            <returns>True - if register successful, false - if type already registered</returns>
        </member>
        <member name="M:LiteNetLib.Utils.NetSerializer.RegisterNestedType``1(System.Action{LiteNetLib.Utils.NetDataWriter,``0},System.Func{LiteNetLib.Utils.NetDataReader,``0})">
            <summary>
            Register nested property type
            </summary>
            <param name="writeDelegate"></param>
            <param name="readDelegate"></param>
            <returns>True - if register successful, false - if type already registered</returns>
        </member>
        <member name="M:LiteNetLib.Utils.NetSerializer.Register``1">
            <exception cref="T:LiteNetLib.Utils.InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        </member>
        <member name="M:LiteNetLib.Utils.NetSerializer.Deserialize``1(LiteNetLib.Utils.NetDataReader)">
            <summary>
            Reads packet with known type
            </summary>
            <param name="reader">NetDataReader with packet</param>
            <returns>Returns packet if packet in reader is matched type</returns>
            <exception cref="T:LiteNetLib.Utils.InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        </member>
        <member name="M:LiteNetLib.Utils.NetSerializer.Deserialize``1(LiteNetLib.Utils.NetDataReader,``0)">
            <summary>
            Reads packet with known type (non alloc variant)
            </summary>
            <param name="reader">NetDataReader with packet</param>
            <param name="target">Deserialization target</param>
            <returns>Returns true if packet in reader is matched type</returns>
            <exception cref="T:LiteNetLib.Utils.InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        </member>
        <member name="M:LiteNetLib.Utils.NetSerializer.Serialize``1(LiteNetLib.Utils.NetDataWriter,``0)">
            <summary>
            Serialize struct to NetDataWriter (fast)
            </summary>
            <param name="writer">Serialization target NetDataWriter</param>
            <param name="obj">Object to serialize</param>
            <exception cref="T:LiteNetLib.Utils.InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        </member>
        <member name="M:LiteNetLib.Utils.NetSerializer.Serialize``1(``0)">
            <summary>
            Serialize struct to byte array
            </summary>
            <param name="obj">Object to serialize</param>
            <returns>byte array with serialized data</returns>
        </member>
        <member name="T:LiteNetLib.UnconnectedMessageType">
            <summary>
            Type of message that you receive in OnNetworkReceiveUnconnected event
            </summary>
        </member>
        <member name="T:LiteNetLib.DisconnectReason">
            <summary>
            Disconnect reason that you receive in OnPeerDisconnected event
            </summary>
        </member>
        <member name="T:LiteNetLib.DisconnectInfo">
            <summary>
            Additional information about disconnection
            </summary>
        </member>
        <member name="F:LiteNetLib.DisconnectInfo.Reason">
            <summary>
            Additional info why peer disconnected
            </summary>
        </member>
        <member name="F:LiteNetLib.DisconnectInfo.SocketErrorCode">
            <summary>
            Error code (if reason is SocketSendError or SocketReceiveError)
            </summary>
        </member>
        <member name="F:LiteNetLib.DisconnectInfo.AdditionalData">
            <summary>
            Additional data that can be accessed (only if reason is RemoteConnectionClose)
            </summary>
        </member>
        <member name="M:LiteNetLib.INetEventListener.OnPeerConnected(LiteNetLib.NetPeer)">
            <summary>
            New remote peer connected to host, or client connected to remote host
            </summary>
            <param name="peer">Connected peer object</param>
        </member>
        <member name="M:LiteNetLib.INetEventListener.OnPeerDisconnected(LiteNetLib.NetPeer,LiteNetLib.DisconnectInfo)">
            <summary>
            Peer disconnected
            </summary>
            <param name="peer">disconnected peer</param>
            <param name="disconnectInfo">additional info about reason, errorCode or data received with disconnect message</param>
        </member>
        <member name="M:LiteNetLib.INetEventListener.OnNetworkError(System.Net.IPEndPoint,System.Net.Sockets.SocketError)">
            <summary>
            Network error (on send or receive)
            </summary>
            <param name="endPoint">From endPoint (can be null)</param>
            <param name="socketError">Socket error</param>
        </member>
        <member name="M:LiteNetLib.INetEventListener.OnNetworkReceive(LiteNetLib.NetPeer,LiteNetLib.NetPacketReader,LiteNetLib.DeliveryMethod)">
            <summary>
            Received some data
            </summary>
            <param name="peer">From peer</param>
            <param name="reader">DataReader containing all received data</param>
            <param name="deliveryMethod">Type of received packet</param>
        </member>
        <member name="M:LiteNetLib.INetEventListener.OnNetworkReceiveUnconnected(System.Net.IPEndPoint,LiteNetLib.NetPacketReader,LiteNetLib.UnconnectedMessageType)">
            <summary>
            Received unconnected message
            </summary>
            <param name="remoteEndPoint">From address (IP and Port)</param>
            <param name="reader">Message data</param>
            <param name="messageType">Message type (simple, discovery request or responce)</param>
        </member>
        <member name="M:LiteNetLib.INetEventListener.OnNetworkLatencyUpdate(LiteNetLib.NetPeer,System.Int32)">
            <summary>
            Latency information updated
            </summary>
            <param name="peer">Peer with updated latency</param>
            <param name="latency">latency value in milliseconds</param>
        </member>
        <member name="M:LiteNetLib.INetEventListener.OnConnectionRequest(LiteNetLib.ConnectionRequest)">
            <summary>
            On peer connection requested
            </summary>
            <param name="request">Request information (EndPoint, internal id, additional data)</param>
        </member>
        <member name="T:LiteNetLib.NatPunchModule">
            <summary>
            Module for UDP NAT Hole punching operations. Can be accessed from NetManager
            </summary>
        </member>
        <member name="T:LiteNetLib.DeliveryMethod">
            <summary>
            Sending method type
            </summary>
        </member>
        <member name="F:LiteNetLib.DeliveryMethod.Unreliable">
            <summary>
            Unreliable. Packets can be dropped, duplicated or arrive without order
            </summary>
        </member>
        <member name="F:LiteNetLib.DeliveryMethod.ReliableUnordered">
            <summary>
            Reliable. All packets will be sent and received, but without order
            </summary>
        </member>
        <member name="F:LiteNetLib.DeliveryMethod.Sequenced">
            <summary>
            Unreliable. Packets can be dropped, but never duplicated and arrive in order
            </summary>
        </member>
        <member name="F:LiteNetLib.DeliveryMethod.ReliableOrdered">
            <summary>
            Reliable and ordered. All packets will be sent and received in order
            </summary>
        </member>
        <member name="F:LiteNetLib.DeliveryMethod.ReliableSequenced">
            <summary>
            Reliable only last packet
            </summary>
        </member>
        <member name="T:LiteNetLib.NetConstants">
            <summary>
            Network constants. Can be tuned from sources for your purposes.
            </summary>
        </member>
        <member name="T:LiteNetLib.INetLogger">
            <summary>
            Interface to implement for your own logger
            </summary>
        </member>
        <member name="T:LiteNetLib.NetDebug">
            <summary>
            Static class for defining your own LiteNetLib logger instead of Console.WriteLine
            or Debug.Log if compiled with UNITY flag
            </summary>
        </member>
        <member name="T:LiteNetLib.NetManager">
            <summary>
            Main class for all network operations. Can be used as client and/or server.
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.UnconnectedMessagesEnabled">
            <summary>
            Enable messages receiving without connection. (with SendUnconnectedMessage method)
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.NatPunchEnabled">
            <summary>
            Enable nat punch messages
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.UpdateTime">
            <summary>
            Library logic update and send period in milliseconds
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.PingInterval">
            <summary>
            Interval for latency detection and checking connection
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.DisconnectTimeout">
            <summary>
            If NetManager doesn't receive any packet from remote peer during this time then connection will be closed
            (including library internal keepalive packets)
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.SimulatePacketLoss">
            <summary>
            Simulate packet loss by dropping random amout of packets. (Works only in DEBUG mode)
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.SimulateLatency">
            <summary>
            Simulate latency by holding packets for random time. (Works only in DEBUG mode)
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.SimulationPacketLossChance">
            <summary>
            Chance of packet loss when simulation enabled. value in percents (1 - 100).
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.SimulationMinLatency">
            <summary>
            Minimum simulated latency
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.SimulationMaxLatency">
            <summary>
            Maximum simulated latency
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.UnsyncedEvents">
            <summary>
            Experimental feature. Events automatically will be called without PollEvents method from another thread
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.DiscoveryEnabled">
            <summary>
            Allows receive DiscoveryRequests
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.MergeEnabled">
            <summary>
            Merge small packets into one before sending to reduce outgoing packets count. (May increase a bit outgoing data size)
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.ReconnectDelay">
            <summary>
            Delay betwen initial connection attempts
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.MaxConnectAttempts">
            <summary>
            Maximum connection attempts before client stops and call disconnect event.
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.ReuseAddress">
            <summary>
            Enables socket option "ReuseAddress" for specific purposes
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.Statistics">
            <summary>
            Statistics of all connections
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.NatPunchModule">
            <summary>
            NatPunchModule for NAT hole punching operations
            </summary>
        </member>
        <member name="P:LiteNetLib.NetManager.IsRunning">
            <summary>
            Returns true if socket listening and update thread is running
            </summary>
        </member>
        <member name="P:LiteNetLib.NetManager.LocalPort">
            <summary>
            Local EndPoint (host and port)
            </summary>
        </member>
        <member name="F:LiteNetLib.NetManager.AutoRecycle">
            <summary>
            Automatically recycle NetPacketReader after OnReceive event
            </summary>
        </member>
        <member name="P:LiteNetLib.NetManager.FirstPeer">
            <summary>
            First peer. Useful for Client mode
            </summary>
            <returns></returns>
        </member>
        <member name="P:LiteNetLib.NetManager.PeersCount">
            <summary>
            Returns connected peers count
            </summary>
        </member>
        <member name="M:LiteNetLib.NetManager.#ctor(LiteNetLib.INetEventListener)">
            <summary>
            NetManager constructor
            </summary>
            <param name="listener">Network events listener</param>
        </member>
        <member name="M:LiteNetLib.NetManager.SendToAll(LiteNetLib.Utils.NetDataWriter,LiteNetLib.DeliveryMethod)">
            <summary>
            Send data to all connected peers
            </summary>
            <param name="writer">DataWriter with data</param>
            <param name="options">Send options (reliable, unreliable, etc.)</param>
        </member>
        <member name="M:LiteNetLib.NetManager.SendToAll(System.Byte[],LiteNetLib.DeliveryMethod)">
            <summary>
            Send data to all connected peers
            </summary>
            <param name="data">Data</param>
            <param name="options">Send options (reliable, unreliable, etc.)</param>
        </member>
        <member name="M:LiteNetLib.NetManager.SendToAll(System.Byte[],System.Int32,System.Int32,LiteNetLib.DeliveryMethod)">
            <summary>
            Send data to all connected peers
            </summary>
            <param name="data">Data</param>
            <param name="start">Start of data</param>
            <param name="length">Length of data</param>
            <param name="options">Send options (reliable, unreliable, etc.)</param>
        </member>
        <member name="M:LiteNetLib.NetManager.SendToAll(LiteNetLib.Utils.NetDataWriter,LiteNetLib.DeliveryMethod,LiteNetLib.NetPeer)">
            <summary>
            Send data to all connected peers
            </summary>
            <param name="writer">DataWriter with data</param>
            <param name="options">Send options (reliable, unreliable, etc.)</param>
            <param name="excludePeer">Excluded peer</param>
        </member>
        <member name="M:LiteNetLib.NetManager.SendToAll(System.Byte[],LiteNetLib.DeliveryMethod,LiteNetLib.NetPeer)">
            <summary>
            Send data to all connected peers
            </summary>
            <param name="data">Data</param>
            <param name="options">Send options (reliable, unreliable, etc.)</param>
            <param name="excludePeer">Excluded peer</param>
        </member>
        <member name="M:LiteNetLib.NetManager.SendToAll(System.Byte[],System.Int32,System.Int32,LiteNetLib.DeliveryMethod,LiteNetLib.NetPeer)">
            <summary>
            Send data to all connected peers
            </summary>
            <param name="data">Data</param>
            <param name="start">Start of data</param>
            <param name="length">Length of data</param>
            <param name="options">Send options (reliable, unreliable, etc.)</param>
            <param name="excludePeer">Excluded peer</param>
        </member>
        <member name="M:LiteNetLib.NetManager.Start">
            <summary>
            Start logic thread and listening on available port
            </summary>
        </member>
        <member name="M:LiteNetLib.NetManager.Start(System.Net.IPAddress,System.Net.IPAddress,System.Int32)">
            <summary>
            Start logic thread and listening on selected port
            </summary>
            <param name="addressIPv4">bind to specific ipv4 address</param>
            <param name="addressIPv6">bind to specific ipv6 address</param>
            <param name="port">port to listen</param>
        </member>
        <member name="M:LiteNetLib.NetManager.Start(System.String,System.String,System.Int32)">
            <summary>
            Start logic thread and listening on selected port
            </summary>
            <param name="addressIPv4">bind to specific ipv4 address</param>
            <param name="addressIPv6">bind to specific ipv6 address</param>
            <param name="port">port to listen</param>
        </member>
        <member name="M:LiteNetLib.NetManager.Start(System.Int32)">
            <summary>
            Start logic thread and listening on selected port
            </summary>
            <param name="port">port to listen</param>
        </member>
        <member name="M:LiteNetLib.NetManager.SendUnconnectedMessage(System.Byte[],System.Net.IPEndPoint)">
            <summary>
            Send message without connection
            </summary>
            <param name="message">Raw data</param>
            <param name="remoteEndPoint">Packet destination</param>
            <returns>Operation result</returns>
        </member>
        <member name="M:LiteNetLib.NetManager.SendUnconnectedMessage(LiteNetLib.Utils.NetDataWriter,System.Net.IPEndPoint)">
            <summary>
            Send message without connection
            </summary>
            <param name="writer">Data serializer</param>
            <param name="remoteEndPoint">Packet destination</param>
            <returns>Operation result</returns>
        </member>
        <member name="M:LiteNetLib.NetManager.SendUnconnectedMessage(System.Byte[],System.Int32,System.Int32,System.Net.IPEndPoint)">
            <summary>
            Send message without connection
            </summary>
            <param name="message">Raw data</param>
            <param name="start">data start</param>
            <param name="length">data length</param>
            <param name="remoteEndPoint">Packet destination</param>
            <returns>Operation result</returns>
        </member>
        <member name="M:LiteNetLib.NetManager.Flush">
            <summary>
            Flush all queued packets of all peers
            </summary>
        </member>
        <member name="M:LiteNetLib.NetManager.PollEvents">
            <summary>
            Receive all pending events. Call this in game update code
            </summary>
        </member>
        <member name="M:LiteNetLib.NetManager.Connect(System.String,System.Int32,System.String)">
            <summary>
            Connect to remote host
            </summary>
            <param name="address">Server IP or hostname</param>
            <param name="port">Server Port</param>
            <param name="key">Connection key</param>
            <returns>New NetPeer if new connection, Old NetPeer if already connected</returns>
            <exception cref="T:System.InvalidOperationException">Manager is not running. Call <see cref="M:LiteNetLib.NetManager.Start"/></exception>
        </member>
        <member name="M:LiteNetLib.NetManager.Connect(System.String,System.Int32,LiteNetLib.Utils.NetDataWriter)">
            <summary>
            Connect to remote host
            </summary>
            <param name="address">Server IP or hostname</param>
            <param name="port">Server Port</param>
            <param name="connectionData">Additional data for remote peer</param>
            <returns>New NetPeer if new connection, Old NetPeer if already connected</returns>
            <exception cref="T:System.InvalidOperationException">Manager is not running. Call <see cref="M:LiteNetLib.NetManager.Start"/></exception>
        </member>
        <member name="M:LiteNetLib.NetManager.Connect(System.Net.IPEndPoint,System.String)">
            <summary>
            Connect to remote host
            </summary>
            <param name="target">Server end point (ip and port)</param>
            <param name="key">Connection key</param>
            <returns>New NetPeer if new connection, Old NetPeer if already connected</returns>
            <exception cref="T:System.InvalidOperationException">Manager is not running. Call <see cref="M:LiteNetLib.NetManager.Start"/></exception>
        </member>
        <member name="M:LiteNetLib.NetManager.Connect(System.Net.IPEndPoint,LiteNetLib.Utils.NetDataWriter)">
            <summary>
            Connect to remote host
            </summary>
            <param name="target">Server end point (ip and port)</param>
            <param name="connectionData">Additional data for remote peer</param>
            <returns>New NetPeer if new connection, Old NetPeer if already connected</returns>
            <exception cref="T:System.InvalidOperationException">Manager is not running. Call <see cref="M:LiteNetLib.NetManager.Start"/></exception>
        </member>
        <member name="M:LiteNetLib.NetManager.Stop">
            <summary>
            Force closes connection and stop all threads.
            </summary>
        </member>
        <member name="M:LiteNetLib.NetManager.Stop(System.Boolean)">
            <summary>
            Force closes connection and stop all threads.
            </summary>
            <param name="sendDisconnectMessages">Send disconnect messages</param>
        </member>
        <member name="M:LiteNetLib.NetManager.GetPeers">
            <summary>
            Get copy of current connected peers (slow! use GetPeersNonAlloc for best performance)
            </summary>
            <returns>Array with connected peers</returns>
        </member>
        <member name="M:LiteNetLib.NetManager.GetPeers(LiteNetLib.ConnectionState)">
            <summary>
            Get copy of current connected peers (slow! use GetPeersNonAlloc for best performance)
            </summary>
            <returns>Array with connected peers</returns>
        </member>
        <member name="M:LiteNetLib.NetManager.GetPeersNonAlloc(System.Collections.Generic.List{LiteNetLib.NetPeer},LiteNetLib.ConnectionState)">
            <summary>
            Get copy of peers (without allocations)
            </summary>
            <param name="peers">List that will contain result</param>
            <param name="peerState">State of peers</param>
        </member>
        <member name="M:LiteNetLib.NetManager.DisconnectPeerForce(LiteNetLib.NetPeer)">
            <summary>
            Immediately disconnect peer from server without additional data
            </summary>
            <param name="peer">peer to disconnect</param>
        </member>
        <member name="M:LiteNetLib.NetManager.DisconnectPeer(LiteNetLib.NetPeer)">
            <summary>
            Disconnect peer from server
            </summary>
            <param name="peer">peer to disconnect</param>
        </member>
        <member name="M:LiteNetLib.NetManager.DisconnectPeer(LiteNetLib.NetPeer,System.Byte[])">
            <summary>
            Disconnect peer from server and send additional data (Size must be less or equal MTU - 8)
            </summary>
            <param name="peer">peer to disconnect</param>
            <param name="data">additional data</param>
        </member>
        <member name="M:LiteNetLib.NetManager.DisconnectPeer(LiteNetLib.NetPeer,LiteNetLib.Utils.NetDataWriter)">
            <summary>
            Disconnect peer from server and send additional data (Size must be less or equal MTU - 8)
            </summary>
            <param name="peer">peer to disconnect</param>
            <param name="writer">additional data</param>
        </member>
        <member name="M:LiteNetLib.NetManager.DisconnectPeer(LiteNetLib.NetPeer,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Disconnect peer from server and send additional data (Size must be less or equal MTU - 8)
            </summary>
            <param name="peer">peer to disconnect</param>
            <param name="data">additional data</param>
            <param name="start">data start</param>
            <param name="count">data length</param>
        </member>
        <member name="T:LiteNetLib.ConnectionState">
            <summary>
            Peer connection state
            </summary>
        </member>
        <member name="T:LiteNetLib.NetPeer">
            <summary>
            Network peer. Main purpose is sending messages to specific peer.
            </summary>
        </member>
        <member name="P:LiteNetLib.NetPeer.ConnectionState">
            <summary>
            Current connection state
            </summary>
        </member>
        <member name="P:LiteNetLib.NetPeer.ConnectTime">
            <summary>
            Connection time for internal purposes
            </summary>
        </member>
        <member name="F:LiteNetLib.NetPeer.Id">
            <summary>
            Peer id can be used as key in your dictionary of peers
            </summary>
        </member>
        <member name="P:LiteNetLib.NetPeer.EndPoint">
            <summary>
            Peer ip address and port
            </summary>
        </member>
        <member name="P:LiteNetLib.NetPeer.Ping">
            <summary>
            Current ping in milliseconds
            </summary>
        </member>
        <member name="P:LiteNetLib.NetPeer.Mtu">
            <summary>
            Current MTU - Maximum Transfer Unit ( maximum udp packet size without fragmentation )
            </summary>
        </member>
        <member name="P:LiteNetLib.NetPeer.RemoteTimeDelta">
            <summary>
            Delta with remote time in ticks (not accurate)
            positive - remote time > our time
            </summary>
        </member>
        <member name="P:LiteNetLib.NetPeer.RemoteUtcTime">
            <summary>
            Remote UTC time (not accurate)
            </summary>
        </member>
        <member name="P:LiteNetLib.NetPeer.TimeSinceLastPacket">
            <summary>
            Time since last packet received (including internal library packets)
            </summary>
        </member>
        <member name="P:LiteNetLib.NetPeer.NetManager">
            <summary>
            Peer parent NetManager
            </summary>
        </member>
        <member name="F:LiteNetLib.NetPeer.Tag">
            <summary>
            Application defined object containing data about the connection
            </summary>
        </member>
        <member name="F:LiteNetLib.NetPeer.Statistics">
            <summary>
            Statistics of peer connection
            </summary>
        </member>
        <member name="M:LiteNetLib.NetPeer.GetMaxSinglePacketSize(LiteNetLib.DeliveryMethod)">
            <summary>
            Gets maximum size of packet that will be not fragmented.
            </summary>
            <param name="options">Type of packet that you want send</param>
            <returns>size in bytes</returns>
        </member>
        <member name="M:LiteNetLib.NetPeer.Send(System.Byte[],LiteNetLib.DeliveryMethod)">
            <summary>
            Send data to peer
            </summary>
            <param name="data">Data</param>
            <param name="options">Send options (reliable, unreliable, etc.)</param>
            <exception cref="T:LiteNetLib.TooBigPacketException">
                If size exceeds maximum limit:<para/>
                MTU - headerSize bytes for Unreliable<para/>
                Fragment count exceeded ushort.MaxValue<para/>
            </exception>
        </member>
        <member name="M:LiteNetLib.NetPeer.Send(LiteNetLib.Utils.NetDataWriter,LiteNetLib.DeliveryMethod)">
            <summary>
            Send data to peer
            </summary>
            <param name="dataWriter">DataWriter with data</param>
            <param name="options">Send options (reliable, unreliable, etc.)</param>
            <exception cref="T:LiteNetLib.TooBigPacketException">
                If size exceeds maximum limit:<para/>
                MTU - headerSize bytes for Unreliable<para/>
                Fragment count exceeded ushort.MaxValue<para/>
            </exception>
        </member>
        <member name="M:LiteNetLib.NetPeer.Send(System.Byte[],System.Int32,System.Int32,LiteNetLib.DeliveryMethod)">
            <summary>
            Send data to peer
            </summary>
            <param name="data">Data</param>
            <param name="start">Start of data</param>
            <param name="length">Length of data</param>
            <param name="options">Send options (reliable, unreliable, etc.)</param>
            <exception cref="T:LiteNetLib.TooBigPacketException">
                If size exceeds maximum limit:<para/>
                MTU - headerSize bytes for Unreliable<para/>
                Fragment count exceeded ushort.MaxValue<para/>
            </exception>
        </member>
        <member name="M:LiteNetLib.NetPeer.Flush">
            <summary>
            Flush all queued packets
            </summary>
        </member>
        <member name="T:LiteNetLib.LocalAddrType">
            <summary>
            Address type that you want to receive from NetUtils.GetLocalIp method
            </summary>
        </member>
        <member name="T:LiteNetLib.NetUtils">
            <summary>
            Some specific network utilities
            </summary>
        </member>
        <member name="M:LiteNetLib.NetUtils.GetLocalIpList(LiteNetLib.LocalAddrType)">
            <summary>
            Get all local ip addresses
            </summary>
            <param name="addrType">type of address (IPv4, IPv6 or both)</param>
            <returns>List with all local ip adresses</returns>
        </member>
        <member name="M:LiteNetLib.NetUtils.GetLocalIpList(System.Collections.Generic.List{System.String},LiteNetLib.LocalAddrType)">
            <summary>
            Get all local ip addresses (non alloc version)
            </summary>
            <param name="targetList">result list</param>
            <param name="addrType">type of address (IPv4, IPv6 or both)</param>
        </member>
        <member name="M:LiteNetLib.NetUtils.GetLocalIp(LiteNetLib.LocalAddrType)">
            <summary>
            Get first detected local ip address
            </summary>
            <param name="addrType">type of address (IPv4, IPv6 or both)</param>
            <returns>IP address if available. Else - string.Empty</returns>
        </member>
        <member name="T:LiteNetLib.Ntp.NtpPacket">
            <summary>
            Represents RFC4330 SNTP packet used for communication to and from a network time server.
            </summary>
            <remarks>
            <para>
            Most applications should just use the <see cref="P:LiteNetLib.Ntp.NtpPacket.CorrectionOffset" /> property.
            </para>
            <para>
            The same data structure represents both request and reply packets.
            Request and reply differ in which properties are set and to what values.
            </para>
            <para>
            The only real property is <see cref="P:LiteNetLib.Ntp.NtpPacket.Bytes" />.
            All other properties read from and write to the underlying byte array
            with the exception of <see cref="P:LiteNetLib.Ntp.NtpPacket.DestinationTimestamp" />,
            which is not part of the packet on network and it is instead set locally after receiving the packet.
            </para>
            <para>
            Copied from <a href="https://guerrillantp.machinezoo.com/">GuerrillaNtp project</a>
            with permission from Robert Vazan (@robertvazan) under MIT license, see https://github.com/RevenantX/LiteNetLib/pull/236
            </para>
            </remarks>
        </member>
        <member name="P:LiteNetLib.Ntp.NtpPacket.Bytes">
            <summary>
            Gets RFC4330-encoded SNTP packet.
            </summary>
            <value>
            Byte array containing RFC4330-encoded SNTP packet. It is at least 48 bytes long.
            </value>
            <remarks>
            This is the only real property. All other properties except
            <see cref="P:LiteNetLib.Ntp.NtpPacket.DestinationTimestamp" /> read from or write to this byte array.
            </remarks>
        </member>
        <member name="P:LiteNetLib.Ntp.NtpPacket.LeapIndicator">
            <summary>
            Gets the leap second indicator.
            </summary>
            <value>
            Leap second warning, if any. Special value
            <see cref="F:LiteNetLib.Ntp.NtpLeapIndicator.AlarmCondition" /> indicates unsynchronized server clock.
            Default is <see cref="F:LiteNetLib.Ntp.NtpLeapIndicator.NoWarning" />.
            </value>
            <remarks>
            Only servers fill in this property. Clients can consult this property for possible leap second warning.
            </remarks>
        </member>
        <member name="P:LiteNetLib.Ntp.NtpPacket.VersionNumber">
            <summary>
            Gets or sets protocol version number.
            </summary>
            <value>
            SNTP protocol version. Default is 4, which is the latest version at the time of this writing.
            </value>
            <remarks>
            In request packets, clients should leave this property at default value 4.
            Servers usually reply with the same protocol version.
            </remarks>
        </member>
        <member name="P:LiteNetLib.Ntp.NtpPacket.Mode">
            <summary>
            Gets or sets SNTP packet mode, i.e. whether this is client or server packet.
            </summary>
            <value>
            SNTP packet mode. Default is <see cref="F:LiteNetLib.Ntp.NtpMode.Client" /> in newly created packets.
            Server reply should have this property set to <see cref="F:LiteNetLib.Ntp.NtpMode.Server" />.
            </value>
        </member>
        <member name="P:LiteNetLib.Ntp.NtpPacket.Stratum">
            <summary>
            Gets server's distance from the reference clock.
            </summary>
            <value>
            <para>
            Distance from the reference clock. This property is set only in server reply packets.
            Servers connected directly to reference clock hardware set this property to 1.
            Statum number is incremented by 1 on every hop down the NTP server hierarchy.
            </para>
            <para>
            Special value 0 indicates that this packet is a Kiss-o'-Death message
            with kiss code stored in <see cref="P:LiteNetLib.Ntp.NtpPacket.ReferenceId" />.
            </para>
            </value>
        </member>
        <member name="P:LiteNetLib.Ntp.NtpPacket.Poll">
            <summary>
            Gets server's preferred polling interval.
            </summary>
            <value>
            Polling interval in log2 seconds, e.g. 4 stands for 16s and 17 means 131,072s.
            </value>
        </member>
        <member name="P:LiteNetLib.Ntp.NtpPacket.Precision">
            <summary>
            Gets the precision of server clock.
            </summary>
            <value>
            Clock precision in log2 seconds, e.g. -20 for microsecond precision.
            </value>
        </member>
        <member name="P:LiteNetLib.Ntp.NtpPacket.RootDelay">
            <summary>
            Gets the total round-trip delay from the server to the reference clock.
            </summary>
            <value>
            Round-trip delay to the reference clock. Normally a positive value smaller than one second.
            </value>
        </member>
        <member name="P:LiteNetLib.Ntp.NtpPacket.RootDispersion">
            <summary>
            Gets the estimated error in time reported by the server.
            </summary>
            <value>
            Estimated error in time reported by the server. Normally a positive value smaller than one second.
            </value>
        </member>
        <member name="P:LiteNetLib.Ntp.NtpPacket.ReferenceId">
            <summary>
            Gets the ID of the time source used by the server or Kiss-o'-Death code sent by the server.
            </summary>
            <value>
            <para>
            ID of server's time source or Kiss-o'-Death code.
            Purpose of this property depends on value of <see cref="P:LiteNetLib.Ntp.NtpPacket.Stratum" /> property.
            </para>
            <para>
            Stratum 1 servers write here one of several special values that describe the kind of hardware clock they use.
            </para>
            <para>
            Stratum 2 and lower servers set this property to IPv4 address of their upstream server.
            If upstream server has IPv6 address, the address is hashed, because it doesn't fit in this property.
            </para>
            <para>
            When server sets <see cref="P:LiteNetLib.Ntp.NtpPacket.Stratum" /> to special value 0,
            this property contains so called kiss code that instructs the client to stop querying the server.
            </para>
            </value>
        </member>
        <member name="P:LiteNetLib.Ntp.NtpPacket.ReferenceTimestamp">
            <summary>
            Gets or sets the time when the server clock was last set or corrected.
            </summary>
            <value>
            Time when the server clock was last set or corrected or <c>null</c> when not specified.
            </value>
            <remarks>
            This Property is usually set only by servers. It usually lags server's current time by several minutes,
            so don't use this property for time synchronization.
            </remarks>
        </member>
        <member name="P:LiteNetLib.Ntp.NtpPacket.OriginTimestamp">
            <summary>
            Gets or sets the time when the client sent its request.
            </summary>
            <value>
            This property is <c>null</c> in request packets.
            In reply packets, it is the time when the client sent its request.
            Servers copy this value from <see cref="P:LiteNetLib.Ntp.NtpPacket.TransmitTimestamp" />
            that they find in received request packet.
            </value>
            <seealso cref="P:LiteNetLib.Ntp.NtpPacket.CorrectionOffset" />
            <seealso cref="P:LiteNetLib.Ntp.NtpPacket.RoundTripTime" />
        </member>
        <member name="P:LiteNetLib.Ntp.NtpPacket.ReceiveTimestamp">
            <summary>
            Gets or sets the time when the request was received by the server.
            </summary>
            <value>
            This property is <c>null</c> in request packets.
            In reply packets, it is the time when the server received client request.
            </value>
            <seealso cref="P:LiteNetLib.Ntp.NtpPacket.CorrectionOffset" />
            <seealso cref="P:LiteNetLib.Ntp.NtpPacket.RoundTripTime" />
        </member>
        <member name="P:LiteNetLib.Ntp.NtpPacket.TransmitTimestamp">
            <summary>
            Gets or sets the time when the packet was sent.
            </summary>
            <value>
            Time when the packet was sent. It should never be <c>null</c>.
            Default value is <see cref="P:System.DateTime.UtcNow" />.
            </value>
            <remarks>
            This property must be set by both clients and servers.
            </remarks>
            <seealso cref="P:LiteNetLib.Ntp.NtpPacket.CorrectionOffset" />
            <seealso cref="P:LiteNetLib.Ntp.NtpPacket.RoundTripTime" />
        </member>
        <member name="P:LiteNetLib.Ntp.NtpPacket.DestinationTimestamp">
            <summary>
            Gets or sets the time of reception of response SNTP packet on the client.
            </summary>
            <value>
            Time of reception of response SNTP packet on the client. It is <c>null</c> in request packets.
            </value>
            <remarks>
            This property is not part of the protocol and has to be set when reply packet is received.
            </remarks>
            <seealso cref="P:LiteNetLib.Ntp.NtpPacket.CorrectionOffset" />
            <seealso cref="P:LiteNetLib.Ntp.NtpPacket.RoundTripTime" />
        </member>
        <member name="P:LiteNetLib.Ntp.NtpPacket.RoundTripTime">
            <summary>
            Gets the round-trip time to the server.
            </summary>
            <value>
            Time the request spent travelling to the server plus the time the reply spent travelling back.
            This is calculated from timestamps in the packet as <c>(t1 - t0) + (t3 - t2)</c>
            where t0 is <see cref="P:LiteNetLib.Ntp.NtpPacket.OriginTimestamp" />,
            t1 is <see cref="P:LiteNetLib.Ntp.NtpPacket.ReceiveTimestamp" />,
            t2 is <see cref="P:LiteNetLib.Ntp.NtpPacket.TransmitTimestamp" />,
            and t3 is <see cref="P:LiteNetLib.Ntp.NtpPacket.DestinationTimestamp" />.
            This property throws an exception in request packets.
            </value>
        </member>
        <member name="P:LiteNetLib.Ntp.NtpPacket.CorrectionOffset">
            <summary>
            Gets the offset that should be added to local time to synchronize it with server time.
            </summary>
            <value>
            Time difference between server and client. It should be added to local time to get server time.
            It is calculated from timestamps in the packet as <c>0.5 * ((t1 - t0) - (t3 - t2))</c>
            where t0 is <see cref="P:LiteNetLib.Ntp.NtpPacket.OriginTimestamp" />,
            t1 is <see cref="P:LiteNetLib.Ntp.NtpPacket.ReceiveTimestamp" />,
            t2 is <see cref="P:LiteNetLib.Ntp.NtpPacket.TransmitTimestamp" />,
            and t3 is <see cref="P:LiteNetLib.Ntp.NtpPacket.DestinationTimestamp" />.
            This property throws an exception in request packets.
            </value>
        </member>
        <member name="M:LiteNetLib.Ntp.NtpPacket.#ctor">
            <summary>
            Initializes default request packet.
            </summary>
            <remarks>
            Properties <see cref="P:LiteNetLib.Ntp.NtpPacket.Mode" /> and <see cref="P:LiteNetLib.Ntp.NtpPacket.VersionNumber" />
            are set appropriately for request packet. Property <see cref="P:LiteNetLib.Ntp.NtpPacket.TransmitTimestamp" />
            is set to <see cref="P:System.DateTime.UtcNow" />.
            </remarks>
        </member>
        <member name="M:LiteNetLib.Ntp.NtpPacket.#ctor(System.Byte[])">
            <summary>
            Initializes packet from received data.
            </summary>
        </member>
        <member name="M:LiteNetLib.Ntp.NtpPacket.FromServerResponse(System.Byte[],System.DateTime)">
            <summary>
            Initializes packet from data received from a server.
            </summary>
            <param name="bytes">Data received from the server.</param>
            <param name="destinationTimestamp">Utc time of reception of response SNTP packet on the client.</param>
            <returns></returns>
        </member>
        <member name="T:LiteNetLib.Ntp.NtpLeapIndicator">
            <summary>
            Represents leap second warning from the server that instructs the client to add or remove leap second.
            </summary>
            <seealso cref="P:LiteNetLib.Ntp.NtpPacket.LeapIndicator" />
        </member>
        <member name="F:LiteNetLib.Ntp.NtpLeapIndicator.NoWarning">
            <summary>
            No leap second warning. No action required.
            </summary>
        </member>
        <member name="F:LiteNetLib.Ntp.NtpLeapIndicator.LastMinuteHas61Seconds">
            <summary>
            Warns the client that the last minute of the current day has 61 seconds.
            </summary>
        </member>
        <member name="F:LiteNetLib.Ntp.NtpLeapIndicator.LastMinuteHas59Seconds">
            <summary>
            Warns the client that the last minute of the current day has 59 seconds.
            </summary>
        </member>
        <member name="F:LiteNetLib.Ntp.NtpLeapIndicator.AlarmCondition">
            <summary>
            Special value indicating that the server clock is unsynchronized and the returned time is unreliable.
            </summary>
        </member>
        <member name="T:LiteNetLib.Ntp.NtpMode">
            <summary>
            Describes SNTP packet mode, i.e. client or server.
            </summary>
            <seealso cref="P:LiteNetLib.Ntp.NtpPacket.Mode" />
        </member>
        <member name="F:LiteNetLib.Ntp.NtpMode.Client">
            <summary>
            Identifies client-to-server SNTP packet.
            </summary>
        </member>
        <member name="F:LiteNetLib.Ntp.NtpMode.Server">
            <summary>
            Identifies server-to-client SNTP packet.
            </summary>
        </member>
        <member name="T:LiteNetLib.Ntp.NtpRequest">
            <summary>
            Make NTP request.
            <para>
            1. Create the object by <see cref="M:LiteNetLib.Ntp.NtpRequest.Create(System.Net.IPEndPoint,System.Action{LiteNetLib.Ntp.NtpPacket})"/> method. 
            </para>
            <para>
            2. Use <see cref="M:LiteNetLib.Ntp.NtpRequest.Send"/> method to send requests. 3. Call <see cref="M:LiteNetLib.Ntp.NtpRequest.Close"/> to release the socket
            AFTER you have received the response or some timeout. If you close the socket too early, you may miss the response.
            </para>
            <para>
            3. Call <see cref="M:LiteNetLib.Ntp.NtpRequest.Close"/> to release the socket AFTER you have received the response or some timeout.
            If you close the socket too early, you may miss the response.
            </para>
            </summary>
        </member>
        <member name="M:LiteNetLib.Ntp.NtpRequest.#ctor(System.Net.IPEndPoint,System.Action{LiteNetLib.Ntp.NtpPacket})">
            <summary>
            Initialize object, open socket.
            </summary>
            <param name="onRequestComplete">callback (called from other thread!)</param>
        </member>
        <member name="M:LiteNetLib.Ntp.NtpRequest.Create(System.Net.IPEndPoint,System.Action{LiteNetLib.Ntp.NtpPacket})">
            <summary>
            Create the requests for NTP server, open socket.
            </summary>
            <param name="endPoint">NTP Server address.</param>
            <param name="onRequestComplete">callback (called from other thread!)</param>
        </member>
        <member name="M:LiteNetLib.Ntp.NtpRequest.Create(System.Net.IPAddress,System.Action{LiteNetLib.Ntp.NtpPacket})">
            <summary>
            Create the requests for NTP server (default port), open socket.
            </summary>
            <param name="ipAddress">NTP Server address.</param>
            <param name="onRequestComplete">callback (called from other thread!)</param>
        </member>
        <member name="M:LiteNetLib.Ntp.NtpRequest.Create(System.String,System.Int32,System.Action{LiteNetLib.Ntp.NtpPacket})">
            <summary>
            Create the requests for NTP server, open socket.
            </summary>
            <param name="ntpServerAddress">NTP Server address.</param>
            <param name="port">port</param>
            <param name="onRequestComplete">callback (called from other thread!)</param>
        </member>
        <member name="M:LiteNetLib.Ntp.NtpRequest.Create(System.String,System.Action{LiteNetLib.Ntp.NtpPacket})">
            <summary>
            Create the requests for NTP server (default port), open socket.
            </summary>
            <param name="ntpServerAddress">NTP Server address.</param>
            <param name="onRequestComplete">callback (called from other thread!)</param>
        </member>
        <member name="M:LiteNetLib.Ntp.NtpRequest.Send">
            <summary>
            Send request to the NTP server calls callback (if success).
            In case of error the callbacke is called with null param.
            </summary>
        </member>
        <member name="M:LiteNetLib.Ntp.NtpRequest.Close">
            <summary>
            Close socket.
            </summary>
        </member>
        <member name="M:LiteNetLib.Ntp.NtpRequest.LiteNetLib#INetSocketListener#OnMessageReceived(System.Byte[],System.Int32,System.Net.Sockets.SocketError,System.Net.IPEndPoint)">
            <summary>
            Handle received data: transform bytes to NtpPacket, close socket and call the callback.
            </summary>
        </member>
        <member name="M:Facebook.Audio.BootstrapperBase`1.Init(UnityEngine.GameObject,TBE.RuntimeOptions,TBE.SampleRate,TBE.AudioDeviceType,System.String,System.UInt32)">
            <summary>
            Create and initialize the bootstrapper on a game object in cases where you might not want to use the
            prefab provided with the SDK. This method creates a child game object and marks at as "DontDestroyOnLoad".
            </summary>
            <param name="parentObject"></param>
            <param name="options"></param>
            <param name="sampleRate"></param>
            <param name="deviceType"></param>
            <param name="customDeviceName"></param>
            <param name="maxPhysicalObjects"></param>
        </member>
        <member name="T:Facebook.Audio.FBAudio360Bootstrapper">
            <summary>
            Add to a game object to initialize all the FB Audio managers. This script ensures that the managers
            are created and destroyed in the correct order.
            The object will function as a singleton.
            </summary>
        </member>
        <member name="M:Facebook.Audio.ListExtensions.FastRemoveAt``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Faster remove for when you don't need to keep the list in order.
            </summary>
            <typeparam name="T">The type contained in the list (inferred)</typeparam>
            <param name="list">The list (inferred)</param>
            <param name="index">The index of the element to remove</param>
        </member>
        <member name="T:Facebook.Audio.SPSCQ`1">
            <summary>
            A single producer, single consumer, bounded, lock free queue.
            </summary>
            <typeparam name="T">The data type contained in the queue</typeparam>
        </member>
        <member name="P:Facebook.Audio.SPSCQ`1.Count">
            <summary>
            The number of items in the queue
            </summary>
        </member>
        <member name="M:Facebook.Audio.SPSCQ`1.Push(Facebook.Audio.SPSCQ{`0}.Writer)">
            <summary>
            Add an item to the queue
            </summary>
            <param name="writer">The write function to update the item</param>
            <returns>Whether there was room in the queue</returns>
        </member>
        <member name="M:Facebook.Audio.SPSCQ`1.Pop(Facebook.Audio.SPSCQ{`0}.Reader)">
            <summary>
            Remove an item from the queue
            </summary>
            <param name="reader">The read function to get the item info</param>
            <returns>Whether there were any items left in the queue</returns>
        </member>
        <member name="T:Facebook.Audio.WavSimpleHeader">
            <summary>
            A utility to write a simple wave header to a binary stream.
            Typical usage:
            <code>
            WavSimpleHeader header = new WavSimpleHeader();
            // Start of file
            header.WriteHeader(writer, sampleRate, numOfChannels, numBitsPerSample, WavSimpleHeader.WavFileFormat.FloatPcm);
            // write audio samples to the binary writer..
            // and then once done, update the header with the duration
            header.UpdateDuration(writer);
            </code> 
            </summary>
        </member>
        <member name="M:Facebook.Audio.WavSimpleHeader.WriteHeader(System.IO.BinaryWriter,System.UInt32,System.UInt16,System.UInt16,Facebook.Audio.WavSimpleHeader.WavFileFormat)">
            <summary>
            Write the header information to a stream. Typically called first before any data is written to the stream
            </summary>
            <param name="writer"></param>
            <param name="fileSampleRate"></param>
            <param name="numOfChannels"></param>
            <param name="numBitsPerSample"></param>
            <param name="format"></param>
        </member>
        <member name="M:Facebook.Audio.WavSimpleHeader.UpdateDuration(System.IO.BinaryWriter)">
            <summary>
            Update the duration metadata. Must be called after all audio samples have been written.
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:GazeInputModule.GetIntersectionPosition(UnityEngine.Camera,UnityEngine.EventSystems.RaycastResult)">
             @brief get intersection position in world space
            
        </member>
        <member name="T:GvrActivityHelper">
            <summary>
            Simple static class to abstract out several JNI calls that need to be shared between different
            classes.
            </summary>
        </member>
        <member name="F:GvrActivityHelper.GVR_DLL_NAME">
            <summary>The name of the GVR DLL.</summary>
        </member>
        <member name="F:GvrActivityHelper.GVR_SHIM_DLL_NAME">
            <summary>The name of the GVR Shim DLL.</summary>
        </member>
        <member name="F:GvrActivityHelper.PACKAGE_UNITY_PLAYER">
            @endcond
            <summary>Package name for the Android Unity player class.</summary>
        </member>
        <member name="T:GvrAllEventsTrigger">
            <summary>
            Exposes events from `GvrEventExecutor` that are fired by `GvrPointerInputModule_`to the editor.
            </summary>
            <remarks>Makes it possible to handle `EventSystem` events globally.</remarks>
        </member>
        <member name="F:GvrAllEventsTrigger.OnPointerClick">
            <summary>Event for `OnPointerClick`.</summary>
        </member>
        <member name="F:GvrAllEventsTrigger.OnPointerDown">
            <summary>Event for `OnPointerDown`.</summary>
        </member>
        <member name="F:GvrAllEventsTrigger.OnPointerUp">
            <summary>Event for `OnPointerUp`.</summary>
        </member>
        <member name="F:GvrAllEventsTrigger.OnPointerEnter">
            <summary>Event for `OnPointerEnter`.</summary>
        </member>
        <member name="F:GvrAllEventsTrigger.OnPointerExit">
            <summary>Event for `OnPointerExit`.</summary>
        </member>
        <member name="F:GvrAllEventsTrigger.OnScroll">
            <summary>Event for `OnScroll`.</summary>
        </member>
        <member name="T:GvrAllEventsTrigger.TriggerEvent">
            <summary>Exposes fired `PointerEventData` events.</summary>
        </member>
        <member name="T:GvrArmModel">
            <summary>
            Standard implementation for a mathematical model to make the virtual controller approximate the
            physical location of the Daydream controller.
            </summary>
        </member>
        <member name="F:GvrArmModel.DEFAULT_ELBOW_BEND_RATIO">
            @cond
            <summary>The default elbow bend ratio.</summary>
        </member>
        <member name="F:GvrArmModel.DEFAULT_ELBOW_REST_POSITION">
            @endcond
            @cond
            <summary>The default elbow rest position.</summary>
        </member>
        <member name="F:GvrArmModel.DEFAULT_WRIST_REST_POSITION">
            @endcond
            @cond
            <summary>The default wrist rest position.</summary>
        </member>
        <member name="F:GvrArmModel.DEFAULT_CONTROLLER_REST_POSITION">
            @endcond
            @cond
            <summary>The default controller rest position.</summary>
        </member>
        <member name="F:GvrArmModel.DEFAULT_ARM_EXTENSION_OFFSET">
            @endcond
            @cond
            <summary>The default arm extension offset.</summary>
        </member>
        <member name="F:GvrArmModel.elbowRestPosition">
            @endcond
            <summary>
            Position of the elbow joint relative to the head before the arm model is applied.
            </summary>
        </member>
        <member name="F:GvrArmModel.wristRestPosition">
            <summary>
            Position of the wrist joint relative to the elbow before the arm model is applied.
            </summary>
        </member>
        <member name="F:GvrArmModel.controllerRestPosition">
            <summary>
            Position of the controller joint relative to the wrist before the arm model is applied.
            </summary>
        </member>
        <member name="F:GvrArmModel.armExtensionOffset">
            <summary>
            Offset applied to the elbow position as the controller is rotated upwards.
            </summary>
        </member>
        <member name="F:GvrArmModel.elbowBendRatio">
            <summary>Ratio of the controller's rotation to apply to the rotation of the elbow.</summary>
            <remarks>The remaining rotation is applied to the wrist's rotation.</remarks>
        </member>
        <member name="F:GvrArmModel.fadeControllerOffset">
            <summary>
            Offset in front of the controller to determine what position to use when determing if the
            controller should fade.
            </summary>
            <remarks>This is useful when objects are attached to the controller.</remarks>
        </member>
        <member name="F:GvrArmModel.fadeDistanceFromHeadForward">
            <summary>
            Controller distance from the front/back of the head after which the controller disappears
            (meters).
            </summary>
        </member>
        <member name="F:GvrArmModel.fadeDistanceFromHeadSide">
            <summary>
            Controller distance from the left/right of the head after which the controller disappears
            (meters).
            </summary>
        </member>
        <member name="F:GvrArmModel.tooltipMinDistanceFromFace">
            <summary>Controller distance from face after which the tooltips appear (meters).</summary>
        </member>
        <member name="F:GvrArmModel.tooltipMaxAngleFromCamera">
            <summary>
            The maximum angle in degrees between the controller and head at which to show tooltips.
            </summary>
            <remarks>
            When the angle between the controller and the head is larger than this value, the tooltips
            disappear.  If the value is 180, then the tooltips are always shown.  If the value is 90,
            the tooltips are only shown when they are facing the camera.
            </remarks>
        </member>
        <member name="F:GvrArmModel.isLockedToNeck">
            <summary>
            If `true`, the root of the pose is locked to the local position of the player's neck.
            </summary>
        </member>
        <member name="F:GvrArmModel.EXTENSION_WEIGHT">
            <summary>Increases elbow bending as the controller moves up (unitless).</summary>
        </member>
        <member name="F:GvrArmModel.DELTA_ALPHA">
            <summary>Amount of normalized alpha transparency to change per second.</summary>
        </member>
        <member name="F:GvrArmModel.MIN_EXTENSION_ANGLE">
            <summary>
            Minimum angle in degrees of the controller the for arm extension offset to start.
            </summary>
            <remarks>
            This is the range of controller X-axis values in which the modeled arm rotates with the
            controller, outside of which the modeled arm doesn't rotate with the controller, only the
            controller rotates.  Below this value, the wrist is primarily responsible for controller
            rotation, not the arm.
            </remarks>
        </member>
        <member name="F:GvrArmModel.MAX_EXTENSION_ANGLE">
            <summary>
            Maximum angle in degrees of the controller the for arm extension offset to end.
            </summary>
            <remarks>
            This is the range of controller X-axis values in which the modeled arm rotates with the
            controller, outside of which the modeled arm doesn't rotate with the controller, only the
            controller rotates.  Above this value, the wrist is primarily responsible for controller
            rotation, not the arm.
            </remarks>
        </member>
        <member name="F:GvrArmModel.SHOULDER_POSITION">
            <summary>Rest position for shoulder joint.</summary>
        </member>
        <member name="F:GvrArmModel.NECK_OFFSET">
            <summary>Neck offset used to apply the inverse neck model when locked to the head.</summary>
        </member>
        <member name="F:GvrArmModel.neckPosition">
            <summary>The neck position based on this arm model.</summary>
        </member>
        <member name="F:GvrArmModel.elbowPosition">
            <summary>The elbow position based on this arm model.</summary>
        </member>
        <member name="F:GvrArmModel.elbowRotation">
            <summary>The elbow rotation based on this arm model.</summary>
        </member>
        <member name="F:GvrArmModel.wristPosition">
            <summary>The wrist position based on this arm model.</summary>
        </member>
        <member name="F:GvrArmModel.wristRotation">
            <summary>The wrist rotation based on this arm model.</summary>
        </member>
        <member name="F:GvrArmModel.controllerPosition">
            <summary>The controller position based on this arm model.</summary>
        </member>
        <member name="F:GvrArmModel.controllerRotation">
            <summary>The controller rotation based on this arm model.</summary>
        </member>
        <member name="F:GvrArmModel.preferredAlpha">
            <summary>The preferred alpha.</summary>
        </member>
        <member name="F:GvrArmModel.tooltipAlphaValue">
            <summary>The tooltip alpha value.</summary>
        </member>
        <member name="F:GvrArmModel.handedMultiplier">
            <summary>Multiplier for handedness such that 1 = Right, 0 = Center, -1 = left.</summary>
        </member>
        <member name="F:GvrArmModel.torsoDirection">
            <summary>Forward direction of user's torso.</summary>
        </member>
        <member name="F:GvrArmModel.torsoRotation">
            <summary>Orientation of the user's torso.</summary>
        </member>
        <member name="P:GvrArmModel.ControllerPositionFromHead">
            <inheritdoc/>
        </member>
        <member name="P:GvrArmModel.ControllerRotationFromHead">
            <inheritdoc/>
        </member>
        <member name="P:GvrArmModel.PreferredAlpha">
            <inheritdoc/>
        </member>
        <member name="P:GvrArmModel.TooltipAlphaValue">
            <inheritdoc/>
        </member>
        <member name="P:GvrArmModel.NeckPosition">
            <summary>Gets the neck's position relative to the user's head.</summary>
            <remarks>
            If `isLockedToNeck` is `true`, this will be the input tracking position of the head node
            modified by an inverse neck model to approximate the neck position.  Otherwise, it is always
            zero.
            </remarks>
            <value>The neck position.</value>
        </member>
        <member name="P:GvrArmModel.ShoulderPosition">
            <summary>Gets the shoulder's position relative to the user's head.</summary>
            <remarks>
            This is not actually used as part of the arm model calculations, and exists for debugging.
            </remarks>
            <value>The shoulder position.</value>
        </member>
        <member name="P:GvrArmModel.ShoulderRotation">
            <summary>Gets the shoulder's rotation relative to the user's head.</summary>
            <remarks>
            This is not actually used as part of the arm model calculations, and exists for debugging.
            </remarks>
            <value>The shoulder rotation.</value>
        </member>
        <member name="P:GvrArmModel.ElbowPosition">
            <summary>Gets the elbow's position relative to the user's head.</summary>
            <value>The elbow position.</value>
        </member>
        <member name="P:GvrArmModel.ElbowRotation">
            <summary>Gets the elbow's rotation relative to the user's head.</summary>
            <value>The elbow rotation.</value>
        </member>
        <member name="P:GvrArmModel.WristPosition">
            <summary>Gets the wrist's position relative to the user's head.</summary>
            <value>The wrist position.</value>
        </member>
        <member name="P:GvrArmModel.WristRotation">
            <summary>Gets the wrist's rotation relative to the user's head.</summary>
            <value>The wrist rotation.</value>
        </member>
        <member name="P:GvrArmModel.ControllerInputDevice">
            <summary>Gets or sets the controller input device.</summary>
            <value>The controller input device.</value>
        </member>
        <member name="M:GvrArmModel.OnEnable">
            @cond
            <summary>The `MonoBehavior`'s `OnEnable` method.</summary>
        </member>
        <member name="M:GvrArmModel.OnDisable">
            @endcond
            @cond
            <summary>The `MonoBehavior`'s `OnDisable` method.</summary>
        </member>
        <member name="M:GvrArmModel.OnControllerInputUpdated">
            @endcond
            @cond
            <summary>The `GvrControllerInput`'s `OnControllerInputUpdated` action.</summary>
        </member>
        <member name="M:GvrArmModel.UpdateHandedness">
            @endcond
            <summary>Updates the arm model handedness.</summary>
        </member>
        <member name="M:GvrArmModel.UpdateTorsoDirection(System.Boolean)">
            <summary>Updates the arm model torso direction.</summary>
            <param name="forceImmediate">
            If `true`, uses the gaze direction, otherwise uses slerp to update the direction smoothly.
            </param>
        </member>
        <member name="M:GvrArmModel.UpdateNeckPosition">
            <summary>Updates the neck position in the arm model.</summary>
        </member>
        <member name="M:GvrArmModel.ApplyArmModel">
            <summary>Applies the arm model parameters to update the orientation and position.</summary>
        </member>
        <member name="M:GvrArmModel.SetUntransformedJointPositions">
            <summary>
            Set the starting positions of the joints before they are transformed by the arm model.
            </summary>
        </member>
        <member name="M:GvrArmModel.CalculateExtensionRatio(System.Single)">
            <summary>
            Calculate the extension ratio based on the angle of the controller along the x axis.
            </summary>
            <returns>The extension ratio of the elbow.</returns>
            <param name="xAngle">The X angle of the controller along the x axis.</param>
        </member>
        <member name="M:GvrArmModel.ApplyExtensionOffset(System.Single)">
            <summary>Offset the elbow by the extension offset.</summary>
            <param name="extensionRatio">The extension ratio of the elbow to apply.</param>
        </member>
        <member name="M:GvrArmModel.CalculateLerpRotation(UnityEngine.Quaternion,System.Single)">
            <summary>
            Calculate the lerp rotation, which is used to control how much the rotation of the
            controller impacts each joint.
            </summary>
            <returns>The lerp rotation.</returns>
            <param name="xyRotation">The xy rotation of the controller.</param>
            <param name="extensionRatio">The extension ratio of the elbow.</param>
        </member>
        <member name="M:GvrArmModel.CalculateFinalJointRotations(UnityEngine.Quaternion,UnityEngine.Quaternion,UnityEngine.Quaternion)">
            <summary>Determine the final joint rotations relative to the head.</summary>
            <param name="controllerOrientation">Controller orientation.</param>
            <param name="xyRotation">The xy rotation of the controller.</param>
            <param name="lerpRotation">Lerp rotation.</param>
        </member>
        <member name="M:GvrArmModel.ApplyRotationToJoints">
            <summary>
            Apply the joint rotations to the positions of the joints to determine the final pose.
            </summary>
        </member>
        <member name="M:GvrArmModel.ApplyInverseNeckModel(UnityEngine.Vector3)">
            <summary>Transform the head position into an approximate neck position.</summary>
            <returns>The inverse neck model.</returns>
            <param name="headPosition">Head position.</param>
        </member>
        <member name="M:GvrArmModel.UpdateTransparency">
            <summary>
            Controls the transparency of the controller to prevent the controller from clipping through
            the user's head.
            </summary>
            <remarks>
            Also controls the transparency of the tooltips so they are only visible when the controller
            is held up.
            </remarks>
        </member>
        <member name="M:GvrArmModel.GetControllerRotation(UnityEngine.Quaternion@,UnityEngine.Quaternion@,System.Single@)">
            <summary>Get the controller's orientation.</summary>
            <param name="rotation">The output rotation which will be written to.</param>
            <param name="xyRotation">The output xy-only rotation.</param>
            <param name="xAngle">The output angle from the X axis.</param>
        </member>
        <member name="M:GvrArmModel.OnDrawGizmosSelected">
            <summary>Raises the draw gizmos selected event.</summary>
        </member>
        <member name="T:GvrBaseArmModel">
            <summary>Interface for a mathematical Arm model for 3DoF controllers.</summary>
            <remarks>
            Uses the orientation and location of the physical controller, and predicts the location of the
            controller and pointer to determine where to place the controller model within the scene.
            </remarks>
        </member>
        <member name="P:GvrBaseArmModel.ControllerPositionFromHead">
            <summary>
            Gets a Vector to represent the controller's location relative to the player's head position.
            </summary>
            <value>A Vector to represent the controller's location.</value>
        </member>
        <member name="P:GvrBaseArmModel.ControllerRotationFromHead">
            <summary>
            Gets a Quaternion to represent the controller's rotation relative to the player's head
            position.
            </summary>
            <value>A Quaternion to represent the controller's rotation.</value>
        </member>
        <member name="P:GvrBaseArmModel.PreferredAlpha">
            <summary>Gets the suggested rendering alpha value of the controller.</summary>
            <remarks>
            This is to prevent the controller from intersecting the player's face.
            <para>
            The range is always 0 - 1.
            </para></remarks>
            <value>The suggested rendering alpha value of the controller.</value>
        </member>
        <member name="P:GvrBaseArmModel.TooltipAlphaValue">
            <summary>Gets the suggested rendering alpha value of the controller tooltips.</summary>
            <remarks>
            This is to only display the tooltips when the player is looking at the controller, and also
            to prevent the tooltips from intersecting the player's face.
            </remarks>
            <value>The suggested rendering alpha value of the controller tooltips.</value>
        </member>
        <member name="T:GvrBasePointer">
            <summary>An abstract class for handling pointer based input.</summary>
            <remarks><para>
            This abstract class should be implemented for pointer based input, and used with
            the GvrPointerInputModule script.
            </para><para>
            It provides methods called on pointer interaction with in-game objects and UI,
            trigger events, and 'BaseInputModule' class state changes.
            </para><para>
            To have the methods called, an instance of this (implemented) class must be
            registered with the **GvrPointerManager** script in 'Start' by calling
            GvrPointerInputModule.OnPointerCreated.
            </para><para>
            This abstract class should be implemented by pointers doing 1 of 2 things:
            1. Responding to movement of the users head (Cardboard gaze-based-pointer).
            2. Responding to the movement of the daydream controller (Daydream 3D pointer).
            </para></remarks>
        </member>
        <member name="F:GvrBasePointer.raycastMode">
            <summary>Determines which raycast mode to use for this raycaster.</summary>
            <remarks>
            Supports the following modes: <ul>
            <li>Camera - Ray is cast from the camera through the pointer.</li>
            <li>Direct - Ray is cast forward from the pointer.</li>
            <li>Hybrid - Begins with a Direct ray and transitions to a Camera ray.</li>
            </ul>
            </remarks>
        </member>
        <member name="F:GvrBasePointer.overridePointerCamera">
            <summary>
            Determines the `eventCamera` for `GvrPointerPhysicsRaycaster` and
            `GvrPointerGraphicRaycaster`.
            </summary>
            <remarks>
            Additionaly, this is used to control what camera to use when calculating the Camera ray for
            the Hybrid and Camera raycast modes.
            </remarks>
        </member>
        <member name="F:GvrBasePointer.drawDebugRays">
            <summary>
            Determines if the rays used for raycasting will be drawn in the editor.
            </summary>
        </member>
        <member name="T:GvrBasePointer.RaycastMode">
            <summary>The method by which GvrPointer perorms Raycasts.</summary>
            <remarks>
            Camera is usually ideal at long range,
            Direct is usually ideal at close range, and Hybrid interpolates between the two depending
            on range.
            </remarks>
        </member>
        <member name="F:GvrBasePointer.RaycastMode.Camera">
            <summary>
            Camera-based raycasting.  Detects collisions for the pointer from the Camera.
            </summary>
            <remarks><para>
            Casts a ray from the camera through the target of the pointer. This is ideal for
            reticles that are always rendered on top. The object that is selected will always be
            the object that appears underneath the reticle from the perspective of the camera.
            This also prevents the reticle from appearing to "jump" when it starts/stops hitting
            an object.
            </para><para>
            Recommended for reticles that are always rendered on top such as the GvrReticlePointer
            prefab which is used for cardboard apps.
            </para><para>
            Note: This will prevent the user from pointing around an object to hit something that
            is out of sight.  This isn't a problem in a typical use case.
            </para><para>
            When used with the standard daydream controller, the hit detection will not account for
            the laser correctly for objects that are closer to the camera than the end of the
            laser.
            In that case, it is recommended to do one of the following things:
            1. Hide the laser.
            2. Use a full-length laser pointer in Direct mode.
            3. Use the Hybrid raycast mode.
            </para></remarks>
        </member>
        <member name="F:GvrBasePointer.RaycastMode.Direct">
            <summary>
            Direct raycasting.  Detects collisions for the pointer from the Controller.
            </summary>
            <remarks><para>
            Cast a ray directly from the pointer origin.
            </para><para>
            Recommended for full-length laser pointers.
            </para></remarks>
        </member>
        <member name="F:GvrBasePointer.RaycastMode.Hybrid">
            <summary>
            Hybrid raycasting.  Interpolates between Camera and Direct based on distance.
            </summary>
            <remarks><para>
            Default method for casting ray.
            </para><para>
            Combines the Camera and Direct raycast modes. Uses a Direct ray up until the
            CameraRayIntersectionDistance, and then switches to use a Camera ray starting from the
            point where the two rays intersect.
            </para><para>
            Recommended for use with the standard settings of the GvrControllerPointer prefab.
            This is the most versatile raycast mode. Like Camera mode, this prevents the reticle
            appearing jumpy. Additionally, it still allows the user to target objects that are
            close to them by using the laser as a visual reference.
            </para></remarks>
        </member>
        <member name="P:GvrBasePointer.CurrentRaycastResult">
            <summary>Gets the current RaycastResult.</summary>
            <remarks>
            A convenience function for fetching the object the pointer is currently hitting.
            </remarks>
            <value>The current raycast result.</value>
        </member>
        <member name="P:GvrBasePointer.PointerIntersection">
            @deprecated Replaced by `CurrentRaycastResult.worldPosition`.
            <summary>Gets the pointer intersection.</summary>
            <value>The pointer intersection.</value>
        </member>
        <member name="P:GvrBasePointer.IsPointerIntersecting">
            @deprecated Replaced by `CurrentRaycastResult.gameObject != null`.
            <summary>
            Gets a value indicating whether the pointer raycast intersects any object.
            </summary>
            <value>
            Value `true` if the pointer raycast intersects any object, otherwise `false`.
            </value>
        </member>
        <member name="P:GvrBasePointer.ShouldUseExitRadiusForRaycast">
            <summary>
            Gets or sets a value indicating whether the `enterRadius` should be used for the raycast
            or the `exitRadius` should be used.
            </summary>
            <remarks>
            It is set by `GvrPointerInputModule` and doesn't need to be controlled manually.
            </remarks>
            <value>
            Value `true` if enterRadius should be used for the racyast, `false` otherwise.
            </value>
        </member>
        <member name="P:GvrBasePointer.CurrentPointerRadius">
            <summary>Gets the current radius of the pointer.</summary>
            <remarks>
            Gets the `exitRadius` if `ShouldUseExitRadiusForRaycast` is `true`, otherwise returns the
            `enterRadius`.
            </remarks>
            <value>The current pointer radius.</value>
        </member>
        <member name="P:GvrBasePointer.PointerTransform">
            <summary>Gets the transform that represents this pointer.</summary>
            <remarks>It is used by `GvrBasePointerRaycaster` as the origin of the ray.</remarks>
            <value>The pointer transform.</value>
        </member>
        <member name="P:GvrBasePointer.ControllerInputDevice">
            <summary>Gets or sets the reference to the controller input device.</summary>
            <value>The reference to the controller input device.</value>
        </member>
        <member name="P:GvrBasePointer.TriggerDown">
            <summary>Gets a value indicating whether the trigger was just pressed.</summary>
            <remarks>
            This is an event flag.  It will be true for only one frame after the event happens.
            Defaults to mouse button 0 down on Cardboard or
            `ControllerInputDevice.GetButtonDown(TouchPadButton)` on Daydream.
            Can be overridden to change the trigger.
            </remarks>
            <value>Value `true` if the trigger was just pressed, `false` otherwise.</value>
        </member>
        <member name="P:GvrBasePointer.Triggering">
            <summary>Gets a value indicating whether the trigger is currently being pressed.</summary>
            <remarks>
            This is not an event; it represents the trigger's state (it remains true while
            the trigger is being pressed).
            Defaults to mouse button 0 state on Cardboard or
            `ControllerInputDevice.GetButton(TouchPadButton)` on Daydream.
            Can be overridden to change the trigger.
            </remarks>
            <value>Value `true` if the trigger is currently being pressed, `false` otherwise.</value>
        </member>
        <member name="P:GvrBasePointer.TriggerUp">
            <summary>
            Gets a value indicating whether the trigger was just released.
            </summary>
            <remarks>
            This is an event flag; it will be true for only one frame after the event happens.
            Defaults to mouse button 0 up on Cardboard or
            `ControllerInputDevice.GetButtonUp(TouchPadButton)` on Daydream.
            Can be overridden to change the trigger.
            </remarks>
            <value>Value `true` if the trigger was just released, `false` otherwise.</value>
        </member>
        <member name="P:GvrBasePointer.TouchDown">
            <summary>
            Gets a value indicating whether the user just started touching the touchpad.
            </summary>
            <remarks>
            This is an event flag; it is `true` for only one frame after the event happens,
            then reverts to false.
            Used by `GvrPointerScrollInput` to generate `OnScroll` events using Unity's event system.
            Defaults to `ControllerInputDevice.GetButtonDown(TouchPadTouch)`, can be overridden to
            change the input source.
            </remarks>
            <value>
            Value `true` if the user just started touching the touchpad, `false` otherwise.
            </value>
        </member>
        <member name="P:GvrBasePointer.IsTouching">
            <summary>
            Gets a value indicating whether the user is currently touching the touchpad.
            </summary>
            <remarks>
            Used by `GvrPointerScrollInput` to generate `OnScroll` events using Unity's event system.
            Defaults to `ControllerInputDevice.GetButton(TouchPadTouch)`, can be overridden to change
            the input source.
            </remarks>
            <value>
            Value `true` the user is currently touching the touchpad; otherwise, `false`.
            </value>
        </member>
        <member name="P:GvrBasePointer.TouchUp">
            <summary>
            Gets a value indicating whether the user just stopped touching the touchpad.
            </summary>
            <remarks>
            This is an event flag; it is `true` for only one frame after the event happens,
            then reverts to false.
            Used by `GvrPointerScrollInput` to generate `OnScroll` events using Unity's event system.
            Defaults to `ControllerInputDevice.GetButtonUp(TouchPadTouch)`, can be overridden to change
            the input source.
            </remarks>
            <value>The touch up.</value>
        </member>
        <member name="P:GvrBasePointer.TouchPos">
            <summary>
            Gets the position of the current touch, if touching the touchpad. If not touching, this
            is the position of the last touch (when the finger left the touchpad).
            </summary>
            <remarks>
            The X and Y range is from 0 to 1.
            (0, 0) is the top left of the touchpad and (1, 1) is the bottom right of the touchpad.
            Used by `GvrPointerScrollInput` to generate `OnScroll` events using Unity's event system.
            Defaults to `ControllerInputDevice.TouchPos` but translated to top-left-relative coordinates
            for backwards compatibility. Can be overridden to change the input source.
            </remarks>
            <value>The touch position.</value>
        </member>
        <member name="P:GvrBasePointer.MaxPointerEndPoint">
            <summary>
            Gets the end point of the pointer when it is MaxPointerDistance away from the origin.
            </summary>
            <value>
            The end point of the pointer when it is MaxPointerDistance away from the origin.
            </value>
        </member>
        <member name="P:GvrBasePointer.IsAvailable">
            <summary>
            Gets a value indicating whether the pointer will be used for generating input events by
            `GvrPointerInputModule`.
            </summary>
            <value>
            Value `true` if the pointer will be used for generating input events by
            `GvrPointerInputModule`, `false`.
            </value>
        </member>
        <member name="P:GvrBasePointer.CameraRayIntersectionDistance">
            <summary>
            Gets the location where the ray from the pointer will intersect with the ray from the
            camera when using the Hybrid raycast mode.
            </summary>
            <value>
            The location where the ray from the pointer will intersect with the ray from the camera
            when using the Camera raycast mode.
            </value>
        </member>
        <member name="P:GvrBasePointer.PointerCamera">
            <summary>Gets the camera used as the pointer.</summary>
            <value>The camera used as the pointer.</value>
        </member>
        <member name="P:GvrBasePointer.MaxPointerDistance">
            <summary>
            Gets the max distance from the pointer that raycast hits will be detected.
            </summary>
            <value>The max pointer distance from the pointer that raycast hits will be detected.</value>
        </member>
        <member name="M:GvrBasePointer.CalculateRay(GvrBasePointer,GvrBasePointer.RaycastMode)">
            <summary>
            Calculates the ray for a given Raycast mode.
            </summary>
            <remarks>
            Will throw an exception if the raycast mode Hybrid is passed in.
            If you need to calculate the ray for the direct or camera segment of the Hybrid raycast,
            use CalculateHybridRay instead.
            </remarks>
            <param name="pointer">Which pointer to project the ray from.</param>
            <param name="mode">Which Raycast mode to use.  Must be Camera or Direct.</param>
            <returns>The PointerRay as projected from the GvrbasePointer in the given mode.</returns>
        </member>
        <member name="M:GvrBasePointer.CalculateHybridRay(GvrBasePointer,GvrBasePointer.RaycastMode)">
            <summary>
            Calculates the ray for the segment of the Hybrid raycast determined by the raycast mode
            passed in.
            </summary>
            <remarks>
            Throws an exception if Hybrid is passed in.
            </remarks>
            <param name="pointer">Which pointer to project the ray from.</param>
            <param name="hybridMode">
            Which Raycast sub-mode to use within Hybrid mode.  Must be Camera or Direct.
            </param>
            <returns>The PointerRay as projected from the GvrbasePointer in the given mode.</returns>
        </member>
        <member name="M:GvrBasePointer.OnPointerEnter(UnityEngine.EventSystems.RaycastResult,System.Boolean)">
            <summary>Called when the pointer is facing a valid GameObject.</summary>
            <remarks>This can be a 3D or UI element.</remarks>
            <param name="raycastResult">
            The hit detection result for the object being pointed at.
            </param>
            <param name="isInteractive">
            Value `true` if the object being pointed at is interactive.
            </param>
        </member>
        <member name="M:GvrBasePointer.OnPointerHover(UnityEngine.EventSystems.RaycastResult,System.Boolean)">
            <summary>Called every frame the user is still pointing at a valid GameObject.</summary>
            <remarks>This can be a 3D or UI element.</remarks>
            <param name="raycastResultResult">
            The hit detection result for the object being pointed at.
            </param>
            <param name="isInteractive">
            Value `true` if the object being pointed at is interactive.
            </param>
        </member>
        <member name="M:GvrBasePointer.OnPointerExit(UnityEngine.GameObject)">
            <summary>
            Called when the pointer no longer faces an object previously
            intersected with a ray projected from the camera.
            </summary>
            <remarks>
            This is also called just before **OnInputModuleDisabled**
            previousObject will be null in this case.
            </remarks>
            <param name="previousObject">
            The object that was being pointed at the previous frame.
            </param>
        </member>
        <member name="M:GvrBasePointer.OnPointerClickDown">
            <summary>
            Called when a click is initiated.
            </summary>
        </member>
        <member name="M:GvrBasePointer.OnPointerClickUp">
            <summary>
            Called when click is finished.
            </summary>
        </member>
        <member name="M:GvrBasePointer.GetPointerRadius(System.Single@,System.Single@)">
            <summary>Return the radius of the pointer.</summary>
            <remarks><para>
            It is used by GvrPointerPhysicsRaycaster when searching for valid pointer targets. If a
            radius is 0, then a ray is used to find a valid pointer target. Otherwise it will use a
            SphereCast.
            </para><para>
            The *enterRadius* is used for finding new targets while the *exitRadius*
            is used to see if you are still nearby the object currently pointed at
            to avoid a flickering effect when just at the border of the intersection.
            </para><para>
            NOTE: This is only works with GvrPointerPhysicsRaycaster. To use it with uGUI,
            add 3D colliders to your canvas elements.
            </para></remarks>
            <param name="enterRadius">Used for finding new targets.</param>
            <param name="exitRadius">
            Used to see if the pointer is still nearby the object currently pointed at.  This exists
            to avoid a flickering effect when just at the border of the intersection.
            </param>
        </member>
        <member name="M:GvrBasePointer.GetPointAlongPointer(System.Single)">
            <summary>
            Returns a point in worldspace a specified distance along the pointer.
            </summary>
            <remarks><para>
            What this point will be is different depending on the raycastMode.
            </para><para>
            Because raycast modes differ, use this function instead of manually calculating a point
            projected from the pointer.
            </para></remarks>
            <param name="distance">The distance along the pointer's laser.</param>
            <returns>A worlspace position along the pointer's laser.</returns>
        </member>
        <member name="M:GvrBasePointer.GetRayForDistance(System.Single)">
            <summary>
            Returns the ray used for projecting points out of the pointer for the given distance.
            </summary>
            <remarks>
            In Hybrid raycast mode, the ray will be different depending upon the distance.
            In Camera or Direct raycast mode, the ray will always be the same.
            </remarks>
            <param name="distance">The distance to check.</param>
            <returns>
            Either the Camera or Controller's PointerRay. For Hybrid mode, this will return Camera at
            large distances and Controller at close distances.  For other modes, the ray will always
            be the mode's associated ray (Camera=Camera, Direct=Controller).
            </returns>
        </member>
        <member name="M:GvrBasePointer.Start">
            @cond
            <summary>
            This MonoBehavior's Start() implementation.
            </summary>
        </member>
        <member name="M:GvrBasePointer.OnDrawGizmos">
            <summary>Draws gizmos that visualize the rays used by the pointer for raycasting.</summary>
            <remarks><para>
            These rays will change based on the `raycastMode` selected.
            </para><para>
            This is a `MonoBehavior` builtin implementation: Implement `OnDrawGizmos` if you want to
            draw gizmos that are also pickable and always drawn.  This allows you to quickly pick
            important objects in your Scene.  Note that `OnDrawGizmos` will use a mouse position that is
            relative to the Scene View.  This function does not get called if the component is collapsed
            in the inspector. Use `OnDrawGizmosSelected` to draw gizmos when the game object is
            selected.
            </para></remarks>
        </member>
        <member name="M:GvrBasePointer.OnEnable">
            <summary>This MonoBehavior's OnEnable behavior.</summary>
        </member>
        <member name="T:GvrBasePointer.PointerRay">
            <summary>Represents a ray segment for a series of intersecting rays.</summary>
            <remarks>This is useful for Hybrid raycast mode, which uses two sequential rays.</remarks>
        </member>
        <member name="F:GvrBasePointer.PointerRay.ray">
            <summary>The ray for this segment of the pointer.</summary>
        </member>
        <member name="F:GvrBasePointer.PointerRay.distanceFromStart">
            <summary>
            The distance along the pointer from the origin of the first ray to this ray.
            </summary>
        </member>
        <member name="F:GvrBasePointer.PointerRay.distance">
            <summary>Distance that this ray extends to.</summary>
        </member>
        <member name="T:GvrBasePointerRaycaster">
            <summary>This script provides shared functionality used by all Gvr raycasters.</summary>
        </member>
        <member name="M:GvrBasePointerRaycaster.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GvrBasePointerRaycaster" /> class.
            </summary>
        </member>
        <member name="P:GvrBasePointerRaycaster.CurrentRaycastModeForHybrid">
            <summary>Gets the mode used for raycasting.</summary>
            <value>The mode used for raycasting.</value>
        </member>
        <member name="M:GvrBasePointerRaycaster.GetLastRay">
            <summary>
            Gets the last ray created.
            </summary>
            <returns>The last ray created.</returns>
        </member>
        <member name="M:GvrBasePointerRaycaster.Raycast(UnityEngine.EventSystems.PointerEventData,System.Collections.Generic.List{UnityEngine.EventSystems.RaycastResult})">
            <summary>Raycast against the scene.</summary>
            <param name="eventData">The pointer event data.</param>
            <param name="resultAppendList">The result of the raycast is appended to this list.</param>
        </member>
        <member name="M:GvrBasePointerRaycaster.PerformRaycast(GvrBasePointer.PointerRay,System.Single,UnityEngine.EventSystems.PointerEventData,System.Collections.Generic.List{UnityEngine.EventSystems.RaycastResult})">
            <summary>Perform raycast on the scene.</summary>
            <param name="pointerRay">The ray to use for the operation.</param>
            <param name="radius">The radius of the ray to use when testing for hits.</param>
            <param name="eventData">The event data triggered by any resultant Raycast hits.</param>
            <param name="resultAppendList">The results are appended to this list.</param>
            <returns>Returns `true` if the Raycast has at least one hit, `false` otherwise.</returns>
        </member>
        <member name="T:GoogleVR.Beta.GvrBetaAndroidNativeControllerInputProvider">
            <summary>Daydream controller provider for AndroidNative impl of the Beta API.</summary>
        </member>
        <member name="T:GoogleVR.Beta.GvrBetaControllerInput">
            <summary>Daydream controller beta API.</summary>
        </member>
        <member name="T:GoogleVR.Beta.GvrBetaControllerInput.Configuration">
            <summary>Daydream Controller configurations.</summary>
            <remarks>Matches the C API enum `gvr_beta_controller_configuration_type`.</remarks>
        </member>
        <member name="F:GoogleVR.Beta.GvrBetaControllerInput.Configuration.Unknown">
            <summary>Used when controller configuration is unknown.</summary>
        </member>
        <member name="F:GoogleVR.Beta.GvrBetaControllerInput.Configuration.Is3DoF">
            <summary>Daydream (3DoF) controller.</summary>
        </member>
        <member name="F:GoogleVR.Beta.GvrBetaControllerInput.Configuration.Is6DoF">
            <summary>Daydream 6DoF controller.</summary>
        </member>
        <member name="T:GoogleVR.Beta.GvrBetaControllerInput.TrackingStatusFlags">
            <summary>Tracking status flags for Daydream 6DoF controllers.</summary>
            <remarks><para>
            Although enum values are in practice currently mutually exclusive, returned values
            should be tested using bitwise tests.
            </para><para>
            Matches the C API enum `gvr_beta_controller_tracking_status_flags`.
            </para></remarks>
        </member>
        <member name="F:GoogleVR.Beta.GvrBetaControllerInput.TrackingStatusFlags.Unknown">
            <summary>The controller's tracking status is unknown.</summary>
        </member>
        <member name="F:GoogleVR.Beta.GvrBetaControllerInput.TrackingStatusFlags.Nominal">
            <summary>The controller is tracking in 6DoF mode.</summary>
        </member>
        <member name="F:GoogleVR.Beta.GvrBetaControllerInput.TrackingStatusFlags.Occluded">
            <summary>The 6DoF controller is occluded.</summary>
            <remarks>
            6DoF controllers report 3DoF pose and last-known position in this case.
            </remarks>
        </member>
        <member name="F:GoogleVR.Beta.GvrBetaControllerInput.TrackingStatusFlags.OutOfFov">
            <summary>The controller is out of field of view.</summary>
            <remarks>
            6DoF controllers report 3DoF pose and last-known position in this case.
            </remarks>
        </member>
        <member name="M:GoogleVR.Beta.GvrBetaControllerInput.GetConfigurationType(System.Int32)">
            <summary>Gets the current controller configuration.</summary>
            <remarks>Controller configuration will only change while the app is paused.</remarks>
            <param name="device">A controller input device to get the configuration for.</param>
            <returns>The controller configuration (3DoF or 6DoF).</returns>
        </member>
        <member name="M:GoogleVR.Beta.GvrBetaControllerInput.GetTrackingStatusFlags(System.Int32)">
            <summary>Gets the tracking status flags for the given controller.</summary>
            <param name="device">A controller input device to get the tracking status for.</param>
            <returns>A bitwise series of flags representing tracking status.</returns>
        </member>
        <member name="T:GoogleVR.Beta.GvrBetaControllerState">
            <summary>
            Internal representation of the Beta features for controller's current state.
            </summary>
            <remarks>
            The fields in this class have identical meanings to their correspondents in the GVR C API,
            so they are not redundantly documented here.
            </remarks>
        </member>
        <member name="T:GoogleVR.Beta.GvrBetaControllerVisualMulti">
            <summary>A beta library for multiple 6DoF controller visuals.</summary>
        </member>
        <member name="F:GoogleVR.Beta.GvrBetaControllerVisualMulti.visualsAssets">
            <summary>
            An array of mesh and material pairs used to dynamically change the controller visual.
            </summary>
        </member>
        <member name="P:GoogleVR.Beta.GvrBetaControllerVisualMulti.PreferredAlpha">
            <inheritdoc/>
        </member>
        <member name="M:GoogleVR.Beta.GvrBetaControllerVisualMulti.GetVisualAssets">
            <inheritdoc/>
        </member>
        <member name="T:GoogleVR.Beta.GvrBetaEditorControllerInputProvider">
            <summary>Daydream controller provider for Editor impl of the Beta API.</summary>
        </member>
        <member name="T:GoogleVR.Beta.GvrBetaSeeThroughCameraMode">
            <summary>
            The different supported appearances that determine how see-through camera
            frames will be drawn.
            </summary>
            <remarks>Matches the C API enum `gvr_beta_see_through_camera_mode`.</remarks>
        </member>
        <member name="F:GoogleVR.Beta.GvrBetaSeeThroughCameraMode.Disabled">
            <summary>The default behavior where no camera frames will be drawn.</summary>
        </member>
        <member name="F:GoogleVR.Beta.GvrBetaSeeThroughCameraMode.RawImage">
            <summary>
            The monochrome image will be shown as a grayscale image.
            A theoretical color image will be shown in color.
            </summary>
        </member>
        <member name="F:GoogleVR.Beta.GvrBetaSeeThroughCameraMode.ToneMap">
            <summary>
            The monochrome image will be mapped to a blue to orange to white color
            gradient.
            </summary>
        </member>
        <member name="T:GoogleVR.Beta.GvrBetaSeeThroughSceneType">
            <summary>
            The different scene types that an app can have. These control where the scene
            is rendered from. Generally in a virtual scene the scene should be rendered from
            the users' eyes while an augmented scene should be rendered from the camera's
            position to match the see-through images. More details can be found in the
            online developer documentation.
            </summary>
        </member>
        <member name="F:GoogleVR.Beta.GvrBetaSeeThroughSceneType.Virtual">
            <summary>Virtual scene type.</summary>
            <remarks>
            This represents a scene either composed entirely of virtual objects
            with no see-through or a scene that is primarily virtual with small
            cut outs for see-through. No head pose adjustments are applied with this
            scene type.
            </remarks>
        </member>
        <member name="F:GoogleVR.Beta.GvrBetaSeeThroughSceneType.Augmented">
            <summary>Augmented scene type with virtual objects.</summary>
            <remarks>
            This represents a scene that is primarily see-through with sparse virtual
            objects inside the real environment.  Head poses are adjusted based on camera
            geometry to make virtual objects track properly with the real environment.
            </remarks>
        </member>
        <member name="T:GoogleVR.Beta.GvrBetaHeadset">
            <summary>Daydream headset beta API.</summary>
        </member>
        <member name="F:GoogleVR.Beta.GvrBetaHeadset.initialCameraMode">
            <summary>Initial see-through camera mode set when this object starts.</summary>
        </member>
        <member name="F:GoogleVR.Beta.GvrBetaHeadset.initialSceneType">
            <summary>Initial see-through scene type set when this object starts.</summary>
        </member>
        <member name="P:GoogleVR.Beta.GvrBetaHeadset.CameraMode">
            <summary>Gets or sets the current see-through camera mode.</summary>
            <value>The see-through camera mode.</value>
        </member>
        <member name="P:GoogleVR.Beta.GvrBetaHeadset.SceneType">
            <summary>Gets or sets the current see-through scene type.</summary>
            <value>The see-through scene type.</value>
        </member>
        <member name="M:GoogleVR.Beta.GvrBetaHeadset.SetSeeThroughConfig(GoogleVR.Beta.GvrBetaSeeThroughCameraMode,GoogleVR.Beta.GvrBetaSeeThroughSceneType)">
            <summary>Sets the current see-through camera mode and scene type.</summary>
            <param name="cameraMode">The see-through camera mode to be set.</param>
            <param name="sceneType">The see-through scene type to be set.</param>
        </member>
        <member name="T:GoogleVR.Beta.GvrBetaFeature">
            <summary>
            Types of Daydream features that the user can enable or disable at runtime.
            </summary>
            <remarks>Matches the C API enum `gvr_runtime_feature`.</remarks>
        </member>
        <member name="F:GoogleVR.Beta.GvrBetaFeature.SeeThrough">
            <summary>The see-through feature.</summary>
        </member>
        <member name="T:GoogleVR.Beta.GvrBetaSettings">
            <summary>Daydream beta settings API.</summary>
        </member>
        <member name="M:GoogleVR.Beta.GvrBetaSettings.IsFeatureSupported(GoogleVR.Beta.GvrBetaFeature)">
            <summary>
            Queries whether a particular GVR feature is supported by the underlying platform.
            </summary>
            <param name="feature">The `GvrBetaFeature` being queried.</param>
            <returns>Returns `true` if the feature is supported, `false` otherwise.</returns>
        </member>
        <member name="M:GoogleVR.Beta.GvrBetaSettings.IsFeatureEnabled(GoogleVR.Beta.GvrBetaFeature)">
            <summary>
            Queries whether a particular GVR feature has been enabled by the user.
            </summary>
            <param name="feature">The `GvrBetaFeature` being queried.</param>
            <returns>Returns `true` if the feature is enabled, `false` otherwise.</returns>
        </member>
        <member name="M:GoogleVR.Beta.GvrBetaSettings.RequestFeatures(GoogleVR.Beta.GvrBetaFeature[],GoogleVR.Beta.GvrBetaFeature[])">
            <summary>
            Asks the user to enable one or more features. This API will return
            immediately and will asynchronously ask the user to enable features using
            a separate Activity.
            </summary>
            <param name="requiredFeatures">A list of required `GvrBetaFeature`s. The
            user will not be returned to the app if they decline a required feature.
            This can be null if there are no required features.</param>
            <param name="optionalFeatures">A list of optional `GvrBetaFeature`s.
            This can be null if there are no required features.</param>
        </member>
        <member name="T:GoogleVR.Beta.GvrControllerInputDeviceExtension">
            <summary>
            Class extension for `GvrControllerInputDevice` to add beta tracking status getter.
            </summary>
        </member>
        <member name="M:GoogleVR.Beta.GvrControllerInputDeviceExtension.GetConfigurationType(GvrControllerInputDevice)">
            <summary>Gets a controller's configuration type.</summary>
            <remarks>Controller configuration will only change while the app is paused.</remarks>
            <param name="device">A controller input device to get the configuration for.</param>
            <returns>The controller configuration (3DoF or 6DoF).</returns>
        </member>
        <member name="M:GoogleVR.Beta.GvrControllerInputDeviceExtension.GetTrackingStatusFlags(GvrControllerInputDevice)">
            <summary>Gets a controller's tracking status.</summary>
            <remarks>
            Although `TrackingStatusFlags` values are in practice currently mutually exclusive,
            returned values should be tested using bitwise tests.
            </remarks>
            <param name="device">A controller input device to get the tracking status for.</param>
            <returns>A bitwise series of flags representing tracking status.</returns>
        </member>
        <member name="T:GvrCardboardHelpers">
            <summary>General Cardboard helper methods.</summary>
        </member>
        <member name="M:GvrCardboardHelpers.Recenter">
            <summary>Manual recenter for Cardboard apps.</summary>
            <remarks><para>
            After recentering the camera's orientation will be given in the new recentered coordinate
            system.
            </para><para>
            Do not use for Daydream apps as controller based recentering is handled automatically by
            Google VR Services.  <see cref="!:GvrControllerInput#recentered"/>
            for details.
            </para></remarks>
        </member>
        <member name="M:GvrCardboardHelpers.SetViewerProfile(System.String)">
            <summary>Set the Cardboard viewer params.</summary>
            <remarks>
            Example URI for 2015 Cardboard Viewer V2:
            "http://google.com/cardboard/cfg?p=CgZHb29nbGUSEkNhcmRib2FyZCBJL08gMjAxNR0rGBU9JQHegj0qEAAASEIAAEhCAABIQgAASEJYADUpXA89OggeZnc-Ej6aPlAAYAM".
            </remarks>
            <param name="viewerProfileUri">The URI to a cardboard viewer profile.</param>
        </member>
        <member name="T:GvrConnectionState">
            <summary>Represents a controller's current connection state.</summary>
            <remarks>
            All values and semantics below (except for Error) are from gvr_types.h in the GVR C API.
            </remarks>
        </member>
        <member name="F:GvrConnectionState.Error">
            <summary>Indicates that an error has occurred.</summary>
        </member>
        <member name="F:GvrConnectionState.Disconnected">
            <summary>Indicates a controller is disconnected.</summary>
        </member>
        <member name="F:GvrConnectionState.Scanning">
            <summary>Indicates that the device is scanning for controllers.</summary>
        </member>
        <member name="F:GvrConnectionState.Connecting">
            <summary>Indicates that the device is connecting to a controller.</summary>
        </member>
        <member name="F:GvrConnectionState.Connected">
            <summary>Indicates that the device is connected to a controller.</summary>
        </member>
        <member name="T:GvrControllerApiStatus">
            <summary>Represents the status of the controller API.</summary>
            <remarks>Values and semantics are from `gvr_types.h` in the GVR C API.</remarks>
        </member>
        <member name="F:GvrControllerApiStatus.Error">
            <summary>A Unity-localized error occurred.</summary>
            <remarks>This is the only value that isn't in `gvr_types.h`.</remarks>
        </member>
        <member name="F:GvrControllerApiStatus.Ok">
            <summary>API is happy and healthy.</summary>
            <remarks>
            This doesn't mean any controllers are connected, it just means that the underlying service
            is working properly.
            </remarks>
        </member>
        <member name="F:GvrControllerApiStatus.Unsupported">
            <summary>
            API failed because this device does not support controllers (API is too low, or other
            required feature not present).
            </summary>
        </member>
        <member name="F:GvrControllerApiStatus.NotAuthorized">
            <summary>
            This app was not authorized to use the service (e.g., missing permissions, the app is
            blacklisted by the underlying service, etc).
            </summary>
        </member>
        <member name="F:GvrControllerApiStatus.Unavailable">
            <summary>The underlying VR service is not present.</summary>
        </member>
        <member name="F:GvrControllerApiStatus.ApiServiceObsolete">
            <summary>The underlying VR service is too old, needs upgrade.</summary>
        </member>
        <member name="F:GvrControllerApiStatus.ApiClientObsolete">
            <summary>
            The underlying VR service is too new, is incompatible with current client.
            </summary>
        </member>
        <member name="F:GvrControllerApiStatus.ApiMalfunction">
            <summary>The underlying VR service is malfunctioning. Try again later.</summary>
        </member>
        <member name="T:GvrControllerBatteryLevel">
            <summary>Represents a controller's current battery level.</summary>
            <remarks>Values and semantics from gvr_types.h in the GVR C API.</remarks>
        </member>
        <member name="F:GvrControllerBatteryLevel.Error">
            <summary>A Unity-localized error occurred.</summary>
            <remarks>This is the only value that isn't in `gvr_types.h`.</remarks>
        </member>
        <member name="F:GvrControllerBatteryLevel.Unknown">
            <summary>The battery state is currently unreported.</summary>
        </member>
        <member name="F:GvrControllerBatteryLevel.CriticalLow">
            <summary>Equivalent to 1 out of 5 bars on the battery indicator.</summary>
        </member>
        <member name="F:GvrControllerBatteryLevel.Low">
            <summary>Equivalent to 2 out of 5 bars on the battery indicator.</summary>
        </member>
        <member name="F:GvrControllerBatteryLevel.Medium">
            <summary>Equivalent to 3 out of 5 bars on the battery indicator.</summary>
        </member>
        <member name="F:GvrControllerBatteryLevel.AlmostFull">
            <summary>Equivalent to 4 out of 5 bars on the battery indicator.</summary>
        </member>
        <member name="F:GvrControllerBatteryLevel.Full">
            <summary>Equivalent to 5 out of 5 bars on the battery indicator.</summary>
        </member>
        <member name="T:GvrControllerButton">
            <summary>Represents controller buttons.</summary>
            <remarks>
            Values 0-9 are from `gvr_types.h` in the GVR C API.  Value 31 is not represented in the C API.
            </remarks>
        </member>
        <member name="F:GvrControllerButton.TouchPadButton">
            <summary>The Button under the touch pad.</summary>
            <remarks>Formerly known as Click.</remarks>
        </member>
        <member name="F:GvrControllerButton.TouchPadTouch">
            <summary>Touch pad touching indicator.</summary>
        </member>
        <member name="F:GvrControllerButton.App">
            <summary>General application button.</summary>
        </member>
        <member name="F:GvrControllerButton.System">
            <summary>System button.</summary>
            <remarks>Formerly known as Home.</remarks>
        </member>
        <member name="F:GvrControllerButton.Trigger">
            <summary>Primary button on the underside of the controller.</summary>
        </member>
        <member name="F:GvrControllerButton.Grip">
            <summary>Secondary button on the underside of the controller.</summary>
        </member>
        <member name="F:GvrControllerButton.Reserved2">
            <summary>Buttons reserved for future use. Subject to name change.</summary>
        </member>
        <member name="T:GvrControllerHand">
            <summary>Represents controller handedness.</summary>
        </member>
        <member name="F:GvrControllerHand.Right">
            <summary>Right hand.</summary>
        </member>
        <member name="F:GvrControllerHand.Left">
            <summary>Left hand.</summary>
        </member>
        <member name="F:GvrControllerHand.Dominant">
            <summary>Alias for dominant hand as specified by `GvrSettings.Handedness`.</summary>
        </member>
        <member name="F:GvrControllerHand.NonDominant">
            <summary>Alias for non-dominant hand.</summary>
        </member>
        <member name="T:GvrControllerInput">
            <summary>Main entry point for the Daydream controller API.</summary>
            <remarks>
            To use this API, add this script to a game object in your scene, or use the
            **GvrControllerMain** prefab.  This is a singleton object. There can only be one object with
            this script in your scene.
            <para>
            To access a controller's state, get a device from `GvrControllerInput.GetDevice` then query it
            for state. For example, to the dominant controller's current orientation, use
            `GvrControllerInput.GetDevice(GvrControllerHand.Dominant).Orientation`.
            </para></remarks>
        </member>
        <member name="F:GvrControllerInput.emulatorConnectionMode">
            <summary>Indicates how to connect to the controller emulator.</summary>
        </member>
        <member name="T:GvrControllerInput.OnStateChangedEvent">
            <summary>Event handler for when the connection state of a controller changes.</summary>
            <param name="state">The new state.</param>
            <param name="oldState">The previous state.</param>
        </member>
        <member name="E:GvrControllerInput.OnControllerInputUpdated">
            <summary>
            Event handler for receiving button, touchpad, and IMU updates from the controllers.
            </summary>
            <remarks>Use this handler to update app state based on controller input.</remarks>
        </member>
        <member name="E:GvrControllerInput.OnPostControllerInputUpdated">
            <summary>
            Event handler for receiving a second notification callback, after all
            `OnControllerInputUpdated` events have fired.
            </summary>
        </member>
        <member name="E:GvrControllerInput.OnDevicesChanged">
            <summary>Event handler for when controller devices have changed.</summary>
            <remarks>
            Any code that stores a `GvrControllerInputDevice` should get a new device instance from
            `GetDevice`. Existing `GvrControllerInputDevice`s will be marked invalid and will log errors
            when used. Event handlers are called immediately when added.
            </remarks>
        </member>
        <member name="E:GvrControllerInput.OnStateChanged">
            <summary>
            Event handler for when the connection state of the dominant controller changes.
            </summary>
        </member>
        <member name="T:GvrControllerInput.EmulatorConnectionMode">
            <summary>Controller Emulatuor connection modes.</summary>
        </member>
        <member name="F:GvrControllerInput.EmulatorConnectionMode.OFF">
            <summary>Emulator disconnected.</summary>
        </member>
        <member name="F:GvrControllerInput.EmulatorConnectionMode.USB">
            <summary>Emulator connects over USB.</summary>
        </member>
        <member name="F:GvrControllerInput.EmulatorConnectionMode.WIFI">
            <summary>Emulator connects over WIFI.</summary>
        </member>
        <member name="P:GvrControllerInput.State">
            @deprecated Replaced by `GvrControllerInputDevice.State`.
            <summary>Gets the dominant controller's current connection state.</summary>
            <remarks>
            Returns `GvrConnectionState.Error` if `GvrControllerInput` is uninitialized.
            </remarks>
            <value>The state.</value>
        </member>
        <member name="P:GvrControllerInput.ApiStatus">
            <summary>Gets the status of the controller API.</summary>
            <remarks>
            Returns `GvrControllerApiStatus.Error` if `GvrControllerInput` is uninitialized.
            </remarks>
            <value>The api status.</value>
        </member>
        <member name="P:GvrControllerInput.SupportsBatteryStatus">
            <summary>Gets a value indicating whether battery status is supported.</summary>
            <remarks>Returns `false` if `GvrControllerInput` is uninitialized.</remarks>
            <value>
            Value `true` if the GVR Controller Input supports BatteryStatus calls, `false` otherwise.
            </value>
        </member>
        <member name="P:GvrControllerInput.Orientation">
            @deprecated Replaced by `GvrControllerInputDevice.Orientation`.
            <summary>
            Gets the dominant controller's current orientation in space, as a quaternion.
            </summary>
            <remarks>
            The rotation is provided in 'orientation space' which means the rotation is given relative
            to the last time the user recentered their controllers.  To make a game object in your scene
            have the same orientation as the dominant controller, simply assign this quaternion to the
            object's `transform.rotation`.  To match the relative rotation, use
            `transform.localRotation` instead.
            </remarks>
            <value>
            The orientation.  This is `Quaternion.identity` if `GvrControllerInput` is uninitialized.
            </value>
        </member>
        <member name="P:GvrControllerInput.Gyro">
            @deprecated Replaced by `GvrControllerInputDevice.Gyro`.
            <summary>
            Gets the dominant controller's current angular speed in radians per second.
            </summary>
            <remarks>
            Uses the right-hand rule (positive means a right-hand rotation about the given axis), as
            measured by the controller's gyroscope.  Returns `Vector3.zero` if `GvrControllerInput` is
            uninitialized.
            <para>
            The controller's axes are:
            - X points to the right.
            - Y points perpendicularly up from the controller's top surface.
            - Z lies along the controller's body, pointing towards the front.
            </para></remarks>
            <value>The gyro's angular speed.</value>
        </member>
        <member name="P:GvrControllerInput.Accel">
            @deprecated Replaced by `GvrControllerInputDevice.Accel`.
            <summary>
            Gets the dominant controller's current acceleration in meters per second squared.
            </summary>
            <remarks>
            The controller's axes are:
            - X points to the right.
            - Y points perpendicularly up from the controller's top surface.
            - Z lies along the controller's body, pointing towards the front.
            <para>
            Note that gravity is indistinguishable from acceleration, so when the controller is resting
            on a surface, expect to measure an acceleration of 9.8 m/s^2 on the Y axis.  The
            accelerometer reading will be zero on all three axes only if the controller is in free fall,
            or if the user is in a zero gravity environment like a space station.
            </para></remarks>
            <value>
            The acceleration.  Will be `Vector3.zero` if `GvrControllerInput` is uninitialized.
            </value>
        </member>
        <member name="P:GvrControllerInput.IsTouching">
            @deprecated Replaced by
            `GvrControllerInputDevice.GetButton(GvrControllerButton.TouchPadTouch)`.
            <summary>
            Gets a value indicating whether the user is touching the dominant controller's touchpad.
            </summary>
            <remarks>Returns `false` if `GvrControllerInput` is uninitialized.</remarks>
            <value>Value `true` if is touching. Otherwise, `false`.</value>
        </member>
        <member name="P:GvrControllerInput.TouchDown">
            @deprecated Replaced by
            `GvrControllerInputDevice.GetButtonDown(GvrControllerButton.TouchPadTouch)`.
            <summary>
            Gets a value indicating whether this frame is the frame the user starts touching the
            dominant controller's touchpad.
            </summary>
            <remarks>
            Returns `false` if `GvrControllerInput` is uninitialized.  Every `TouchDown` event is
            guaranteed to be followed by exactly one `TouchUp` event in a later frame. Also, `TouchDown`
            and `TouchUp` will never both be `true` in the same frame.
            </remarks>
            <value>
            Value `true` if this is the frame after the user starts touching the dominant controller's
            touchpad, `false` otherwise.
            </value>
        </member>
        <member name="P:GvrControllerInput.TouchUp">
            @deprecated Replaced by
            `GvrControllerInputDevice.GetButtonUp(GvrControllerButton.TouchPadTouch)`.
            <summary>
            Gets a value indicating whether this frame is the frame after the user stops touching the
            dominant controller's touchpad.
            </summary>
            <remarks>
            Returns `false` if `GvrControllerInput` is uninitialized.  Every `TouchUp` event is
            guaranteed to be preceded by exactly one `TouchDown` event in an earlier frame. Also,
            `TouchDown` and `TouchUp` will never both be `true` in the same frame.
            </remarks>
            <value>
            Value `true` if this is the frame after the user stops touching the dominant controller's
            touchpad, `false` otherwise.
            </value>
        </member>
        <member name="P:GvrControllerInput.TouchPos">
            @deprecated Please migrate to the center-relative `GvrControllerInputDevice.TouchPos`.
            <summary>
            Gets the position of the dominant controller's current touch, if touching the touchpad.
            </summary>
            <remarks>
            Returns `Vector2(0.5f, 0.5f)` if `GvrControllerInput` is uninitialized.  If not touching,
            this is the position of the last touch (when the finger left the touchpad).  The X and Y
            range is from 0 to 1.  (0, 0) is the top left of the touchpad and (1, 1) is the bottom right
            of the touchpad.
            </remarks>
            <value>The touch position.</value>
        </member>
        <member name="P:GvrControllerInput.TouchPosCentered">
            @deprecated Please migrate to the center-relative `GvrControllerInputDevice.TouchPos`.
            <summary>
            Gets the position of the dominant controller's current touch, if touching the touchpad.
            </summary>
            <remarks>
            Returns `Vector2.zero` if `GvrControllerInput` is uninitialized.  If not touching, this is
            the position of the last touch (when the finger left the touchpad).  The X and Y range is
            from -1 to 1. (-.707,-.707) is bottom left, (.707,.707) is upper right.  (0, 0) is the
            center of the touchpad.  The magnitude of the touch vector is guaranteed to be less than or
            equal to 1.
            </remarks>
            <value>The touch position centered.</value>
        </member>
        <member name="P:GvrControllerInput.Recentering">
            @deprecated Use `Recentered` to detect when user has completed the recenter gesture.
            <summary>Gets a value indicating whether the user is currently recentering.</summary>
            <value>Value `true` if the user is currently recentering, `false` otherwise.</value>
        </member>
        <member name="P:GvrControllerInput.Recentered">
            <summary>
            Gets a value indicating whether the user just completed the recenter gesture.
            </summary>
            <remarks>
            Returns `false` if `GvrControllerInput` is uninitialized.  The headset and the dominant
            controller's orientation are now being reported in the new recentered coordinate system.
            This is an event flag (it is true for only one frame after the event happens, then reverts
            to false).
            </remarks>
            <value>Value `true` if the user has just finished recentering, `false` otherwise.</value>
        </member>
        <member name="P:GvrControllerInput.ClickButton">
            @deprecated Replaced by
            `GvrControllerInputDevice.GetButton(GvrControllerButton.TouchPadButton)`.
            <summary>
            Gets a value indicating whether the user currently holds down the dominant controller's
            touchpad button.
            </summary>
            <remarks>Returns `false` if `GvrControllerInput` is uninitialized.</remarks>
            <value>
            Value `true` if the user currently holds down the dominant controller's touchpad button,
            `false` otherwise.
            </value>
        </member>
        <member name="P:GvrControllerInput.ClickButtonDown">
            @deprecated Replaced by
            `GvrControllerInputDevice.GetButtonDown(GvrControllerButton.TouchPadButton)`.
            <summary>
            Gets a value indicating whether this is the frame the user starts pressing down the dominant
            controller's touchpad button.
            </summary>
            <remarks>
            Returns `false` if `GvrControllerInput` is uninitialized.  Every `ClickButtonDown` event is
            guaranteed to be followed by exactly one `ClickButtonUp` event in a later frame. Also,
            `ClickButtonDown` and `ClickButtonUp` will never both be `true` in the same frame.
            </remarks>
            <value>
            Value `true` this is the frame the user started pressing down the dominant controller's
            touchpad button, `false` otherwise.
            </value>
        </member>
        <member name="P:GvrControllerInput.ClickButtonUp">
            @deprecated Replaced by
            `GvrControllerInputDevice.GetButtonUp(GvrControllerButton.TouchPadButton)`.
            <summary>
            Gets a value indicating whether this is the frame after the user stops pressing down the
            dominant controller's touchpad button.
            </summary>
            <remarks>
            Returns `false` if `GvrControllerInput` is uninitialized.  Every `ClickButtonUp` event is
            guaranteed to be preceded by exactly one `ClickButtonDown` event in an earlier frame. Also,
            `ClickButtonDown` and `ClickButtonUp` will never both be `true` in the same frame.
            </remarks>
            <value>
            Value `true` if this is the frame after the user stops pressing down the dominant
            controller's touchpad button, `false` otherwise.
            </value>
        </member>
        <member name="P:GvrControllerInput.AppButton">
            @deprecated Replaced by `GvrControllerInputDevice.GetButton(GvrControllerButton.App)`.
            <summary>
            Gets a value indicating whether the user is currently holding down the dominant controller's
            app button.
            </summary>
            <remarks>Returns `false` if `GvrControllerInput` is uninitialized.</remarks>
            <value>
            Value `true` if the user is currently holding down the dominant controller's app button,
            `false` otherwise.
            </value>
        </member>
        <member name="P:GvrControllerInput.AppButtonDown">
            @deprecated Replaced by `GvrControllerInputDevice.GetButtonDown(GvrControllerButton.App)`.
            <summary>
            Gets a value indicating whether this is the frame the user started pressing down the
            dominant controller's app button.
            </summary>
            <remarks>
            Returns `false` if `GvrControllerInput` is uninitialized. Every `AppButtonDown` event is
            guaranteed to be followed by exactly one `AppButtonUp` event in a later frame.
            `AppButtonDown` and `AppButtonUp` will never both be `true` in the same frame.
            </remarks>
            <value>
            Value `true` if this is the frame the user started pressing down the dominant controller's
            app button, `false` otherwise.
            </value>
        </member>
        <member name="P:GvrControllerInput.AppButtonUp">
            @deprecated Replaced by `GvrControllerInputDevice.GetButtonUp(GvrControllerButton.App)`.
            <summary>
            Gets a value indicating whether this is the frame after the user stopped pressing down the
            dominant controller's app button.
            </summary>
            <remarks>
            Returns `false` if `GvrControllerInput` is uninitialized. Every `AppButtonUp` event is
            guaranteed to be preceded by exactly one `AppButtonDown` event in an earlier frame. Also,
            `AppButtonDown` and `AppButtonUp` will never both be `true` in the same frame.
            </remarks>
            <value>
            Value `true` if this is the frame after the user stopped pressing down the dominant
            controller's app button, `false` otherwise.
            </value>
        </member>
        <member name="P:GvrControllerInput.HomeButtonDown">
            @deprecated Replaced by
            `GvrControllerInputDevice.GetButtonDown(GvrControllerButton.System)`.
            <summary>
            Gets a value indicating whether this is the frame the user started pressing down the
            dominant controller's system button.
            </summary>
            <remarks>Returns `false` if `GvrControllerInput` is uninitialized.</remarks>
            <value>
            Value `true` if this is the frame the user started pressing down the dominant controller's
            system button, `false` otherwise.
            </value>
        </member>
        <member name="P:GvrControllerInput.HomeButtonState">
            @deprecated Replaced by GvrControllerInputDevice.GetButton(GvrControllerButton.System).
            <summary>
            Gets a value indicating whether the user is holding down the dominant controller's system
            button.
            </summary>
            <remarks>Returns `false` if `GvrControllerInput` is uninitialized.</remarks>
            <value>
            Value `true` if the user is holding down the dominant controller's system button, `false`
            otherwise.
            </value>
        </member>
        <member name="P:GvrControllerInput.ErrorDetails">
            @deprecated Replaced by `GvrControllerInputDevice.ErrorDetails`.
            <summary>
            Gets details about the reasoning behind the Dominant Controller's error state.
            </summary>
            <remarks>
            If the dominant controller's state `== GvrConnectionState.Error`, this contains details
            about the error.  If `GvrControllerInput` is uninitialized this returns an error string
            describing the uninitialized state.
            </remarks>
            <value>Details about the reasoning behind the dominant controller's error state.</value>
        </member>
        <member name="P:GvrControllerInput.StatePtr">
            @deprecated Replaced by `GvrControllerInputDevice.StatePtr`.
            <summary>
            Gets the GVR C library controller state pointer (`gvr_controller_state*`) for the dominant
            controller.
            </summary>
            <remarks>Returns `IntPtr.Zero` if `GvrControllerInput` is uninitialized.</remarks>
            <value>
            The GVR C library controller state pointer (`gvr_controller_state*`) for the dominant
            controller.
            </value>
        </member>
        <member name="P:GvrControllerInput.IsCharging">
            @deprecated Replaced by `GvrControllerInputDevice.IsCharging`.
            <summary>
            Gets a value indicating whether the dominant controller is currently being charged.
            </summary>
            <remarks>Returns `false` if `GvrControllerInput` is uninitialized.</remarks>
            <value>Value `true` if the dominant controller is charging.  Otherwise, `false`.</value>
        </member>
        <member name="P:GvrControllerInput.BatteryLevel">
            @deprecated Replaced by `GvrControllerInputDevice.BatteryLevel`.
            <summary>Gets the dominant controller's current battery charge level.</summary>
            <remarks>
            Returns `GvrControllerBatteryLevel.Error` if `GvrControllerInput` is uninitialized.
            </remarks>
            <value>The dominant controller's current battery charge level.</value>
        </member>
        <member name="M:GvrControllerInput.GetDevice(GvrControllerHand)">
            <summary>Returns a controller device for the specified hand.</summary>
            <returns>The controller input device.</returns>
            <param name="hand">The hand whose input device should be fetched.</param>
        </member>
        <member name="T:GvrControllerInputDevice">
            <summary>Device instance of the Daydream controller API.</summary>
        </member>
        <member name="E:GvrControllerInputDevice.OnStateChanged">
            <summary>Event handler for when the connection state of the controller changes.</summary>
        </member>
        <member name="P:GvrControllerInputDevice.IsDominantHand">
            <summary>Gets a value indicating whether this instance is dominant hand.</summary>
            <value>Value `true` if this instance is dominant hand, `false` otherwise.</value>
        </member>
        <member name="P:GvrControllerInputDevice.IsRightHand">
            <summary>
            Gets a value indicating whether this instance is configured as being the right hand.
            </summary>
            <value>Value `true` if this instance is right hand, `false` otherwise.</value>
        </member>
        <member name="P:GvrControllerInputDevice.State">
            <summary>Gets the controller's current connection state.</summary>
            <value>The state.</value>
        </member>
        <member name="P:GvrControllerInputDevice.ApiStatus">
            <summary>Gets the API status of the current controller state.</summary>
            <value>The API status.</value>
        </member>
        <member name="P:GvrControllerInputDevice.Orientation">
            <summary>Gets the controller's current orientation in space, as a quaternion.</summary>
            <remarks>
            The rotation is provided in 'orientation space' which means the rotation is given relative
            to the last time the user recentered their controller. To make a game object in your scene
            have the same orientation as the controller, simply assign this quaternion to the object's
            `transform.rotation`. To match the relative rotation, use `transform.localRotation` instead.
            </remarks>
            <value>The orientation.</value>
        </member>
        <member name="P:GvrControllerInputDevice.Position">
            <summary>Gets the controller's current position in world space.</summary>
            <value>The controller's current position in world space.</value>
        </member>
        <member name="P:GvrControllerInputDevice.Gyro">
            <summary>Gets the controller's current angular speed in radians per second.</summary>
            <remarks>
            Generated using the right-hand rule (positive means a right-hand rotation about the given
            axis), as measured by the controller's gyroscope.
            <para>
            The controller's axes are:
            - X points to the right.
            - Y points perpendicularly up from the controller's top surface.
            - Z lies along the controller's body, pointing towards the front.
            </para></remarks>
            <value>The gyro's angular speed.</value>
        </member>
        <member name="P:GvrControllerInputDevice.Accel">
            <summary>Gets the controller's current acceleration in meters per second squared.</summary>
            <remarks>
            The controller's axes are:
            - X points to the right.
            - Y points perpendicularly up from the controller's top surface.
            - Z lies along the controller's body, pointing towards the front.
            <para>
            Note that gravity is indistinguishable from acceleration, so when the controller is resting
            on a surface, expect to measure an acceleration of 9.8 m/s^2 on the Y axis.  The
            accelerometer reading will be zero on all three axes only if the controller is in free fall,
            or if the user is in a zero gravity environment like a space station.
            </para></remarks>
            <value>The acceleration in m/s^2.</value>
        </member>
        <member name="P:GvrControllerInputDevice.TouchPos">
            <summary>Gets the position of the current touch, if touching the touchpad.</summary>
            <remarks>
            The X and Y range is from -1.0 to 1.0. (0, 0) is the center of the touchpad.  (-.707, -.707)
            is bottom left, (.707, .707) is upper right.  The magnitude of the touch vector is
            guaranteed to be less than or equal to 1.0.
            </remarks>
            <value>
            The position of the current touch, if touching the touchpad.  If not touching, this is the
            position of the last touch (when the finger left the touchpad).
            </value>
        </member>
        <member name="P:GvrControllerInputDevice.Recentered">
            <summary>
            Gets a value indicating whether the user just completed the recenter gesture.
            </summary>
            <remarks>
            The headset and the controller's orientation are now being reported in the new recentered
            coordinate system.
            </remarks>
            <value>
            Value `true` if the user just completed the recenter gesture, `false` otherwise.  This is an
            event flag (it is `true` for only one frame after the event happens, then reverts to
            `false`).
            </value>
        </member>
        <member name="P:GvrControllerInputDevice.Buttons">
            <summary>Gets the bitmask of the buttons that are down in the current frame.</summary>
            <value>The bitmask of currently-down buttons.</value>
        </member>
        <member name="P:GvrControllerInputDevice.ButtonsDown">
            <summary>
            Gets the bitmask of the buttons that began being pressed in the current frame.
            </summary>
            <remarks>
            Each individual button enum is guaranteed to be followed by exactly one ButtonsUp event in a
            later frame.  `ButtonsDown` and `ButtonsUp` will never both be `true` in the same frame for
            an individual button.
            </remarks>
            <value>The bitmask of just-pressed-down buttons.</value>
        </member>
        <member name="P:GvrControllerInputDevice.ButtonsUp">
            <summary>
            Gets the bitmask of the buttons that ended being pressed in the current frame.
            </summary>
            <remarks>
            Each individual button enum is guaranteed to be preceded by exactly one `ButtonsDown`
            event in an earlier frame.  `ButtonsDown` and `ButtonsUp` will never both be `true` in the
            same frame for an individual button.
            </remarks>
            <value>The bitmask of just-released buttons.</value>
        </member>
        <member name="P:GvrControllerInputDevice.ErrorDetails">
            <summary>Gets `GvrConnectionState` error details.</summary>
            <remarks>
            If `State == GvrConnectionState.Error`, this contains details about the error.
            </remarks>
            <value>The error details.</value>
        </member>
        <member name="P:GvrControllerInputDevice.StatePtr">
            <summary>
            Gets the GVR C library controller state pointer (`gvr_controller_state*`).
            </summary>
            <value>The state pointer.</value>
        </member>
        <member name="P:GvrControllerInputDevice.IsCharging">
            <summary>
            Gets a value indicating whether the controller is currently being charged.
            </summary>
            <value>Value `true` if this instance is charging. Otherwise, `false`.</value>
        </member>
        <member name="P:GvrControllerInputDevice.BatteryLevel">
            <summary>Gets the controller's current battery charge level.</summary>
            <value>The battery charge level.</value>
        </member>
        <member name="M:GvrControllerInputDevice.GetButton(GvrControllerButton)">
            <summary>
            Gets a value indicating whether the user is holding down any of the buttons specified in
            `buttons`.
            </summary>
            <remarks>
            Multiple `GvrControllerButton` types can be checked at once using a bitwise-or operation.
            </remarks>
            <returns>Returns `true` if the designated button is being held this frame.</returns>
            <param name="buttons">The button to get the held state for this frame.</param>
        </member>
        <member name="M:GvrControllerInputDevice.GetButtonDown(GvrControllerButton)">
            <summary>
            Gets a value indicating whether the user starts pressing down any of the buttons specified
            in `buttons`.
            </summary>
            <remarks>
            For an individual button enum, every `ButtonDown` event is guaranteed to be followed by
            exactly one `ButtonUp` event in a later frame.  `ButtonDown` and `ButtonUp` will never both
            be `true` in the same frame for an individual button.
            <para>
            Using multiple button enums together with an `or` statement can result in multiple
            `ButtonDown`s before a `ButtonUp`.
            </para></remarks>
            <returns>Returns `true` if the designated button was pressed this frame.</returns>
            <param name="buttons">The button to get the press-state for this frame.</param>
        </member>
        <member name="M:GvrControllerInputDevice.GetButtonUp(GvrControllerButton)">
            <summary>
            Gets a value indicating whether this is the frame after the user stops pressing down any of
            the buttons specified in `buttons`.
            </summary>
            <remarks>
            For an individual button enum, every `ButtonUp` event is guaranteed to be preceded by
            exactly one `ButtonDown` event in an earlier frame.  `ButtonDown` and `ButtonUp` will never
            both be `true` in the same frame for an individual button.
            <para>
            Using multiple button enums together with an `or` statement can result in multiple
            `ButtonUp`s after multiple `ButtonDown`s.
            </para></remarks>
            <returns>Returns `true` if the designated button was released this frame.</returns>
            <param name="buttons">The button to get the release-state for this frame.</param>
        </member>
        <member name="T:GvrControllerReticleVisual">
            <summary>Visualizes a reticle using a Quad.</summary>
            <remarks>
            Provides tuning options to control how the reticle scales and rotates based on distance from the
            camera.
            </remarks>
        </member>
        <member name="F:GvrControllerReticleVisual.isSizeBasedOnCameraDistance">
            <summary>
            If `true`, the scale is based on Camera Distance.  If `false`, the scale is set to the
            `sizeMeters` value.
            </summary>
        </member>
        <member name="F:GvrControllerReticleVisual.sizeMeters">
            <summary>
            The reticle will be scaled based on the size of the mesh so that its size matches this size.
            </summary>
            <remarks>Final size of the reticle in meters when it is 1 meter from the camera.</remarks>
        </member>
        <member name="F:GvrControllerReticleVisual.doesReticleFaceCamera">
            <summary>
            Determines if the reticle will always face the camera and along which axes.
            </summary>
        </member>
        <member name="F:GvrControllerReticleVisual.sortingOrder">
            <summary>Sorting order to use for the reticle's renderer.</summary>
            <remarks>
            Range values come from https://docs.unity3d.com/ScriptReference/Renderer-sortingOrder.html.
            </remarks>
        </member>
        <member name="F:GvrControllerReticleVisual.meshRenderer">
            <summary>The mesh renderer for the reticle.</summary>
        </member>
        <member name="F:GvrControllerReticleVisual.meshFilter">
            <summary>The mesh filter for the reticle.</summary>
        </member>
        <member name="P:GvrControllerReticleVisual.ReticleMeshSizeMeters">
            <summary>Gets the size of the reticle's mesh in meters.</summary>
            <value>The reticle mesh size in meters.</value>
        </member>
        <member name="P:GvrControllerReticleVisual.ReticleMeshSizeRatio">
            <summary>Gets the ratio of the reticleMeshSizeMeters compared to 1 meter.</summary>
            <remarks>If reticleMeshSizeMeters is 10, then reticleMeshSizeRatio is 0.1.</remarks>
            <value>The reticle mesh size ratio.</value>
        </member>
        <member name="M:GvrControllerReticleVisual.RefreshMesh">
            <summary>Updates the mesh dimensions.</summary>
        </member>
        <member name="M:GvrControllerReticleVisual.Awake">
            @cond
            <summary>The MonoBehavior's Awake method.</summary>
        </member>
        <member name="M:GvrControllerReticleVisual.OnEnable">
            @endcond
            @cond
            <summary>The MonoBehavior's OnEnable method.</summary>
        </member>
        <member name="M:GvrControllerReticleVisual.OnWillRenderObject">
            @endcond
            @cond
            <summary>The MonoBehavior's OnWillRenderObject method.</summary>
        </member>
        <member name="M:GvrControllerReticleVisual.OnRenderObject">
            @endcond
            @cond
            <summary>The MonoBehavior's OnRenderObject method.</summary>
        </member>
        <member name="M:GvrControllerReticleVisual.UpdateReticleSize(UnityEngine.Camera)">
            @endcond
            <summary>Update the recticle size based on the distance.</summary>
            <param name="camera">The camera to update size relative to.</param>
        </member>
        <member name="M:GvrControllerReticleVisual.UpdateReticleOrientation(UnityEngine.Camera)">
            <summary>Updates the reticle position and orientation based on the camera.</summary>
            <remarks>Locks orientation angles according to `along*Axis` fields.</remarks>
            <param name="camera">The camera to update orientation to match.</param>
        </member>
        <member name="M:GvrControllerReticleVisual.OnValidate">
            @cond
            <summary>Called by the `validate` event.</summary>
        </member>
        <member name="T:GvrControllerReticleVisual.FaceCameraData">
            @endcond
            <summary>Camera facing positioning data.</summary>
            <remarks>
            These are parameters for restricting recenters along given euler angle axes.
            </remarks>
        </member>
        <member name="F:GvrControllerReticleVisual.FaceCameraData.alongXAxis">
            <summary>Value `true` if aligned on X axis.</summary>
            <remarks>
            If `true`, the `eulerAngle.x` is set to 0 (relative to the designated Camera) after a
            recenter. Otherwise, `eulerAngle.x` is determined by relative look-positon from the
            Camera.
            </remarks>
        </member>
        <member name="F:GvrControllerReticleVisual.FaceCameraData.alongYAxis">
            <summary>Value `true` if aligned on Y axis.</summary>
            <remarks>
            If `true`, the `eulerAngle.y` is set to 0 (relative to the designated Camera) after a
            recenter. Otherwise, `eulerAngle.y` is determined by relative look-positon from the
            Camera.
            </remarks>
        </member>
        <member name="F:GvrControllerReticleVisual.FaceCameraData.alongZAxis">
            <summary>Value `true` if aligned on Z axis.</summary>
            <remarks>
            If `true`, the `eulerAngle.z` is set to 0 (relative to the designated Camera) after a
            recenter. Otherwise, `eulerAngle.z` is determined by relative look-positon from the
            Camera.
            </remarks>
        </member>
        <member name="M:GvrControllerReticleVisual.FaceCameraData.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:GvrControllerReticleVisual.FaceCameraData" /> struct.
            </summary>
            <param name="startEnabled">Whether the axes should start enabled.</param>
        </member>
        <member name="P:GvrControllerReticleVisual.FaceCameraData.IsAnyAxisOff">
            <summary>Gets a value indicating whether any axis is off.</summary>
            <value>Value `false` if along any axis, `true` otherwise.</value>
        </member>
        <member name="T:GvrControllerTooltipsSimple">
            <summary>A lightweight tooltip designed to minimize draw calls.</summary>
        </member>
        <member name="P:GvrControllerTooltipsSimple.ArmModel">
            <summary>Gets or sets the arm model used to position the controller.</summary>
            <value>The arm model used to position the controller.</value>
        </member>
        <member name="M:GvrControllerTooltipsSimple.OnVisualUpdate">
            <summary>Updates the tooltip visualation based on the arm model.</summary>
        </member>
        <member name="T:GvrControllerVisual">
            <summary>Provides visual feedback for the daydream controller.</summary>
        </member>
        <member name="F:GvrControllerVisual.APP_BUTTON_ACTIVE_DURATION_SECONDS">
            <summary>App button animation duration when pressed.</summary>
        </member>
        <member name="F:GvrControllerVisual.APP_BUTTON_RELEASE_DURATION_SECONDS">
            <summary>App button animation duration when released.</summary>
        </member>
        <member name="F:GvrControllerVisual.SYSTEM_BUTTON_ACTIVE_DURATION_SECONDS">
            <summary>System button animation duration when pressed.</summary>
        </member>
        <member name="F:GvrControllerVisual.SYSTEM_BUTTON_RELEASE_DURATION_SECONDS">
            <summary>System button animation duration when released.</summary>
        </member>
        <member name="F:GvrControllerVisual.TOUCHPAD_CLICK_DURATION_SECONDS">
            <summary>Touchpad animation duration when pressed.</summary>
        </member>
        <member name="F:GvrControllerVisual.TOUCHPAD_RELEASE_DURATION_SECONDS">
            <summary>Touchpad animation duration when released.</summary>
        </member>
        <member name="F:GvrControllerVisual.TOUCHPAD_CLICK_SCALE_DURATION_SECONDS">
            @deprecated
            <summary>This value controls scaling animation times for the touchpad button.</summary>
        </member>
        <member name="F:GvrControllerVisual.TOUCHPAD_POINT_SCALE_DURATION_SECONDS">
            <summary>
            Duration of the visual bubble on the controller to grow to its full size when clicked.
            </summary>
        </member>
        <member name="F:GvrControllerVisual.readControllerState">
            <summary>Determines if the displayState is set from `GvrControllerInputDevice`.</summary>
        </member>
        <member name="F:GvrControllerVisual.displayState">
            <summary>Used to set the display state of the controller visual.</summary>
            <remarks>
            This can be used for tutorials that visualize the controller or other use-cases that require
            displaying the controller visual without the state being determined by controller input.
            Additionally, it can be used to preview the controller visual in the editor.
            <para>
            NOTE: `readControllerState` must be disabled to set the display state.
            </para></remarks>
        </member>
        <member name="F:GvrControllerVisual.maximumAlpha">
            <summary>
            This is the preferred, maximum alpha value the object should have when it is a comfortable
            distance from the head.
            </summary>
        </member>
        <member name="F:GvrControllerVisual.attachmentPrefabs">
            <summary>
            An array of prefabs that will be instantiated and added as children of the controller visual
            when the controller is created.
            </summary>
            <remarks>
            Used to attach tooltips or other additional visual elements to the control dynamically.
            </remarks>
        </member>
        <member name="P:GvrControllerVisual.ArmModel">
            <summary>Gets or sets the arm model used to position the controller.</summary>
            <value>The arm model used to position the controller.</value>
        </member>
        <member name="P:GvrControllerVisual.ControllerInputDevice">
            <summary>Gets or sets the controller device reference.</summary>
            <value>The controller device reference.</value>
        </member>
        <member name="P:GvrControllerVisual.PreferredAlpha">
            <summary>Gets the preferred alpha value for the controller.</summary>
            <value>The preferred alpha value for the controller.</value>
        </member>
        <member name="P:GvrControllerVisual.TouchPadColor">
            <summary>Gets or sets the color of the touch pad.</summary>
            <value>The color of the touch pad.</value>
        </member>
        <member name="P:GvrControllerVisual.AppButtonColor">
            <summary>Gets or sets the color of the app button.</summary>
            <value>The color of the app button.</value>
        </member>
        <member name="P:GvrControllerVisual.SystemButtonColor">
            <summary>Gets or sets the color of the system button.</summary>
            <value>The color of the system button.</value>
        </member>
        <member name="M:GvrControllerVisual.SetControllerTexture(UnityEngine.Texture)">
            <summary>Sets the controller texture.</summary>
            <param name="newTexture">The new texture to set.</param>
        </member>
        <member name="M:GvrControllerVisual.GetVisualAssets">
            <summary>Override this method to customize the visual's assets.</summary>
            <remarks>
            This method is called once per frame in the visual update process.  Call the base method to
            get the current assets.
            </remarks>
            <returns>A new struct containing the visual assets.</returns>
        </member>
        <member name="T:GvrControllerVisual.ControllerDisplayState">
            <summary>The controller display state data structure.</summary>
        </member>
        <member name="F:GvrControllerVisual.ControllerDisplayState.batteryLevel">
            <summary>The battery charge level.</summary>
        </member>
        <member name="F:GvrControllerVisual.ControllerDisplayState.batteryCharging">
            <summary>True if the battery is charging.</summary>
        </member>
        <member name="F:GvrControllerVisual.ControllerDisplayState.clickButton">
            <summary>True if the touch pad button is down.</summary>
        </member>
        <member name="F:GvrControllerVisual.ControllerDisplayState.appButton">
            <summary>True if the app button is down.</summary>
        </member>
        <member name="F:GvrControllerVisual.ControllerDisplayState.homeButton">
            <summary>True if the system button is down.</summary>
        </member>
        <member name="F:GvrControllerVisual.ControllerDisplayState.touching">
            <summary>True if the controller touch pad is registering a touch.</summary>
        </member>
        <member name="F:GvrControllerVisual.ControllerDisplayState.touchPos">
            <summary>The touch position on the touch pad (if `touching` is `true`).</summary>
        </member>
        <member name="T:GvrControllerVisual.VisualAssets">
            <summary>
            Struct that describes a mesh, material pair used for rendering a controller visual.
            </summary>
        </member>
        <member name="F:GvrControllerVisual.VisualAssets.mesh">
            @cond
            <summary>The mesh.</summary>
        </member>
        <member name="F:GvrControllerVisual.VisualAssets.material">
            <summary>The material.</summary>
        </member>
        <member name="T:GvrDaydreamApi">
            <summary>Main entry point Daydream specific APIs.</summary>
            <remarks>
            This class automatically instantiates an instance when this API is used for the first time.
            For explicit control over when the instance is created and the Java references are setup
            call the provided `CreateAsync` method, for example when no UI is being displayed to the user.
            </remarks>
        </member>
        <member name="P:GvrDaydreamApi.IsCreated">
            <summary>Gets a value indicating whether the `GvrDaydreamApi` has been created.</summary>
            <value>Value `true` if the GvrDaydreamApi has been created, `false` otherwise.</value>
        </member>
        <member name="M:GvrDaydreamApi.Create">
            @deprecated Create() without arguments is deprecated. Use CreateAsync(callback) instead.
            <summary>Creates a generic asynchronous callback.</summary>
        </member>
        <member name="M:GvrDaydreamApi.CreateAsync(System.Action{System.Boolean})">
            <summary>Asynchronously instantiates a `GvrDayreamApi`.</summary>
            <remarks>
            The provided callback will be called with a bool argument indicating whether instance
            creation was successful.
            </remarks>
            <param name="callback">A callback to make after creating a `GvrDaydreamApi`.</param>
        </member>
        <member name="M:GvrDaydreamApi.LaunchVrHome">
            @deprecated Use `LaunchVrHomeAsync(callback)` instead.
            <summary>Launches a generic asynchronous VR Home call.</summary>
        </member>
        <member name="M:GvrDaydreamApi.LaunchVrHomeAsync(System.Action{System.Boolean})">
            <summary>Asynchronously launches VR Home.</summary>
            <remarks><para>
            Instantiates an instance of GvrDaydreamApi if necessary. If successful, launches VR Home.
            </para><para>
            The provided callback will be called with a bool argument indicating whether instance
            creation and launch of VR Home was successful.
            </para></remarks>
            <param name="callback">A callback to make after launching the VrHome screen.</param>
        </member>
        <member name="M:GvrDaydreamApi.Dispose">
            @cond
            <summary>Call Dispose to free up memory used by this API.</summary>
        </member>
        <member name="M:GvrDaydreamApi.EnsureCreated(System.Action{System.Boolean})">
            @endcond
            <summary>Ensures that the Daydream Api has been created.</summary>
            <param name="callback">The callback to make upon completion.</param>
        </member>
        <member name="T:GvrDropdown">
            <summary>Dropdown UI component that works with the GvrRaycasters.</summary>
            <remarks>
            This is a workaround for the fact that the Dropdown component doesn't work with custom
            raycasters because it internally adds two GraphicRaycasters.
            </remarks>
        </member>
        <member name="M:GvrDropdown.OnPointerClick(UnityEngine.EventSystems.PointerEventData)">
            <inheritdoc/>
        </member>
        <member name="M:GvrDropdown.OnSubmit(UnityEngine.EventSystems.BaseEventData)">
            <inheritdoc/>
        </member>
        <member name="M:GvrDropdown.CreateBlocker(UnityEngine.Canvas)">
            <inheritdoc/>
        </member>
        <member name="M:GvrDropdown.CreateDropdownList(UnityEngine.GameObject)">
            <inheritdoc/>
        </member>
        <member name="T:GvrEditorEmulator">
            <summary>Provides mouse-controlled head tracking emulation in the Unity editor.</summary>
        </member>
        <member name="P:GvrEditorEmulator.Instance">
            <summary>Gets the instance for this singleton class.</summary>
            <value>The instance for this singleton class.</value>
        </member>
        <member name="P:GvrEditorEmulator.HeadPosition">
            <summary>Gets the emulated head position.</summary>
            <value>The emulated head position.</value>
        </member>
        <member name="P:GvrEditorEmulator.HeadRotation">
            <summary>Gets the emulated head rotation.</summary>
            <value>The emulated head rotation.</value>
        </member>
        <member name="M:GvrEditorEmulator.Recenter">
            <summary>Recenters the emulated headset.</summary>
        </member>
        <member name="M:GvrEditorEmulator.UpdateEditorEmulation">
            <summary>Single-frame updates for this module.</summary>
            <remarks>Should be called in one MonoBehavior's `Update` method.</remarks>
        </member>
        <member name="T:GvrErrorType">
            <summary>Maps to `gvr_error` in the C API.</summary>
        </member>
        <member name="F:GvrErrorType.None">
            <summary>A default value indicating that no error has occurred.</summary>
        </member>
        <member name="F:GvrErrorType.ControllerCreateFailed">
            <summary>Indicates that a controller could not be created.</summary>
        </member>
        <member name="F:GvrErrorType.NoFrameAavilable">
            <summary>Indicates that a frame is unavailable for render.</summary>
        </member>
        <member name="F:GvrErrorType.NoEventAvailable">
            <summary>Indicates that no events have been received.</summary>
        </member>
        <member name="F:GvrErrorType.NoPropertyAvailable">
            <summary>Indicates that no properties have been received.</summary>
        </member>
        <member name="T:GvrEventExecutor">
            <summary>Wraps `UnityEngine.EventSystems.ExecuteEvents`.</summary>
            <remarks>Also, exposes event delegates to allow global handling of events.</remarks>
        </member>
        <member name="F:GvrEventExecutor.eventTable">
            <summary>Stores delegates for events.</summary>
        </member>
        <member name="M:GvrEventExecutor.#ctor">
            <summary>Initializes a new instance of the <see cref="T:GvrEventExecutor" /> class.</summary>
        </member>
        <member name="T:GvrEventExecutor.EventDelegate">
            <summary>Delegate type for handling pointer events.</summary>
            <param name="target">The GameObject to add this behavior to.</param>
            <param name="eventData">The context data of the Event which triggered this call.</param>
        </member>
        <member name="E:GvrEventExecutor.OnPointerClick">
            <summary>Adds or removes delegate functions for the `OnPointerClick` event.</summary>
        </member>
        <member name="E:GvrEventExecutor.OnPointerDown">
            <summary>Adds or removes delegate functions for the `OnPointerDown` event.</summary>
        </member>
        <member name="E:GvrEventExecutor.OnPointerUp">
            <summary>Adds or removes delegate functions for the `OnPointerUp` event.</summary>
        </member>
        <member name="E:GvrEventExecutor.OnPointerEnter">
            <summary>Adds or removes delegate functions for the `OnPointerEnter` event.</summary>
        </member>
        <member name="E:GvrEventExecutor.OnPointerExit">
            <summary>Adds or removes delegate functions for the `OnPointerExit` event.</summary>
        </member>
        <member name="E:GvrEventExecutor.OnScroll">
            <summary>Adds or removes delegate functions for the `OnScroll` event.</summary>
        </member>
        <member name="M:GvrEventExecutor.Execute``1(UnityEngine.GameObject,UnityEngine.EventSystems.BaseEventData,UnityEngine.EventSystems.ExecuteEvents.EventFunction{``0})">
            <summary>Execute the specified target, eventData and functor.</summary>
            <param name="target">The `GameObject` to execute this event behavior on.</param>
            <param name="eventData">The triggering EventData.</param>
            <param name="functor">The delegate call's implementation.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
            <returns>Returns `true` if the method successfully executes, `false` otherwise.</returns>
        </member>
        <member name="M:GvrEventExecutor.ExecuteHierarchy``1(UnityEngine.GameObject,UnityEngine.EventSystems.BaseEventData,UnityEngine.EventSystems.ExecuteEvents.EventFunction{``0})">
            <summary>Executes the hierarchy.</summary>
            <returns>The hierarchy.</returns>
            <param name="root">The top-level object this event should trigger.</param>
            <param name="eventData">The triggering EventData.</param>
            <param name="callbackFunction">Callback function.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:GvrEventExecutor.GetEventHandler``1(UnityEngine.GameObject)">
            <summary>Gets the event handler.</summary>
            <returns>The event handler.</returns>
            <param name="root">The top-level object this event should trigger.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="T:GvrEventType">
            <summary>Maps to `gvr_event_type` in the C API.</summary>
        </member>
        <member name="F:GvrEventType.Invalid">
            <summary>Not in the C API.</summary>
        </member>
        <member name="F:GvrEventType.Recenter">
            <summary>Indicates that the recenter event is occurring.</summary>
        </member>
        <member name="F:GvrEventType.SafetyRegionExit">
            <summary>Indicates that the headset has left the safety region.</summary>
        </member>
        <member name="F:GvrEventType.SafetyRegionEnter">
            <summary>Indicates that the headset has reentered the safety region.</summary>
        </member>
        <member name="T:GvrExecuteEventsExtension">
            <summary>
            This script extends the standard Unity `EventSystem` events with GVR-specific events.
            </summary>
        </member>
        <member name="P:GvrExecuteEventsExtension.pointerHoverHandler">
            <summary>Gets a handler for hover events.</summary>
            <value>A handler for hover events.</value>
        </member>
        <member name="T:GvrHeadset">
            <summary>Main entry point for Standalone headset APIs.</summary>
            <remarks>
            To use this API, use the GvrHeadset prefab. There can be only one such prefab in a scene, since
            this is a singleton object.
            </remarks>
        </member>
        <member name="F:GvrHeadset.editorSupportsPositionalHeadTracking">
            <summary>Whether this app supports Positional Head Tracking in editor play mode.</summary>
            <remarks>
            This is a user-controlled field which can be toggled in the inspector for the GvrHeadset.
            Its value is ignored if there is a connected device running Instant Preview.
            </remarks>
        </member>
        <member name="M:GvrHeadset.#ctor">
            <summary>Initializes a new instance of the <see cref="T:GvrHeadset" /> class.</summary>
        </member>
        <member name="T:GvrHeadset.OnSafetyRegionEvent">
            <summary>
            This delegate is called when the headset crosses the safety region boundary.
            </summary>
            <param name="enter">
            Set to `true` if the safety region is being entered, or `false` if the safety region is
            being exited.
            </param>
        </member>
        <member name="T:GvrHeadset.OnRecenterEvent">
            <summary>This delegate is called after the headset is recentered.</summary>
            <param name="recenterType">Indicates the reason recentering occurred.</param>
            <param name="recenterFlags">Flags related to recentering.  See |GvrRecenterFlags|.</param>
            <param name="recenteredPosition">The positional offset from the session start pose.</param>
            <param name="recenteredOrientation">
            The rotational offset from the session start pose.
            </param>
        </member>
        <member name="E:GvrHeadset.OnSafetyRegionChange">
            <summary>Event handlers for `OnSafetyRegionChange`.</summary>
            <remarks>Triggered when the safety region has been entered or exited.</remarks>
        </member>
        <member name="E:GvrHeadset.OnRecenter">
            <summary>Event handlers for `OnRecenter`.</summary>
            <remarks>Triggered when a recenter command has been issued by the user.</remarks>
        </member>
        <member name="P:GvrHeadset.SupportsPositionalTracking">
            <summary>
            Gets a value indicating whether this headset supports 6DoF positional tracking.
            </summary>
            <value>
            Value `true` if this headset supports 6DoF positional tracking, or `false` if only 3DoF
            rotation-based head tracking is supported.
            </value>
        </member>
        <member name="P:GvrHeadset.ProvidesEditorEmulator">
            <summary>
            Gets a value indicating whether this headset provides an Editor Emulator.
            </summary>
            <value>
            Value `true` if this headset provides an Editor Emulator, or `false` otherwise.
            </value>
        </member>
        <member name="M:GvrHeadset.TryGetFloorHeight(System.Single@)">
            <summary>Populates `floorHeight` with the detected height, if one is available.</summary>
            <remarks>This may be unavailable if the underlying GVR API call fails.</remarks>
            <returns>
            Returns `true` if value retrieval was successful, `false` otherwise (depends on tracking
            state).
            </returns>
            <param name="floorHeight">
            If this call returns `true`, this value is set to the retrieved `floorHeight`.  Otherwise
            leaves the value unchanged.
            </param>
        </member>
        <member name="M:GvrHeadset.TryGetRecenterTransform(UnityEngine.Vector3@,UnityEngine.Quaternion@)">
            <summary>
            Populates position and rotation with the last recenter transform, if one is available.
            </summary>
            <remarks>This may be unavailable if the underlying GVR API call fails.</remarks>
            <returns>Returns `true` if value retrieval was successful, `false` otherwise.</returns>
            <param name="position">
            If this call returns `true`, this value is set to the retrieved position.
            </param>
            <param name="rotation">
            If this call returns `true`, this value is set to the retrieved rotation.
            </param>
        </member>
        <member name="M:GvrHeadset.TryGetSafetyRegionType(GvrSafetyRegionType@)">
            <summary>Populates `safetyType` with the safety region type, if one is available.</summary>
            <remarks>
            Populates `safetyType` with the available safety region feature on the currently-running
            device.  This may be unavailable if the underlying GVR API call fails.
            </remarks>
            <returns>Returns `true` if value retrieval was successful, `false` otherwise.</returns>
            <param name="safetyType">
            If this call returns `true`, this value is set to the retrieved `safetyType`.
            </param>
        </member>
        <member name="M:GvrHeadset.TryGetSafetyCylinderInnerRadius(System.Single@)">
            <summary>
            Populates `innerRadius` with the safety cylinder inner radius, if one is available.
            </summary>
            <remarks>
            This is the radius at which safety management (e.g. safety fog) may cease taking effect.
            <para>
            If the safety region is of type `GvrSafetyRegionType.Cylinder`, populates `innerRadius` with
            the inner radius size of the safety cylinder in meters.  Before using, confirm that the
            safety region type is `GvrSafetyRegionType.Cylinder`.  This may be unavailable if the
            underlying GVR API call fails.
            </para></remarks>
            <returns>Returns `true` if value retrieval was successful, `false` otherwise.</returns>
            <param name="innerRadius">
            If this call returns `true`, this value is set to the retrieved `innerRadius`.
            </param>
        </member>
        <member name="M:GvrHeadset.TryGetSafetyCylinderOuterRadius(System.Single@)">
            <summary>
            Populates `outerRadius` with the safety cylinder outer radius, if one is available.
            </summary>
            <remarks>
            If the safety region is of type `GvrSafetyRegionType.Cylinder`, populates `outerRadius` with
            the outer radius size of the safety cylinder in meters.  Before using, confirm that the
            safety region type is `GvrSafetyRegionType.Cylinder`.  This may be unavailable if the
            underlying GVR API call fails.
            <para>
            This is the radius at which safety management (e.g. safety fog) may start to take effect.
            </para></remarks>
            <returns>Returns `true` if value retrieval was successful, `false` otherwise.</returns>
            <param name="outerRadius">
            If this call returns `true`, this value is set to the retrieved `outerRadius`.
            </param>
        </member>
        <member name="T:GvrInfo">
            <summary>
            Use to display an Info box in the inspector for a Monobehaviour or ScriptableObject.
            </summary>
        </member>
        <member name="F:GvrInfo.text">
            <summary>The text which should be displayed in the Info box.</summary>
        </member>
        <member name="F:GvrInfo.numLines">
            <summary>The number of lines the Info box should display.</summary>
        </member>
        <member name="F:GvrInfo.messageType">
            <summary>The message type of this info.</summary>
            <remarks>A Unity builtin, e.g. Info, Warning, Error.</remarks>
        </member>
        <member name="M:GvrInfo.#ctor(System.String,System.Int32,UnityEditor.MessageType)">
            <summary>Initializes a new instance of the <see cref="T:GvrInfo" /> class.</summary>
            <param name="text">The text.</param>
            <param name="numLines">The number of lines.</param>
            <param name="messageType">The message type.</param>
        </member>
        <member name="T:GvrInfoDrawer">
            <summary>Use to draw a `GvrInfo` in the inspector.</summary>
        </member>
        <member name="M:GvrInfoDrawer.GetHeightForLines(System.Int32)">
            <summary>Calculates the height for an Info box based on number of lines.</summary>
            <param name="numLines">The number of lines.</param>
            <returns>A height.</returns>
        </member>
        <member name="M:GvrInfoDrawer.Draw(UnityEngine.Rect,System.String,UnityEditor.MessageType)">
            @cond
            <summary>A DecoratorDrawer builtin to draw an Info box.</summary>
            <param name="position">The position to draw the Info box.</param>
            <param name="text">The text to write in the Info box.</param>
            <param name="messageType">The message type of the Info box.</param>
        </member>
        <member name="M:GvrInfoDrawer.GetHeight">
            @endcond
            @cond
            <inheritdoc/>
        </member>
        <member name="M:GvrInfoDrawer.OnGUI(UnityEngine.Rect)">
            @endcond
            @cond
            <summary>A MonoBehavior builtin to draw the Info box on GUI render.</summary>
            <param name="position">The position of the Info box.</param>
        </member>
        <member name="T:GvrIntent">
            <summary>
            Provides information about the Android Intent that started the current Activity.
            </summary>
        </member>
        <member name="M:GvrIntent.GetData">
            <summary>
            Returns the string representation of the data URI on which this activity's intent is
            operating.
            </summary>
            <remarks>See `Intent.getDataString()` in the Android documentation.</remarks>
            <returns>
            The `string` representation of the data URI on which this activity's intent is operating.
            </returns>
        </member>
        <member name="M:GvrIntent.IsLaunchedFromVr">
            <summary>
            Checks whether the intent category contains "android.intent.extra.VR_LAUNCH".
            </summary>
            <returns>
            Returns `true` if the intent category contains "android.intent.extra.VR_LAUNCH", `false`
            otherwise.
            </returns>
        </member>
        <member name="M:GvrIntent.GetIntentHashCode">
            <summary>Returns the hash code of the Java intent object.</summary>
            <remarks>Useful for discerning whether you have a new intent on un-pause.</remarks>
            <returns>The hash code of the Java intent object.</returns>
        </member>
        <member name="T:GvrKeyboardEvent">
            <summary>Events to update the keyboard.</summary>
            <remarks>These values depend on C API keyboard values.</remarks>
        </member>
        <member name="F:GvrKeyboardEvent.GVR_KEYBOARD_ERROR_UNKNOWN">
            <summary>Unknown error.</summary>
        </member>
        <member name="F:GvrKeyboardEvent.GVR_KEYBOARD_ERROR_SERVICE_NOT_CONNECTED">
            <summary>The keyboard service could not be connected.</summary>
            <remarks>This is usually due to the keyboard service not being installed.</remarks>
        </member>
        <member name="F:GvrKeyboardEvent.GVR_KEYBOARD_ERROR_NO_LOCALES_FOUND">
            <summary>No locale was found in the keyboard service.</summary>
        </member>
        <member name="F:GvrKeyboardEvent.GVR_KEYBOARD_ERROR_SDK_LOAD_FAILED">
            <summary>The keyboard service tried to load dynamically but failed.</summary>
            <remarks>
            This is usually due to the keyboard service not being installed or being out of date.
            </remarks>
        </member>
        <member name="F:GvrKeyboardEvent.GVR_KEYBOARD_SHOWN">
            <summary>Keyboard becomes visible.</summary>
        </member>
        <member name="F:GvrKeyboardEvent.GVR_KEYBOARD_HIDDEN">
            <summary>Keyboard becomes hidden.</summary>
        </member>
        <member name="F:GvrKeyboardEvent.GVR_KEYBOARD_TEXT_UPDATED">
            <summary>Text has been updated.</summary>
        </member>
        <member name="F:GvrKeyboardEvent.GVR_KEYBOARD_TEXT_COMMITTED">
            <summary>Text has been committed.</summary>
        </member>
        <member name="T:GvrKeyboardError">
            <summary>Keyboard error codes.</summary>
            <remarks>These values depend on C API keyboard values.</remarks>
        </member>
        <member name="F:GvrKeyboardError.UNKNOWN">
            <summary>Unknown error.</summary>
        </member>
        <member name="F:GvrKeyboardError.SERVICE_NOT_CONNECTED">
            <summary>The keyboard service could not be connected.</summary>
            <remarks>This is usually due to the keyboard service not being installed.</remarks>
        </member>
        <member name="F:GvrKeyboardError.NO_LOCALES_FOUND">
            <summary>No locale was found in the keyboard service.</summary>
        </member>
        <member name="F:GvrKeyboardError.SDK_LOAD_FAILED">
            <summary>The keyboard service tried to load dynamically but failed.</summary>
            <remarks>
            This is usually due to the keyboard service not being installed or being out of date.
            </remarks>
        </member>
        <member name="T:GvrKeyboardInputMode">
            <summary>The keyboard input modes.</summary>
            <remarks>These values depend on C API keyboard values.</remarks>
        </member>
        <member name="F:GvrKeyboardInputMode.DEFAULT">
            <summary>A default input mode.</summary>
            <remarks>For typing letters.</remarks>
        </member>
        <member name="F:GvrKeyboardInputMode.NUMERIC">
            <summary>Indicates a numeric input mode.</summary>
            <remarks>For typing numbers and symbols.</remarks>
        </member>
        <member name="T:GvrKeyboard">
            <summary>
            Handles keyboard state management such as hiding and displaying the keyboard, directly modifying
            text and stereoscopic rendering.
            </summary>
        </member>
        <member name="F:GvrKeyboard.keyboardDelegate">
            <summary>Delegate to handle keyboard events and input.</summary>
        </member>
        <member name="F:GvrKeyboard.inputMode">
            <summary>The input mode of the keyboard.</summary>
        </member>
        <member name="F:GvrKeyboard.useRecommended">
            <summary>Flag to use the recommended world matrix for the keyboard.</summary>
        </member>
        <member name="F:GvrKeyboard.distance">
            <summary>The distance to the keyboard.</summary>
        </member>
        <member name="T:GvrKeyboard.StandardCallback">
            <summary>Standard keyboard delegate type.</summary>
        </member>
        <member name="T:GvrKeyboard.EditTextCallback">
            <summary>Edit text keyboard delegate type.</summary>
            <param name="edit_text">The edited text which has been typed into the keyboard.</param>
        </member>
        <member name="T:GvrKeyboard.ErrorCallback">
            <summary>Keyboard error delegate type.</summary>
            <param name="err">The error which raised this callback.</param>
        </member>
        <member name="T:GvrKeyboard.KeyboardCallback">
            <summary>Keyboard delegate type.</summary>
            <param name="closure">A closure around the method to call.</param>
            <param name="evt">The event which prompted this callback.</param>
        </member>
        <member name="P:GvrKeyboard.EditorText">
            <summary>Gets or sets the text being affected by this keyboard.</summary>
            <value>The text being affected by this keyboard.</value>
        </member>
        <member name="P:GvrKeyboard.Mode">
            <summary>Gets the current input mode of the keyboard.</summary>
            <value>The current input mode of the keyboard.</value>
        </member>
        <member name="P:GvrKeyboard.IsValid">
            <summary>Gets a value indicating whether this keyboard instance is valid.</summary>
            <value>Value `true` if this keyboard instance is valid, `false` otherwise.</value>
        </member>
        <member name="P:GvrKeyboard.IsReady">
            <summary>Gets a value indicating whether this keyboard is ready.</summary>
            <value>Value `true` if this keyboard is ready, `false` otherwise.</value>
        </member>
        <member name="P:GvrKeyboard.WorldMatrix">
            <summary> Gets the world matrix of the keyboard.</summary>
            <value>The world matrix of the keyboard.</value>
        </member>
        <member name="M:GvrKeyboard.ClearText">
            <summary>Resets keyboard text.</summary>
        </member>
        <member name="M:GvrKeyboard.Show">
            <summary>Shows the keyboard.</summary>
        </member>
        <member name="M:GvrKeyboard.Hide">
            <summary>Hides the keyboard.</summary>
        </member>
        <member name="M:GvrKeyboard.OnPointerClick(UnityEngine.EventSystems.BaseEventData)">
            <summary>Handle a pointer click on the keyboard.</summary>
            <param name="data">The event data associated with this callback.</param>
        </member>
        <member name="T:GvrKeyboardDelegateBase">
            <summary>An abstract interface for `GvrKeyboard` methods.</summary>
            <remarks><para>
            An abstract class instead of an interface so that it can be exposed in Unity's editor.
            </para><para>
            It inherits from `MonoBehaviour` so that it can be directly used as a game object.
            </para></remarks>
        </member>
        <member name="E:GvrKeyboardDelegateBase.KeyboardHidden">
            <summary>Event for the keyboard being hidden.</summary>
        </member>
        <member name="E:GvrKeyboardDelegateBase.KeyboardShown">
            <summary>Event for the keyboard being shown.</summary>
        </member>
        <member name="M:GvrKeyboardDelegateBase.OnKeyboardShow">
            <summary>Called to show the keyboard.</summary>
        </member>
        <member name="M:GvrKeyboardDelegateBase.OnKeyboardHide">
            <summary>Called to hide the keyboard.</summary>
        </member>
        <member name="M:GvrKeyboardDelegateBase.OnKeyboardUpdate(System.String)">
            <summary>Called to update the keyboard.</summary>
            <param name="edit_text">The current text for the keyboard.</param>
        </member>
        <member name="M:GvrKeyboardDelegateBase.OnKeyboardEnterPressed(System.String)">
            <summary>Called when the ENTER key is pressed on the keyboard.</summary>
            <param name="edit_text">The current text for the keyboard.</param>
        </member>
        <member name="M:GvrKeyboardDelegateBase.OnKeyboardError(GvrKeyboardError)">
            <summary>Called when there is an error with the keyboard.</summary>
            <param name="errorCode">The code of the error encountered.</param>
        </member>
        <member name="T:GvrKeyboardIntent">
            <summary>A class for launching and managing GVR keyboard intents.</summary>
        </member>
        <member name="P:GvrKeyboardIntent.Instance">
            <summary>
            Gets the singleton instance of the `PermissionsRequester` class, lazily instantiated.
            </summary>
            <value>A singleton instance the `PermissionsRequester` class.</value>
        </member>
        <member name="M:GvrKeyboardIntent.LaunchPlayStore">
            <summary>Start the intent to launch the Play Store.</summary>
        </member>
        <member name="M:GvrKeyboardIntent.InitializeFragment">
            <summary>Initializes the fragment via JNI.</summary>
            <returns>True if fragment was initialized.</returns>
        </member>
        <member name="T:GvrKeyboardIntent.KeyboardCallback">
            <summary>Keyboard callback implementation.</summary>
            <remarks>
            Instances of this class are passed to the java fragment and then invoked once the request
            process is completed by the user.
            </remarks>
        </member>
        <member name="M:GvrKeyboardIntent.KeyboardCallback.onPlayStoreResult">
            <summary>Called when then flow is completed.</summary>
        </member>
        <member name="T:GvrLaserPointer">
            <summary>Implementation of GvrBasePointer for a laser pointer visual.</summary>
            <remarks>
            This script should be attached to the controller object. The laser visual is important to help
            users locate their cursor when its not directly in their field of view.
            </remarks>
        </member>
        <member name="F:GvrLaserPointer.maxPointerDistance">
            <summary>Maximum distance from the pointer that raycast hits will be detected.</summary>
        </member>
        <member name="F:GvrLaserPointer.defaultReticleDistance">
            <summary>
            Distance from the pointer that the reticle will be drawn at when hitting nothing.
            </summary>
        </member>
        <member name="F:GvrLaserPointer.overrideCameraRayIntersectionDistance">
            <summary>
            By default, the length of the laser is used as the CameraRayIntersectionDistance.
            </summary>
            <remarks>Set this field to a non-zero value to override it.</remarks>
        </member>
        <member name="F:GvrLaserPointer.RETICLE_VISUAL_RATIO">
            <summary>The percentage of the reticle mesh that shows the reticle.</summary>
            <remarks>The rest of the reticle mesh is transparent.</remarks>
        </member>
        <member name="P:GvrLaserPointer.LaserVisual">
            <summary>Gets the visual object for the laser beam.</summary>
            <value>The visual object for the laser beam.</value>
        </member>
        <member name="P:GvrLaserPointer.MaxPointerDistance">
            <inheritdoc/>
        </member>
        <member name="P:GvrLaserPointer.CameraRayIntersectionDistance">
            <inheritdoc/>
        </member>
        <member name="M:GvrLaserPointer.OnPointerEnter(UnityEngine.EventSystems.RaycastResult,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:GvrLaserPointer.OnPointerHover(UnityEngine.EventSystems.RaycastResult,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:GvrLaserPointer.OnPointerExit(UnityEngine.GameObject)">
            <inheritdoc/>
        </member>
        <member name="M:GvrLaserPointer.OnPointerClickDown">
            <inheritdoc/>
        </member>
        <member name="M:GvrLaserPointer.OnPointerClickUp">
            <inheritdoc/>
        </member>
        <member name="M:GvrLaserPointer.GetPointerRadius(System.Single@,System.Single@)">
            <inheritdoc/>
        </member>
        <member name="M:GvrLaserPointer.Start">
            @endcond
            @cond
            <inheritdoc/>
        </member>
        <member name="M:GvrLaserPointer.Awake">
            @cond
            <summary>This MonoBehavior's Awake method.</summary>
        </member>
        <member name="M:GvrLaserPointer.Update">
            @endcond
            <summary>This MonoBehavior's Update method.</summary>
        </member>
        <member name="T:GvrLaserVisual">
            <summary>Visualizes a laser and a reticle using a LineRenderer and a Quad.</summary>
            <remarks>
            Provides functions for settings the end point of the laser, and clamps the laser and reticle
            based on max distances.
            </remarks>
        </member>
        <member name="F:GvrLaserVisual.reticle">
            <summary>Used to position the reticle at the current position.</summary>
        </member>
        <member name="F:GvrLaserVisual.controller">
            <summary>The controller visual's transform.</summary>
            <remarks>
            The end point of the visual will not necessarily be along the forward direction of the
            laser. This is particularly true in both Camera and Hybrid Raycast Modes. In that case, both
            the laser and the controller are rotated to face the end point. This reference is used to
            control the rotation of the controller.
            </remarks>
        </member>
        <member name="F:GvrLaserVisual.laserColor">
            <summary>Color of the laser pointer including alpha transparency.</summary>
        </member>
        <member name="F:GvrLaserVisual.laserColorEnd">
            <summary>Color of the laser pointer including alpha transparency.</summary>
        </member>
        <member name="F:GvrLaserVisual.maxLaserDistance">
            <summary>Maximum distance of the laser (meters).</summary>
        </member>
        <member name="F:GvrLaserVisual.lerpSpeed">
            <summary>The rate that the current position moves towards the target position.</summary>
        </member>
        <member name="F:GvrLaserVisual.lerpThreshold">
            <summary>The threashold at which position change becomes immediate.</summary>
            <remarks>
            If the targetPosition is greater than this threshold, then the position changes immediately
            instead of lerping.
            </remarks>
        </member>
        <member name="F:GvrLaserVisual.shrinkLaser">
            <summary>
            This is primarily used for Hybrid Raycast mode (details in _GvrBasePointer_) to prevent
            mismatches between the laser and the reticle when the "camera" component of the ray is used.
            </summary>
        </member>
        <member name="F:GvrLaserVisual.shrunkScale">
            <summary>Amount to shrink the laser when it is fully shrunk.</summary>
        </member>
        <member name="F:GvrLaserVisual.beginShrinkAngleDegrees">
            <summary>
            Begin shrinking the laser when the angle between `transform.forward` and the reticle is
            greater than this value.
            </summary>
        </member>
        <member name="F:GvrLaserVisual.endShrinkAngleDegrees">
            <summary>
            Finish shrinking the laser when the angle between `transform.forward` and the reticle is
            greater than this value.
            </summary>
        </member>
        <member name="F:GvrLaserVisual.shrinkRatio">
            <summary>Ratio to shrink the visual by.</summary>
        </member>
        <member name="F:GvrLaserVisual.targetDistance">
            <summary>Distance to the target object.</summary>
        </member>
        <member name="F:GvrLaserVisual.currentDistance">
            <summary>Current distance to the visual.</summary>
        </member>
        <member name="F:GvrLaserVisual.currentPosition">
            <summary>Current world position of the visual.</summary>
        </member>
        <member name="F:GvrLaserVisual.currentLocalPosition">
            <summary>Current local position of the visual.</summary>
        </member>
        <member name="F:GvrLaserVisual.currentLocalRotation">
            <summary>Current local rotation of the visual.</summary>
        </member>
        <member name="T:GvrLaserVisual.GetPointForDistanceDelegate">
            <summary>
            Optional delegate for customizing how the currentPosition is calculated based on the
            distance.
            </summary>
            <remarks>
            If not set, the `currentPosition` is determined based on the distance multiplied by the
            forward direction of the transform added to the position of the transform.
            </remarks>
            <returns>
            Default: The distance mutliplied by the forwrad direction of the transform added to the
            position of the transform.
            Overridden: An implementation for calculating `currentPosition` from distance.
            </returns>
            <param name="distance">The distance to use in calculating the `currentPosition`.</param>
        </member>
        <member name="P:GvrLaserVisual.ArmModel">
            <summary>Gets or sets the arm model used to control the visual.</summary>
            <value>The arm model used to control the visual.</value>
        </member>
        <member name="P:GvrLaserVisual.Laser">
            <summary>Gets a reference to the laser's line renderer.</summary>
            <value>The laser's line renderer.</value>
        </member>
        <member name="P:GvrLaserVisual.GetPointForDistanceFunction">
            <summary>Gets or sets the function to use for determining the point at a distance.</summary>
            <value>The function to use for determining the point at a distance.</value>
        </member>
        <member name="P:GvrLaserVisual.CurrentDistance">
            <summary>Gets the current distance to the visual.</summary>
            <value>The current distance to the visual.</value>
        </member>
        <member name="M:GvrLaserVisual.SetDistance(System.Single,System.Boolean)">
            <summary>Set the distance of the laser.</summary>
            <remarks>Clamps the distance of the laser and reticle.</remarks>
            <param name="distance">Target distance from the pointer to draw the visual at.</param>
            <param name="immediate">
            If `true`, the distance is changed immediately. Otherwise, it will lerp.
            </param>
        </member>
        <member name="M:GvrLaserVisual.Awake">
            @cond
            <summary>The MonoBehavior's Awake method.</summary>
        </member>
        <member name="M:GvrLaserVisual.LateUpdate">
            @endcond
            @cond
            <summary>The MonoBehavior's Awake method.</summary>
        </member>
        <member name="M:GvrLaserVisual.UpdateCurrentPosition">
            @endcond
            <summary>Updates the current position of the visual.</summary>
        </member>
        <member name="M:GvrLaserVisual.UpdateControllerOrientation">
            <summary>
            Updates the rotation of  the controller based on the current local rotation.
            </summary>
        </member>
        <member name="M:GvrLaserVisual.UpdateReticlePosition">
            <summary> Updates the position of the reticle to the current position.</summary>
        </member>
        <member name="M:GvrLaserVisual.UpdateLaserEndPoint">
            <summary>Updates the endpoint of the laser based on max distance.</summary>
        </member>
        <member name="M:GvrLaserVisual.UpdateLaserAlpha">
            <summary>Updates the alpha of the laser beam.</summary>
        </member>
        <member name="M:GvrLaserVisual.GetSpeed">
            <summary>Gets the speed of the moving pointer visual.</summary>
            <returns>The lerp speed of the moving pointer visual.</returns>
        </member>
        <member name="T:GvrMathHelpers">
            <summary>Helper functions to perform common math operations for Gvr.</summary>
        </member>
        <member name="M:GvrMathHelpers.GetIntersectionPosition(UnityEngine.Camera,UnityEngine.EventSystems.RaycastResult)">
            <summary>Gets the intersection position of the camera and the raycast result.</summary>
            <param name="cam">The camera to use.</param>
            <param name="raycastResult">The result of the raycast to intersect with the camera.</param>
            <returns>The position of the intersection.</returns>
        </member>
        <member name="M:GvrMathHelpers.NormalizedCartesianToSpherical(UnityEngine.Vector3)">
            <summary>Normalizes a 3D Cartesian direction to a 2D spherical direction.</summary>
            <param name="cartCoords">The coordinates to normalize.</param>
            <returns>The spherical coordinates.</returns>
        </member>
        <member name="M:GvrMathHelpers.EaseOutCubic(System.Single,System.Single,System.Single)">
            <summary>A cubic easing function (https://easings.net/#easeOutCubic).</summary>
            <param name="min">The minimum output value.</param>
            <param name="max">The maximum output value.</param>
            <param name="value">The input to the easing function between 0 and 1.</param>
            <returns>The output of the easing function between (min) and (max).</returns>
        </member>
        <member name="M:GvrMathHelpers.GvrMatrixToUnitySpace(UnityEngine.Matrix4x4,UnityEngine.Vector3@,UnityEngine.Quaternion@)">
            <summary>Converts matrix from Google VR convention to Unity convention.</summary>
            <remarks>Google VR is row-major, RHS coordinates, and Unity is column-major, LHS.</remarks>
            <param name="gvrMatrix">The Google VR matrix data.</param>
            <param name="position">The position in Unity space based on the Google VR matrix.</param>
            <param name="orientation">The orientation in Unity space.</param>
        </member>
        <member name="M:GvrMathHelpers.ConvertFloatArrayToMatrix(System.Single[])">
            <summary>Converts a float array of length 16 into a column-major 4x4 matrix.</summary>
            <param name="floatArray">The array to convert to a matrix.</param>
            <returns>A column-major 4x4 matrix.</returns>
        </member>
        <member name="T:GvrPermissionsRequester">
            <summary>Requests dangerous permissions at runtime.</summary>
        </member>
        <member name="P:GvrPermissionsRequester.Instance">
            <summary>
            Gets the singleton instance of the `PermissionsRequester` class, lazily instantiated.
            </summary>
            <value>The singleton instance of this class, lazily instantiated.</value>
        </member>
        <member name="M:GvrPermissionsRequester.IsPermissionGranted(System.String)">
            <summary>Checks whether a given permission is granted.</summary>
            <param name="permission">The name of the permission to check.</param>
            <returns>Returns `true` if the permission is granted, `false` otherwise.</returns>
        </member>
        <member name="M:GvrPermissionsRequester.HasPermissionsGranted(System.String[])">
            <summary>Checks whether a given set of permission are granted.</summary>
            <param name="permissions">The names of the permissions to check.</param>
            <returns>Returns `true` if the permissions are all granted, `false` otherwise.</returns>
        </member>
        <member name="M:GvrPermissionsRequester.ShouldShowRational(System.String)">
            <summary>Checks whether the rationale for a given permission should be shown.</summary>
            <remarks>This should be called `ShouldShowRationale`.</remarks>
            <param name="permission">The name of the permission to check.</param>
            <returns>Returns `true` if the rationale should be shown, `false` otherwise.</returns>
        </member>
        <member name="M:GvrPermissionsRequester.RequestPermissions(System.String[],System.Action{GvrPermissionsRequester.PermissionStatus[]})">
            <summary>Requests a set of permissions.</summary>
            <param name="permissionArray">The names of the permissions to request.</param>
            <param name="callback">The callback to make when requesting permissions.</param>
        </member>
        <member name="M:GvrPermissionsRequester.InitializeFragment">
            <summary>Initializes the fragment via JNI.</summary>
            <returns>True if fragment was initialized.</returns>
        </member>
        <member name="T:GvrPermissionsRequester.PermissionStatus">
            <summary>A class representing a given permission's information and status.</summary>
        </member>
        <member name="M:GvrPermissionsRequester.PermissionStatus.#ctor(System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:GvrPermissionsRequester.PermissionStatus" /> class.
            </summary>
            <param name="name">The name of this permission.</param>
            <param name="granted">Whether this permission has been granted.</param>
        </member>
        <member name="P:GvrPermissionsRequester.PermissionStatus.Name">
            <summary>Gets or sets the name of this permission.</summary>
            <value>The name of this permission.</value>
        </member>
        <member name="P:GvrPermissionsRequester.PermissionStatus.Granted">
            <summary>Gets or sets a value indicating whether this permission is granted.</summary>
            <value>Value `true` if this permission is granted, `false` otherwise.</value>
        </member>
        <member name="T:GvrPermissionsRequester.PermissionsCallback">
            <summary>Permissions callback implementation.</summary>
            <remarks>
            Instances of this class are passed to the java fragment and then invoked once the request
            process is completed by the user.
            </remarks>
        </member>
        <member name="M:GvrPermissionsRequester.PermissionsCallback.onRequestPermissionResult(System.Boolean)">
            <summary>Called when then permission request flow is completed.</summary>
            <param name="allPermissionsGranted">Value `true` if all permissions granted.</param>
        </member>
        <member name="T:GvrPointerEventData">
            <summary>
            This script extends the Unity PointerEventData struct with GoogleVR-specific data.
            </summary>
        </member>
        <member name="F:GvrPointerEventData.gvrButtonsDown">
            <summary>The mask of buttons that are currently down.</summary>
        </member>
        <member name="M:GvrPointerEventData.#ctor(UnityEngine.EventSystems.EventSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:GvrPointerEventData" /> class.
            </summary>
            <param name="eventSystem">The event system associated with this event.</param>
        </member>
        <member name="T:GvrPointerEventDataExtension">
            <summary>
            This class extends the Unity `PointerEventData` struct with GoogleVR data accessors.
            </summary>
        </member>
        <member name="M:GvrPointerEventDataExtension.GvrGetButtonsDown(UnityEngine.EventSystems.PointerEventData)">
            <summary>
            Returns the `GvrControllerButton` mask of buttons that went down to trigger the event.
            </summary>
            <returns>
            The `GvrControllerButton` mask of buttons that went down to trigger the event.
            </returns>
            <param name="pointerEventData">Pointer event data.</param>
        </member>
        <member name="M:GvrPointerEventDataExtension.GvrGetControllerInputDevice(UnityEngine.EventSystems.PointerEventData)">
            <summary>Returns the `GvrControllerInputDevice` that triggered the event.</summary>
            <returns>The get controller input device.</returns>
            <param name="pointerEventData">Pointer event data.</param>
        </member>
        <member name="T:GvrPointerGraphicRaycaster">
            <summary>This script provides a raycaster for use with the `GvrPointerInputModule`.</summary>
            <remarks><para>
            This behaves similarly to the standards Graphic raycaster, except that it utilize raycast
            modes specifically for Gvr.
            </para><para>
            See `GvrBasePointerRaycaster.cs` and `GvrPointerInputModule.cs` for more details.
            </para></remarks>
        </member>
        <member name="F:GvrPointerGraphicRaycaster.ignoreReversedGraphics">
            <summary>Flag for ignoring reversed graphics direction.</summary>
        </member>
        <member name="F:GvrPointerGraphicRaycaster.blockingObjects">
            <summary>The type of objects which can block raycasts.</summary>
        </member>
        <member name="F:GvrPointerGraphicRaycaster.blockingMask">
            <summary>The blocking layer mask to use when raycasting.</summary>
        </member>
        <member name="M:GvrPointerGraphicRaycaster.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GvrPointerGraphicRaycaster" /> class.
            </summary>
        </member>
        <member name="T:GvrPointerGraphicRaycaster.BlockingObjects">
            <summary>Types of blocking objects this object's raycasts can hit.</summary>
        </member>
        <member name="F:GvrPointerGraphicRaycaster.BlockingObjects.None">
            <summary>This cannot hit any objects.</summary>
        </member>
        <member name="F:GvrPointerGraphicRaycaster.BlockingObjects.TwoD">
            <summary>This can hit only 2D objects.</summary>
        </member>
        <member name="F:GvrPointerGraphicRaycaster.BlockingObjects.ThreeD">
            <summary>This can hit only 3D objects.</summary>
        </member>
        <member name="F:GvrPointerGraphicRaycaster.BlockingObjects.All">
            <summary>This can hit all objects.</summary>
        </member>
        <member name="P:GvrPointerGraphicRaycaster.eventCamera">
            <summary>Gets the event Camera used for gaze-based raycasts.</summary>
            <value>The event camera.</value>
        </member>
        <member name="M:GvrPointerGraphicRaycaster.PerformRaycast(GvrBasePointer.PointerRay,System.Single,UnityEngine.EventSystems.PointerEventData,System.Collections.Generic.List{UnityEngine.EventSystems.RaycastResult})">
            <summary>Perform raycast on the scene.</summary>
            <param name="pointerRay">The ray to use for the operation.</param>
            <param name="radius">The radius of the ray to use when testing for hits.</param>
            <param name="eventData">The event data triggered by any resultant Raycast hits.</param>
            <param name="resultAppendList">The results are appended to this list.</param>
            <returns>Returns `true` if the Raycast has at least one hit, `false` otherwise.</returns>
        </member>
        <member name="T:GvrPointerInputModule">
            <summary>This script provides an implemention of Unity's `BaseInputModule` class.</summary>
            <remarks><para>
            Exists so that Canvas-based (`uGUI`) UI elements and 3D scene objects can be interacted with in
            a Gvr Application.
            </para><para>
            This script is intended for use with either a 3D Pointer with the Daydream Controller
            (Recommended for Daydream), or a Gaze-based-Pointer (Recommended for Cardboard).
            </para><para>
            To use, attach to the scene's **EventSystem** object.  Be sure to move it above the
            other modules, such as `TouchInputModule` and `StandaloneInputModule`, in order
            for the Pointer to take priority in the event system.
            </para><para>
            If you are using a **Canvas**, set the `Render Mode` to **World Space**, and add the
            `GvrPointerGraphicRaycaster` script to the object.
            </para><para>
            If you'd like pointers to work with 3D scene objects, add a `GvrPointerPhysicsRaycaster` to the
            main camera, and add a component that implements one of the `Event` interfaces (`EventTrigger`
            will work nicely) to an object with a collider.
            </para><para>
            `GvrPointerInputModule` emits the following events: `Enter`, `Exit`, `Down`, `Up`, `Click`,
            `Select`, `Deselect`, `UpdateSelected`, and `GvrPointerHover`.  Scroll, move, and submit/cancel
            events are not emitted.
            </para><para>
            To use a 3D Pointer with the Daydream Controller:
              - Add the prefab GoogleVR/Prefabs/UI/GvrControllerPointer to your scene.
              - Set the parent of `GvrControllerPointer` to the same parent as the main camera
                (With a local position of 0,0,0).
            </para><para>
            To use a Gaze-based-pointer:
              - Add the prefab GoogleVR/Prefabs/UI/GvrReticlePointer to your scene.
              - Set the parent of `GvrReticlePointer` to the main camera.
            </para></remarks>
        </member>
        <member name="F:GvrPointerInputModule.vrModeOnly">
            <summary>
            If `true`, pointer input is active in VR Mode only.
            If `false`, pointer input is active all of the time.
            </summary>
            <remarks>
            Set to false if you plan to use direct screen taps or other input when not in VR Mode.
            </remarks>
        </member>
        <member name="F:GvrPointerInputModule.scrollInput">
            <summary>Manages scroll events for the input module.</summary>
        </member>
        <member name="P:GvrPointerInputModule.Pointer">
            <summary>Gets or sets the static reference to the `GvrBasePointer`.</summary>
            <value>The static reference to the `GvrBasePointer`.</value>
        </member>
        <member name="P:GvrPointerInputModule.CurrentRaycastResult">
            <summary>Gets the current `RaycastResult`.</summary>
            <value>The current `RaycastResult`.</value>
        </member>
        <member name="P:GvrPointerInputModule.Impl">
            <summary>Gets the implementation object of this module.</summary>
            <value>The implementation object of this module.</value>
        </member>
        <member name="P:GvrPointerInputModule.EventExecutor">
            <summary>Gets the executor this module uses to process events.</summary>
            <value>The executor this module uses to process events.</value>
        </member>
        <member name="P:GvrPointerInputModule.eventSystem">
            <summary>Gets the event system reference.</summary>
            <value>The event system reference.</value>
        </member>
        <member name="P:GvrPointerInputModule.RaycastResultCache">
            <summary>Gets the list of raycast results used as a cache.</summary>
            <value>The list of raycast results used as a cache.</value>
        </member>
        <member name="M:GvrPointerInputModule.OnPointerCreated(GvrBasePointer)">
            <summary>The `GvrBasePointer` calls this when it is created.</summary>
            <remarks>
            If a pointer hasn't already been assigned, it will assign the newly created one by default.
            This simplifies the common case of having only one `GvrBasePointer` so it can be
            automatically hooked up to the manager.  If multiple `GvrBasePointers` are in the scene,
            the app has to take responsibility for setting which one is active.
            </remarks>
            <param name="createdPointer">The pointer whose creation triggered this call.</param>
        </member>
        <member name="M:GvrPointerInputModule.FindEventExecutor">
            <summary>
            Helper function to find the Event executor that is part of the input module if one exists
            in the scene.
            </summary>
            <returns>A found GvrEventExecutor or null.</returns>
        </member>
        <member name="M:GvrPointerInputModule.FindInputModule">
            <summary>
            Helper function to find the input module if one exists in the scene and it is the active
            module.
            </summary>
            <returns>A found `GvrPointerInputModule` or null.</returns>
        </member>
        <member name="M:GvrPointerInputModule.ShouldActivateModule">
            <inheritdoc/>
        </member>
        <member name="M:GvrPointerInputModule.DeactivateModule">
            <inheritdoc/>
        </member>
        <member name="M:GvrPointerInputModule.IsPointerOverGameObject(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:GvrPointerInputModule.Process">
            <inheritdoc/>
        </member>
        <member name="M:GvrPointerInputModule.ShouldActivate">
            <summary>Whether the module should be activated.</summary>
            <returns>Returns `true` if this module should be activated, `false` otherwise.</returns>
        </member>
        <member name="M:GvrPointerInputModule.Deactivate">
            <summary>Deactivate this instance.</summary>
        </member>
        <member name="M:GvrPointerInputModule.FindCommonRoot(UnityEngine.GameObject,UnityEngine.GameObject)">
            <summary>Finds the common root between two `GameObject`s.</summary>
            <returns>The common root.</returns>
            <param name="g1">The first `GameObject`.</param>
            <param name="g2">The second `GameObject`.</param>
        </member>
        <member name="M:GvrPointerInputModule.GetBaseEventData">
            <summary>Gets the base event data.</summary>
            <returns>The base event data.</returns>
        </member>
        <member name="M:GvrPointerInputModule.FindFirstRaycast(System.Collections.Generic.List{UnityEngine.EventSystems.RaycastResult})">
            <summary>Finds the first raycast.</summary>
            <returns>The first raycast.</returns>
            <param name="candidates">
            The list of `RaycastResult`s to search for the first Raycast.
            </param>
        </member>
        <member name="M:GvrPointerInputModule.Awake">
            @cond
            <inheritdoc/>
        </member>
        <member name="M:GvrPointerInputModule.UpdateImplProperties">
            @endcond
            <summary>Update implementation properties.</summary>
        </member>
        <member name="T:GvrPointerInputModuleImpl">
            <summary>Implementation of `GvrPointerInputModule`.</summary>
        </member>
        <member name="P:GvrPointerInputModuleImpl.ModuleController">
            <summary>Gets or sets an interface for controlling the actual input module.</summary>
            <value>The module controller interface for controlling the input module.</value>
        </member>
        <member name="P:GvrPointerInputModuleImpl.EventExecutor">
            <summary>Gets or sets an interface for executing events.</summary>
            <value>An event executor interface for executing events.</value>
        </member>
        <member name="P:GvrPointerInputModuleImpl.VrModeOnly">
            <summary>
            Gets or sets a value indicating whether the pointer input is active in VR Mode only or
            whether it is always active.
            </summary>
            <remarks>
            Set to false if you plan to use direct screen taps or other input when not in VR Mode.
            </remarks>
            <value>
            Set this to `true` to make input active only in VR Mode.  Set to `false` to make input
            active all of the time.
            </value>
        </member>
        <member name="P:GvrPointerInputModuleImpl.ScrollInput">
            <summary>
            Gets or sets the `GvrPointerScrollInput` used to route Scroll events through `EventSystem`.
            </summary>
            <value>The GvrPointerScrollInput used to route Scroll events through `EventSystem`.</value>
        </member>
        <member name="P:GvrPointerInputModuleImpl.CurrentEventData">
            <summary>
            Gets `PointerEventData` from the most recent frame.
            </summary>
            <value>The `PointerEventData` data from the most recent frame.</value>
        </member>
        <member name="P:GvrPointerInputModuleImpl.Pointer">
            <summary>
            Gets or sets the `GvrBasePointer` which will be responding to pointer events.
            </summary>
            <value>The `GvrBasePointer` which will be responding to pointer events.</value>
        </member>
        <member name="M:GvrPointerInputModuleImpl.ShouldActivateModule">
            <summary>
            Gets or sets a value indicating whether this module should be activated.
            </summary>
            <returns>Returns `true` if this module should be activated, `false` otherwise.</returns>
        </member>
        <member name="M:GvrPointerInputModuleImpl.DeactivateModule">
            <summary>Deactivates this input module.</summary>
        </member>
        <member name="M:GvrPointerInputModuleImpl.IsPointerOverGameObject(System.Int32)">
            <summary>Determines whether the pointer is over a game object.</summary>
            <returns>
            Returns `true` if this instance is pointer over game object the specified `pointerId`.
            Returns `false` otherwise.
            </returns>
            <param name="pointerId">The pointer id to check.</param>
        </member>
        <member name="M:GvrPointerInputModuleImpl.Process">
            <summary>Process the input for the current frame.</summary>
        </member>
        <member name="T:GvrPointerPhysicsRaycaster">
            <summary>This script provides a raycaster for use with the `GvrPointerInputModule`.</summary>
            <remarks><para>
            It behaves similarly to the standards Physics raycaster, except that it utilize raycast
            modes specifically for Gvr.
            </para><para>
            View `GvrBasePointerRaycaster.cs` and `GvrPointerInputModule.cs` for more details.
            </para></remarks>
        </member>
        <member name="F:GvrPointerPhysicsRaycaster.NO_EVENT_MASK_SET">
            <summary>Const to use for clarity when no event mask is set.</summary>
        </member>
        <member name="F:GvrPointerPhysicsRaycaster.raycasterEventMask">
            <summary>
            Layer mask used to filter events. Always combined with the camera's culling mask if a camera
            is used.
            </summary>
        </member>
        <member name="F:GvrPointerPhysicsRaycaster.MAX_RAYCAST_HITS_MAX">
            <summary>The maximum allowed value for the field maxRaycastHits.</summary>
        </member>
        <member name="F:GvrPointerPhysicsRaycaster.maxRaycastHits">
            <summary>The max number of hits that the raycaster can detect at once.</summary>
            <remarks><para>
            They are NOT guaranteed to be ordered by distance. This value should be set to a higher
            number than the number of objects the pointer is expected to intersect with in a single
            frame.
            </para><para>
            This functionality is used to prevent unnecessary memory allocation to improve performance.
            https://docs.unity3d.com/ScriptReference/Physics.SphereCastNonAlloc.html
            </para></remarks>
        </member>
        <member name="F:GvrPointerPhysicsRaycaster.hits">
            <summary>Buffer of raycast hits re-used each time `PerformRaycast` is called.</summary>
        </member>
        <member name="F:GvrPointerPhysicsRaycaster.hitComparer">
            <summary>Used to sort the hits by distance.</summary>
        </member>
        <member name="M:GvrPointerPhysicsRaycaster.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GvrPointerPhysicsRaycaster" /> class.
            </summary>
        </member>
        <member name="P:GvrPointerPhysicsRaycaster.MaxRaycastHits">
            <summary>
            Gets or sets the maximum number of hits that the raycaster can detect at once.
            </summary>
            <remarks><para>
            They are NOT guaranteed to be ordered by distance. This value should be set to a higher
            number than the number of objects the pointer is expected to intersect with in a single
            frame.
            </para><para>
            This functionality is used to prevent unnecessary memory allocation to improve performance.
            https://docs.unity3d.com/ScriptReference/Physics.SphereCastNonAlloc.html.
            </para></remarks>
            <value>The maximum number of hits that the raycaster can detect at once.</value>
        </member>
        <member name="P:GvrPointerPhysicsRaycaster.eventCamera">
            <inheritdoc/>
        </member>
        <member name="P:GvrPointerPhysicsRaycaster.finalEventMask">
            <summary>Gets the event mask used to determine which objects will receive events.</summary>
            <value>The event mask used to determine which objects will receive events.</value>
        </member>
        <member name="P:GvrPointerPhysicsRaycaster.eventMask">
            <summary>Gets or sets the layer mask used to filter events.</summary>
            <remarks>Always combined with the camera's culling mask if a camera is used.</remarks>
            <value>The layer mask used to filter events.</value>
        </member>
        <member name="M:GvrPointerPhysicsRaycaster.Awake">
            @cond
            <inheritdoc/>
        </member>
        <member name="M:GvrPointerPhysicsRaycaster.PerformRaycast(GvrBasePointer.PointerRay,System.Single,UnityEngine.EventSystems.PointerEventData,System.Collections.Generic.List{UnityEngine.EventSystems.RaycastResult})">
            @endcond
            <inheritdoc/>
        </member>
        <member name="M:GvrPointerPhysicsRaycaster.OnValidate">
            @cond
            <inheritdoc/>
        </member>
        <member name="T:GvrPointerPhysicsRaycaster.HitComparer">
            <summary>Used to sort the raycast hits by distance.</summary>
        </member>
        <member name="T:GvrPointerScrollInput">
            <summary>
            This class is used by `GvrPointerInputModule` to route scroll events through Unity's event
            system.
            </summary>
            <remarks>
            It maintains indepedent velocities for each instance of `IScrollHandler` that is currently being
            scrolled.  Inertia can optionally be toggled off.
            </remarks>
        </member>
        <member name="F:GvrPointerScrollInput.PROPERTY_NAME_INERTIA">
            <summary>Property name for accessing inertia.</summary>
        </member>
        <member name="F:GvrPointerScrollInput.PROPERTY_NAME_DECELERATION_RATE">
            <summary>Property name for accessing deceleration rate.</summary>
        </member>
        <member name="F:GvrPointerScrollInput.SCROLL_DELTA_MULTIPLIER">
            <summary>Multiplier for calculating the scroll delta.</summary>
            <remarks>
            Used so that the scroll delta is within the order of magnitude that the UI system expects.
            </remarks>
        </member>
        <member name="F:GvrPointerScrollInput.inertia">
            <summary>
            Inertia means that scroll events will continue for a while after the user stops touching the
            touchpad.
            </summary>
            <remarks>It gradually slows down according to the `decelerationRate`.</remarks>
        </member>
        <member name="F:GvrPointerScrollInput.decelerationRate">
            <summary>The deceleration rate is the speed reduction per second.</summary>
            <remarks>
            A value of 0.5 halves the speed each second. The default is 0.05.  The deceleration rate is
            only used when `inertia` is `true`.
            </remarks>
        </member>
        <member name="M:GvrPointerScrollInput.HandleScroll(UnityEngine.GameObject,UnityEngine.EventSystems.PointerEventData,GvrBasePointer,IGvrEventExecutor)">
            <summary>Performs scrolling if the user is touching the controller's touchpad.</summary>
            <remarks>Scroll speed is dependent upon touch position.</remarks>
            <param name="currentGameObject">
            The game object having the `IScrollHandler` component.
            </param>
            <param name="pointerData">The pointer event data.</param>
            <param name="pointer">The pointer object.</param>
            <param name="eventExecutor">The executor to use to process the event.</param>
        </member>
        <member name="T:GvrRecenterEventType">
            <summary>Maps to `gvr_recenter_event_type` in the C API.</summary>
        </member>
        <member name="F:GvrRecenterEventType.Invalid">
            <summary>This value is not in the C API.</summary>
        </member>
        <member name="F:GvrRecenterEventType.RecenterEventRestart">
            <summary>Headset removal / re-attach recenter.</summary>
        </member>
        <member name="F:GvrRecenterEventType.RecenterEventAligned">
            <summary>Controller-initiated recenter.</summary>
        </member>
        <member name="T:GvrRecenterFlags">
            @cond
            <summary>Placeholder.  No C spec for recenter flags yet.</summary>
        </member>
        <member name="F:GvrRecenterFlags.None">
            <summary>A default value indicating that no flags are set.</summary>
        </member>
        <member name="T:GvrRecenterOnlyController">
            <summary>
            Used to recenter only the controllers, required for scenes that have no clear forward direction.
            </summary>
            <remarks>
            Details: https://developers.google.com/vr/distribute/daydream/design-requirements#UX-D6
            <para>
            Works by offsetting the orientation of the transform when a recenter occurs to correct for the
            orientation change caused by the recenter event.
            </para><para>
            Usage: Place on the parent of the camera that should have its orientation corrected.
            </para></remarks>
        </member>
        <member name="T:GvrReticlePointer">
            <summary>Draws a circular reticle in front of any object that the user points at.</summary>
            <remarks>The circle dilates if the object is clickable.</remarks>
        </member>
        <member name="F:GvrReticlePointer.RETICLE_MIN_INNER_ANGLE">
            <summary>
            The constants below are expsed for testing. Minimum inner angle of the reticle (in degrees).
            </summary>
        </member>
        <member name="F:GvrReticlePointer.RETICLE_MIN_OUTER_ANGLE">
            <summary>Minimum outer angle of the reticle (in degrees).</summary>
        </member>
        <member name="F:GvrReticlePointer.RETICLE_GROWTH_ANGLE">
            <summary>
            Angle at which to expand the reticle when intersecting with an object (in degrees).
            </summary>
        </member>
        <member name="F:GvrReticlePointer.RETICLE_DISTANCE_MIN">
            <summary>Minimum distance of the reticle (in meters).</summary>
        </member>
        <member name="F:GvrReticlePointer.maxReticleDistance">
            <summary>Maximum distance of the reticle (in meters).</summary>
        </member>
        <member name="F:GvrReticlePointer.reticleSegments">
            <summary>Number of segments making the reticle circle.</summary>
        </member>
        <member name="F:GvrReticlePointer.reticleGrowthSpeed">
            <summary>Growth speed multiplier for the reticle.</summary>
        </member>
        <member name="F:GvrReticlePointer.reticleSortingOrder">
            <summary>Sorting order to use for the reticle's renderer.</summary>
            <remarks><para>
            Range values come from https://docs.unity3d.com/ScriptReference/Renderer-sortingOrder.html.
            </para><para>
            Default value 32767 ensures gaze reticle is always rendered on top.
            </para></remarks>
        </member>
        <member name="P:GvrReticlePointer.MaterialComp">
            <summary>Gets or sets the material used to render the reticle.</summary>
            <value>The material used to render the reticle.</value>
        </member>
        <member name="P:GvrReticlePointer.ReticleInnerAngle">
            <summary>Gets the current inner angle of the reticle (in degrees).</summary>
            <remarks>Exposed for testing.</remarks>
            <value>The current inner angle of the reticle (in degrees).</value>
        </member>
        <member name="P:GvrReticlePointer.ReticleOuterAngle">
            <summary>Gets the current outer angle of the reticle (in degrees).</summary>
            <remarks>Exposed for testing.</remarks>
            <value>The current outer angle of the reticle (in degrees).</value>
        </member>
        <member name="P:GvrReticlePointer.ReticleDistanceInMeters">
            <summary>Gets the current distance of the reticle (in meters).</summary>
            <remarks>Getter exposed for testing.</remarks>
            <value>The current distance of the reticle (in meters).</value>
        </member>
        <member name="P:GvrReticlePointer.ReticleInnerDiameter">
            <summary>
            Gets the current inner and outer diameters of the reticle, before distance multiplication.
            </summary>
            <remarks>Getters exposed for testing.</remarks>
            <value>
            The current inner and outer diameters of the reticle, before distance multiplication.
            </value>
        </member>
        <member name="P:GvrReticlePointer.ReticleOuterDiameter">
            <summary>Gets the current outer diameter of the reticle (in meters).</summary>
            <value>The current outer diameter of the reticle (in meters).</value>
        </member>
        <member name="P:GvrReticlePointer.MaxPointerDistance">
            <inheritdoc/>
        </member>
        <member name="M:GvrReticlePointer.OnPointerEnter(UnityEngine.EventSystems.RaycastResult,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:GvrReticlePointer.OnPointerHover(UnityEngine.EventSystems.RaycastResult,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:GvrReticlePointer.OnPointerExit(UnityEngine.GameObject)">
            <inheritdoc/>
        </member>
        <member name="M:GvrReticlePointer.OnPointerClickDown">
            <inheritdoc/>
        </member>
        <member name="M:GvrReticlePointer.OnPointerClickUp">
            <inheritdoc/>
        </member>
        <member name="M:GvrReticlePointer.GetPointerRadius(System.Single@,System.Single@)">
            <inheritdoc/>
        </member>
        <member name="M:GvrReticlePointer.UpdateDiameters">
            <summary>Updates the material based on the reticle properties.</summary>
        </member>
        <member name="M:GvrReticlePointer.Start">
            @cond
            <inheritdoc/>
        </member>
        <member name="M:GvrReticlePointer.Awake">
            @endcond
            <summary>This MonoBehavior's Awake behavior.</summary>
        </member>
        <member name="M:GvrReticlePointer.Update">
            @cond
            <summary>This MonoBehavior's `Update` method.</summary>
        </member>
        <member name="M:GvrReticlePointer.SetPointerTarget(UnityEngine.Vector3,System.Boolean)">
            @endcond
            <summary>Sets the reticle pointer's target.</summary>
            <param name="target">The target location.</param>
            <param name="interactive">Whether the pointer is pointing at an interactive object.</param>
            <returns>Returns `true` if the target is set successfully.</returns>
        </member>
        <member name="T:GvrSafetyRegionType">
            <summary>Maps to `gvr_safety_region_type` in the C API.</summary>
        </member>
        <member name="F:GvrSafetyRegionType.None">
            <summary>A default value indicating that there is no safety region.</summary>
        </member>
        <member name="F:GvrSafetyRegionType.Cylinder">
            <summary>A Cylinder-shaped safety region.</summary>
        </member>
        <member name="T:GvrScrollSettings">
            <summary>
            Used to override the global scroll settings in `GvrPointerScrollInput` for the `GameObject` that
            this script is attached to.
            </summary>
        </member>
        <member name="F:GvrScrollSettings.inertiaOverride">
            <summary>Override the `Inertia` property in `GvrPointerScrollInput` for this object.</summary>
            <remarks>
            Inertia means that scroll events will continue for a while after the user stops
            touching the touchpad. It gradually slows down according to the `decelerationRate`.
            </remarks>
        </member>
        <member name="F:GvrScrollSettings.decelerationRateOverride">
            <summary>The deceleration rate is the speed reduction per second.</summary>
            <remarks>
            A value of 0.5 halves the speed each second. The default is 0.05.  The deceleration rate is
            only used when `inertia` is `true`.
            </remarks>
        </member>
        <member name="P:GvrScrollSettings.InertiaOverride">
            <summary>
            Gets a value indicating whether the overridden value for `interia` is enabled.
            </summary>
            <remarks><para>
            This value will override the Inertia property in `GvrPointerScrollInput` for this object.
            </para><para>
            Inertia means that scroll events will continue for a while after the user stops
            touching the touchpad. It gradually slows down according to the `decelerationRate`.
            </para></remarks>
            <value>
            Gets the overridden value for whether to use `interia` for the `GvrPointerScrollInput`.
            </value>
        </member>
        <member name="P:GvrScrollSettings.DecelerationRateOverride">
            <summary>Gets the deceleration rate override value.</summary>
            <remarks><para>
            This value will override the deceleration rate in `GvrPointerScrollInput` for this
            object.
            </para><para>
            The deceleration rate is the speed reduction per second.
            </para><para>
            A value of 0.5 halves the speed each second.
            </para><para>
            The deceleration rate is only used when `inertia` is `true`.
            </para></remarks>
            <value>Gets the deceleration rate override value for the `GvrPointerScrollInput`.</value>
        </member>
        <member name="T:GvrSettings">
            <summary>Accesses and configures Daydream settings.</summary>
        </member>
        <member name="F:GvrSettings.VR_SDK_NONE">
            <summary>Name of 'None' VR SDK, as returned by `VRSettings.loadedDeviceName`.</summary>
        </member>
        <member name="F:GvrSettings.VR_SDK_DAYDREAM">
            <summary>Name of Daydream GVR SDK, as returned by `VRSettings.loadedDeviceName`.</summary>
        </member>
        <member name="F:GvrSettings.VR_SDK_CARDBOARD">
            <summary>
            Name of Cardboard GVR SDK, as returned by <see cref="!:VRSettings.loadedDeviceName" />.
            </summary>
        </member>
        <member name="T:GvrSettings.ViewerPlatformType">
            <summary>Viewer type.</summary>
        </member>
        <member name="F:GvrSettings.ViewerPlatformType.Error">
            <summary>An error value indicating that something has gone wrong.</summary>
            <remarks>Plugin-only value, does not exist in the NDK.</remarks>
        </member>
        <member name="F:GvrSettings.ViewerPlatformType.Cardboard">
            <summary>The Google Cardboard platform.</summary>
        </member>
        <member name="F:GvrSettings.ViewerPlatformType.Daydream">
            <summary>The Google Daydream platform.</summary>
        </member>
        <member name="T:GvrSettings.UserPrefsHandedness">
            <summary>Handedness preference values.</summary>
        </member>
        <member name="F:GvrSettings.UserPrefsHandedness.Error">
            <summary>An error value indicating that something has gone wrong.</summary>
            <remarks>Plugin-only value, does not exist in the NDK.</remarks>
        </member>
        <member name="F:GvrSettings.UserPrefsHandedness.Right">
            <summary>A right-handed preference.</summary>
        </member>
        <member name="F:GvrSettings.UserPrefsHandedness.Left">
            <summary>A left-handed preference.</summary>
        </member>
        <member name="P:GvrSettings.ViewerPlatform">
            <summary>Gets or sets the viewer platform type setting.</summary>
            <remarks> In the editor this can be set for devlopment testing.</remarks>
            <value>The viewer platform type setting.</value>
        </member>
        <member name="P:GvrSettings.SustainedPerformanceMode">
            <summary>Sets a value indicating whether sustained performance mode is enabled.</summary>
            <remarks><para>
            The developer is expected to remember whether sustained performance mode is set at runtime,
            via the checkbox in Player Settings.
            </para><para>
            This state may be recorded here in a future release.
            </para></remarks>
            <value>The sustained performance mode setting.</value>
        </member>
        <member name="P:GvrSettings.Handedness">
            <summary>Gets or sets the user's handedness preference value.</summary>
            <value>The user's handedness preference value.</value>
        </member>
        <member name="M:GvrSettings.GetValidGvrNativePtrOrLogError">
            <summary>Wraps call to `VRDevice.GetNativePtr()`.</summary>
            <remarks>
            Logs error if a supported GVR SDK is not active or if the returned native pointer is
            `IntPtr.Zero`.
            </remarks>
            <returns>An int pointer representing a GVR context.</returns>
        </member>
        <member name="T:GvrTooltip">
            <summary>
            A tooltip for displaying control schemes overlaying the controller visual using a Unity Canvas.
            </summary>
            <remarks>
            Automatically changes what side of the controller the tooltip is shown on depending on the
            handedness setting for the player.  Automatically fades out when the controller visual is too
            close or too far away from the player's head.  Look at the prefab GvrControllerPointer to see an
            example of how to use this script.
            </remarks>
        </member>
        <member name="F:GvrTooltip.TOUCH_PAD_Y_POSITION_METERS">
            <summary>
            Y Position for touch pad tooltips based on the standard controller visual.
            </summary>
        </member>
        <member name="F:GvrTooltip.APP_BUTTON_Y_POSITION_METERS">
            <summary>
            Y position for app button tooltips based on the standard controller visual.
            </summary>
        </member>
        <member name="F:GvrTooltip.TOOLTIP_Z_POSITION_METERS">
            <summary>Z position for all tooltips based on the standard controller visual.</summary>
        </member>
        <member name="F:GvrTooltip.RIGHT_SIDE_ROTATION">
            <summary>
            Rotation for a tooltip when it is displayed on the right side of the controller visual.
            </summary>
        </member>
        <member name="F:GvrTooltip.LEFT_SIDE_ROTATION">
            <summary>
            Rotation for a tooltip when it is displayed on the left side of the controller visual.
            </summary>
        </member>
        <member name="F:GvrTooltip.SQUARE_CENTER">
            <summary>
            Anchor point for a tooltip, used for controlling what side the tooltip is on.
            </summary>
        </member>
        <member name="F:GvrTooltip.PIVOT">
            <summary>
            Pivot point for a tooltip, used for controlling what side the tooltip is on.
            </summary>
        </member>
        <member name="T:GvrTooltip.Location">
            <summary>Options for where the controller should be displayed.</summary>
            <remarks>
            If set to custom, then the manually set localPosition of the tooltip is used.  This is
            useful when displaying a tooltip for a non-standard controller visual.
            </remarks>
        </member>
        <member name="P:GvrTooltip.TooltipText">
            <summary>Gets the text field for this tooltip.</summary>
            <value>The tooltip text.</value>
        </member>
        <member name="P:GvrTooltip.ArmModel">
            <summary>Gets or sets the arm model reference.</summary>
            <value>The arm model reference.</value>
        </member>
        <member name="M:GvrTooltip.IsTooltipInside">
            <summary>
            Returns `true` if this tooltip is set to display on the inside of the controller.
            </summary>
            <returns>Returns `true` if this instance is tooltip inside; otherwise, `false`.</returns>
        </member>
        <member name="M:GvrTooltip.IsTooltipOnLeft">
            <summary>
            Returns `true` if the tooltip should display on the left side of the controller.
            </summary>
            <remarks>
            This will change based on the handedness of the controller, as well as if the tooltip is set
            to display inside or outside.
            </remarks>
            <returns>Returns `true` if this instance is tooltip on left; otherwise, `false`.</returns>
        </member>
        <member name="M:GvrTooltip.OnSideChanged(System.Boolean)">
            <summary>
            Refreshes how the tooltip is being displayed based on what side it is being shown on.
            </summary>
            <remarks>Override to add custom display functionality.</remarks>
            <param name="IsLocationOnLeft">Whether the location is on the left.</param>
        </member>
        <member name="M:GvrTooltip.GetMetersToCanvasScale">
            <summary>Gets the meters-to-canvas scale.</summary>
            <returns>The meters-to-canvas scale.</returns>
        </member>
        <member name="T:GvrTrackedController">
            <summary>Represents an object tracked by controller input.</summary>
            <remarks>
            Manages the active status of the tracked controller based on controller connection status.
            <para>
            Fetches a `GvrControllerInputDevice` for the configured `GvrControllerHand` and propagates
            the device instance to all `IGvrControllerInputDeviceReceiver`s underneath this object on
            Start and if the controller handedness changes. If the controller is not positionally
            tracked, position of the object is updated to approximate arm mechanics by using a
            `GvrBaseArmModel`.  `GvrBaseArmModel`s are also propagated to all `IGvrArmModelReceiver`s
            underneath this object.
            </para></remarks>
        </member>
        <member name="P:GvrTrackedController.ControllerInputDevice">
            <summary>Gets the controller input device for this tracked object.</summary>
            <value>The controller input device for this tracked object.</value>
        </member>
        <member name="P:GvrTrackedController.ControllerHand">
            <summary>Gets or sets the controller hand used for this tracked object.</summary>
            <value>The controller hand used for this tracked object.</value>
        </member>
        <member name="P:GvrTrackedController.ArmModel">
            <summary>Gets or sets an arm model.</summary>
            <remarks>
            Used to control the pose (position and rotation) of the object and to propagate to children
            that implement `IGvrArmModelReceiver`.
            </remarks>
            <value>
            An arm model used to control the pose (position and rotation) of the object, and to
            propagate to children that implement `IGvrArmModelReceiver`.
            </value>
        </member>
        <member name="P:GvrTrackedController.IsDeactivatedWhenDisconnected">
            <summary>
            Gets or sets a value indicating whether the object's active status is determined by the
            controller connection status.
            </summary>
            <value>
            Value `true` if the object's active status is determined by the controller connection
            status, `false` otherwise.
            </value>
        </member>
        <member name="M:GvrTrackedController.PropagateArmModel">
            <summary>Propagates the arm model to all `IGvrArmModelReceiver`s.</summary>
            <remarks>Should only called when ArmModel is instantiated or changed.</remarks>
        </member>
        <member name="M:GvrTrackedController.OnValidate">
            <summary>This MonoBehavior's `OnValidate` override.</summary>
            <remarks>
            If the `armModel` serialized field is changed while the application is playing by using the
            inspector in the editor, then we need to call `PropagateArmModel` to ensure all children
            `IGvrArmModelReceiver` are updated.
            <para>
            Outside of the editor, this can't happen because the arm model can only change when a Setter
            is called that automatically calls `PropagateArmModel`.
            </para></remarks>
        </member>
        <member name="T:GvrUIHelpers">
            <summary>Helper class for dealing with canvas UI.</summary>
        </member>
        <member name="M:GvrUIHelpers.GetMetersToCanvasScale(UnityEngine.Transform)">
            <summary>
            Finds the meters scale for the local coordinate system of the root canvas that contains the
            canvasObject passed in.
            </summary>
            <param name="canvasObject">The UI canvas object for which to find the scale.</param>
            <returns>The meters scale for the local coordinate system of the root UI canvas.</returns>
        </member>
        <member name="T:GvrUnitySdkVersion">
            <summary>Provides and logs versioning information for the GVR SDK for Unity.</summary>
        </member>
        <member name="F:GvrUnitySdkVersion.GVR_SDK_VERSION">
            <summary>The version of the SDK.</summary>
        </member>
        <member name="T:GvrVideoPlayerTexture">
            <summary>Plays video using Exoplayer rendering it on the main texture.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.statusText">
            <summary>Attach a text component to get some debug status info.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.videoType">
            <summary>The type of the video.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.videoURL">
            <summary>The video URL.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.videoContentID">
            <summary>The video content ID.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.videoProviderId">
            <summary>The video provider ID.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.initialResolution">
            <summary>The video resolution used when streaming begins.</summary>
            <remarks><para>
            For multi-rate streams like Dash and HLS, the stream used at the beginning of playback is
            selected such that its vertical resolution is greater than or equal to this value.
            </para><para>
            After streaming begins, the player auto-selects the highest rate stream the network
            connection is capable of delivering.
            </para></remarks>
        </member>
        <member name="F:GvrVideoPlayerTexture.adjustAspectRatio">
            <summary>
            Value `true` indicates that the aspect ratio of the renderer needs adjusting.
            </summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.useSecurePath">
            <summary>Whether to use secure path for DRM protected video.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.videoPlayerPtr">
            <summary>The video player pointer used to uniquely identify the player instance.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.videoPlayerEventBase">
            <summary>The video player event base.</summary>
            <remarks>This is added to the event id when issues events to the plugin.</remarks>
        </member>
        <member name="F:GvrVideoPlayerTexture.renderEventFunction">
            <summary>The render event function.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.onEventCallbacks">
            <summary>List of callbacks to invoke when the video is ready.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.onExceptionCallbacks">
            <summary>List of callbacks to invoke on exception.</summary>
            <remarks>The first parameter is the type of exception, the second is the message.</remarks>
        </member>
        <member name="T:GvrVideoPlayerTexture.OnVideoEventCallback">
            <summary>A delegate to be triggered by event callbacks.</summary>
            <param name="cbdata">An integer pointer to the Video Player.</param>
            <param name="eventId">The ID of the triggering event.</param>
        </member>
        <member name="T:GvrVideoPlayerTexture.OnExceptionCallback">
            <summary>A delegate to be triggered by exception callbacks.</summary>
            <param name="type">The type of exception.</param>
            <param name="msg">The message associated with the exception.</param>
            <param name="cbdata">An integer pointer to the Video Player.</param>
        </member>
        <member name="T:GvrVideoPlayerTexture.VideoType">
            <summary>Video type.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.VideoType.Dash">
            <summary>Dynamic Adaptive Streaming over HTTP.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.VideoType.HLS">
            <summary>HTTP Live Streaming.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.VideoType.Other">
            <summary>Another video type.</summary>
        </member>
        <member name="T:GvrVideoPlayerTexture.VideoResolution">
            <summary>
            Video resolutions which can be selected as the initial resolution when streaming begins.
            See `initialResolution` for more information.
            </summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.VideoResolution.Lowest">
            <summary>The lowest available resolution.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.VideoResolution._720">
            <summary>720p resolution.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.VideoResolution._1080">
            <summary>1080p resolution.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.VideoResolution._2048">
            <summary>2K resolution.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.VideoResolution.Highest">
            <summary>4K resolution.</summary>
        </member>
        <member name="T:GvrVideoPlayerTexture.VideoPlayerState">
            <summary>Video player state.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.VideoPlayerState.Idle">
            <summary>An idle state.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.VideoPlayerState.Preparing">
            <summary>Preparing for video.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.VideoPlayerState.Buffering">
            <summary>Buffering video.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.VideoPlayerState.Ready">
            <summary>Ready for video.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.VideoPlayerState.Ended">
            <summary>Done with video.</summary>
        </member>
        <member name="T:GvrVideoPlayerTexture.VideoEvents">
            <summary>Video events.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.VideoEvents.VideoReady">
            <summary>Indicates that video is ready.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.VideoEvents.VideoStartPlayback">
            <summary>Indicates that the video playback should begin.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.VideoEvents.VideoFormatChanged">
            <summary>Indicates that the video format has changed.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.VideoEvents.VideoSurfaceSet">
            <summary>Indicates that the video surface has been set.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.VideoEvents.VideoSizeChanged">
            <summary>Indicates that the video size has changed.</summary>
        </member>
        <member name="T:GvrVideoPlayerTexture.StereoMode">
            <summary>Stereo mode formats.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.StereoMode.NoValue">
            <summary>An error-state indicating that no value has been set.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.StereoMode.Mono">
            <summary>Mono sound.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.StereoMode.TopBottom">
            <summary>Top-and-bottom stereo sound.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.StereoMode.LeftRight">
            <summary>Left-and-right stereo sound.</summary>
        </member>
        <member name="T:GvrVideoPlayerTexture.RenderCommand">
            <summary>Plugin render commands.</summary>
            <remarks>
            These are added to the eventbase for the specific player object and issued to the plugin.
            </remarks>
        </member>
        <member name="P:GvrVideoPlayerTexture.VideoReady">
            <summary>Gets a value indicating whether the video is ready to be played.</summary>
            <value>Value `true` if the video is ready to be played.</value>
        </member>
        <member name="P:GvrVideoPlayerTexture.CurrentPosition">
            <summary>Gets or sets the current position in seconds in the video stream.</summary>
            <value>The current position in seconds in the video stream.</value>
        </member>
        <member name="P:GvrVideoPlayerTexture.VideoDuration">
            <summary>Gets the duration in seconds of the video stream.</summary>
            <value>The duration in seconds of the video stream.</value>
        </member>
        <member name="P:GvrVideoPlayerTexture.BufferedPosition">
            <summary>Gets the buffered position in seconds of the video stream.</summary>
            <value>The buffered position in seconds of the video stream.</value>
        </member>
        <member name="P:GvrVideoPlayerTexture.BufferedPercentage">
            <summary>Gets the buffered percentage of the video stream.</summary>
            <value>The buffered percentage of the video stream.</value>
        </member>
        <member name="P:GvrVideoPlayerTexture.IsPaused">
            <summary>Gets a value indicating whether the video is paused.</summary>
            <value>Value `true` if the video is paused, `false` otherwise.</value>
        </member>
        <member name="P:GvrVideoPlayerTexture.PlayerState">
            <summary>Gets the player state.</summary>
            <value>The player state.</value>
        </member>
        <member name="P:GvrVideoPlayerTexture.MaxVolume">
            <summary>Gets the maximum volume value which can be set.</summary>
            <value>The maximum volume value which can be set.</value>
        </member>
        <member name="P:GvrVideoPlayerTexture.CurrentVolume">
            <summary>Gets or sets the current volume setting.</summary>
            <value>The current volume setting.</value>
        </member>
        <member name="P:GvrVideoPlayerTexture.CurrentStereoMode">
            <summary>Gets the current stereo mode.</summary>
            <value>The current stereo mode.</value>
        </member>
        <member name="P:GvrVideoPlayerTexture.HasProjection">
            <summary>Gets a value indicating whether the video has a projection.</summary>
            <value>Value `true` if the video has a projection, `false` otherwise.</value>
        </member>
        <member name="P:GvrVideoPlayerTexture.Screen">
            <summary>Gets or sets the renderer for the video texture.</summary>
            <value>The renderer for the video texture.</value>
        </member>
        <member name="P:GvrVideoPlayerTexture.CurrentFrameTexture">
            <summary>Gets the current frame texture.</summary>
            <value>The current frame texture.</value>
        </member>
        <member name="P:GvrVideoPlayerTexture.Width">
            <summary>Gets the width of the texture.</summary>
            <value>The width of the texture.</value>
        </member>
        <member name="P:GvrVideoPlayerTexture.Height">
            <summary>Gets the height of the texture.</summary>
            <value>The height of the texture.</value>
        </member>
        <member name="P:GvrVideoPlayerTexture.AspectRatio">
            <summary>Gets the aspect ratio of the texture.</summary>
            <value>The aspect ratio of the texture.</value>
        </member>
        <member name="M:GvrVideoPlayerTexture.CreateVideoPlayer">
            @cond
            <summary>Creates the Video Player.</summary>
            <remarks>Make this public so we can test the loading of the DLL.</remarks>
            <returns>An integer pointer to the Video Player.</returns>
        </member>
        <member name="M:GvrVideoPlayerTexture.DestroyVideoPlayer(System.IntPtr)">
            @endcond
            @cond
            <summary>Destroys the Video Player.</summary>
            <remarks>Make this public so we can test the loading of the DLL.</remarks>
            <param name="videoPlayerPtr">A pointer to the video player.</param>
        </member>
        <member name="M:GvrVideoPlayerTexture.SetDisplayTexture(UnityEngine.Texture)">
            <summary>Sets the display texture.</summary>
            <param name="texture">
            Texture to display.  If `null`, the initial texture of the renderer is used.
            </param>
        </member>
        <member name="M:GvrVideoPlayerTexture.CleanupVideo">
            <summary>Cleans up the current video player and texture.</summary>
        </member>
        <member name="M:GvrVideoPlayerTexture.ReInitializeVideo">
            <summary>
            Reinitializes the current video player or creates one if there is no player.
            </summary>
        </member>
        <member name="M:GvrVideoPlayerTexture.RestartVideo">
            <summary>Resets the video player.</summary>
        </member>
        <member name="M:GvrVideoPlayerTexture.SetCurrentVolume(System.Int32)">
            <summary>Set the volume level.</summary>
            <param name="val">The new volume level.</param>
        </member>
        <member name="M:GvrVideoPlayerTexture.Init">
            <summary>Initialize the video player.</summary>
            <returns>Returns `true` if successful.</returns>
        </member>
        <member name="M:GvrVideoPlayerTexture.Play">
            <summary>Play the video.</summary>
            <returns>Returns `true` if the video plays successfully, `false` otherwise.</returns>
        </member>
        <member name="M:GvrVideoPlayerTexture.Pause">
            <summary>Pauses video playback.</summary>
            <returns>Returns `true` if the operation is successful, `false` otherwise.</returns>
        </member>
        <member name="M:GvrVideoPlayerTexture.RemoveOnVideoEventCallback(System.Action{System.Int32})">
            <summary>Removes the callback for exceptions.</summary>
            <param name="callback">The callback to remove.</param>
        </member>
        <member name="M:GvrVideoPlayerTexture.SetOnVideoEventCallback(System.Action{System.Int32})">
            <summary>Sets the callback for video events.</summary>
            <param name="callback">The callback to set for video events.</param>
        </member>
        <member name="M:GvrVideoPlayerTexture.SetOnExceptionCallback(System.Action{System.String,System.String})">
            <summary>Sets the callback for exceptions.</summary>
            <param name="callback">The callback to set.</param>
        </member>
        <member name="M:GvrVideoPlayerTexture.ToIntPtr(System.Object)">
            <summary>Generates an integer pointer for a given object.</summary>
            <param name="obj">The object to generate an integer pointer for.</param>
            <returns>An integer pointer.</returns>
        </member>
        <member name="M:GvrVideoPlayerTexture.FireVideoEvent(System.Int32)">
            <summary>Fires off a video event.</summary>
            <param name="eventId">The ID of the event to fire.</param>
        </member>
        <member name="M:GvrVideoPlayerTexture.FireOnException(System.String,System.String)">
            <summary>Fires all callbacks registered to `onExceptionCallbacks`.</summary>
            <param name="type">The `type` parameter for the callback.</param>
            <param name="msg">The `msg` parameter for the callback.</param>
        </member>
        <member name="M:GvrVideoPlayerTexture.ProcessURL">
            <summary>Processes the URL.</summary>
            <returns>The processed URL.</returns>
        </member>
        <member name="M:GvrVideoPlayerTexture.GetVideoPlayerEventBase(System.IntPtr)">
            <summary>A pure-virtual method for getting a video player event base.</summary>
            <param name="videoPlayerPtr">A pointer to the video player.</param>
            <returns>An integer representing the success status.</returns>
        </member>
        <member name="M:GvrVideoPlayerTexture.AdjustAspectRatio">
            <summary>Adjusts the aspect ratio.</summary>
            <remarks>
            This adjusts the transform scale to match the aspect ratio of the texture.
            </remarks>
        </member>
        <member name="M:GvrVideoPlayerTexture.IssuePlayerEvent(GvrVideoPlayerTexture.RenderCommand)">
            <summary>Issues the player event.</summary>
            <param name="evt">The event to send to the video player instance.</param>
        </member>
        <member name="T:GvrVRHelpers">
            <summary>Helper functions common to GVR VR applications.</summary>
        </member>
        <member name="M:GvrVRHelpers.GetViewportCenter">
            <summary>Gets the center of the screen or eye texture, in pixels.</summary>
            <returns>The center of the screen, in pixels.</returns>
        </member>
        <member name="M:GvrVRHelpers.GetHeadForward">
            <summary>Gets the forward vector relative to the headset's rotation.</summary>
            <returns>The forward vector relative to the headset's rotation.</returns>
        </member>
        <member name="M:GvrVRHelpers.GetHeadRotation">
            <summary>Gets the headset's rotation.</summary>
            <returns>The headset's rotation.</returns>
        </member>
        <member name="M:GvrVRHelpers.GetHeadPosition">
            <summary>Gets the head's position.</summary>
            <returns>The head's position.</returns>
        </member>
        <member name="M:GvrVRHelpers.GetRecommendedMaxLaserDistance(GvrBasePointer.RaycastMode)">
            <summary>Gets the recommended max laser distance, based on raycast mode.</summary>
            <param name="mode">The `RaycastMode` for which to get the recommended distance.</param>
            <returns>The recommended maximum laser distance for the given mode.</returns>
        </member>
        <member name="M:GvrVRHelpers.GetRayIntersection(GvrBasePointer.RaycastMode)">
            <summary>Gets the distance at which the `Direct` and `Camera` raycasts intersect.</summary>
            <remarks>
            This is the the point at which `Hybrid` mode will transition from `Direct` (closer than the
            intersection) to `Camera` (further than the intersection) mode.
            </remarks>
            <param name="mode">
            The `RaycastMode` for which to get the intersection distance.  Only returns non-zero when
            this is `RaycastMode.Camera`.
            </param>
            <returns>The distance at which the `Direct` and `Camera` raycasts intersect.</returns>
        </member>
        <member name="M:GvrVRHelpers.GetShrinkLaser(GvrBasePointer.RaycastMode)">
            <summary>Returns a value indicating whether the laser is visually shrunken.</summary>
            <param name="mode">The `RaycastMode` for which to check behavior.</param>
            <returns>Returns `true` if the laser is shrunken, `false`a otherwise.</returns>
        </member>
        <member name="T:GvrXREventsSubscriber">
            <summary>Handler for subscribing XR Unity actions to GVR Actions.</summary>
        </member>
        <member name="P:GvrXREventsSubscriber.loadedDeviceName">
            <summary>Gets the name of the loaded GVR device.</summary>
            <remarks><para>
            This should be used in place of `XRSettings.loadedDeviceName`, which allocates small
            amounts of memory on every call.
            </para><para>
            When using 2018.3 and above, a cached copy of `XRSettings.loadedDeviceName` which updates
            whenever the `OnDeviceLoadAction` event triggers.
            </para><para>
            On 2018.2 and below, a one-time snapshot of the initial `XRSettings.loadedDeviceName` taken
            when this component is instantiated.  If `loadedDeviceName` is expected to change during
            runtime in 2018.2 or earlier, use the setter to assign `XRSettings.loadedDeviceName` when
            this is expected to happen.
            </para></remarks>
            <value>The name of the loaded GVR device.</value>
        </member>
        <member name="T:IGvrArmModelReceiver">
            <summary>Interface declaring the use of the arm model.</summary>
        </member>
        <member name="P:IGvrArmModelReceiver.ArmModel">
            <summary>Gets or sets the arm model reference.</summary>
            <value>The arm model reference.</value>
        </member>
        <member name="T:IGvrControllerInputDeviceReceiver">
            <summary>Interface declaring the need for the controller input device.</summary>
        </member>
        <member name="P:IGvrControllerInputDeviceReceiver.ControllerInputDevice">
            <summary>Sets the reference to the controller input device.</summary>
            <value>The `GvrControllerInputDevice` this instance listens to.</value>
        </member>
        <member name="T:IGvrEventExecutor">
            <summary>Provides an interface for executing events for `IEventSystemHandler`.</summary>
        </member>
        <member name="M:IGvrEventExecutor.Execute``1(UnityEngine.GameObject,UnityEngine.EventSystems.BaseEventData,UnityEngine.EventSystems.ExecuteEvents.EventFunction{``0})">
            <summary>Execute the event of type `T : IEventSystemHandler` on the game object.</summary>
            <remarks>
            The event will be executed on all components on the game object that can handle it.
            </remarks>
            <param name="target">Target game object.</param>
            <param name="eventData">Data associated with the executing event.</param>
            <param name="functor">Function to execute on the game object components.</param>
            <typeparam name="T">An interface with methods for handling events.</typeparam>
            <returns>A value indicating whether the delegate successfully executed.</returns>
        </member>
        <member name="M:IGvrEventExecutor.ExecuteHierarchy``1(UnityEngine.GameObject,UnityEngine.EventSystems.BaseEventData,UnityEngine.EventSystems.ExecuteEvents.EventFunction{``0})">
            <summary>
            Recurse up the hierarchy calling `Execute` until there is a game object that can handle the
            event.
            </summary>
            <remarks>
            See https://docs.unity3d.com/2017.4/Documentation/ScriptReference/EventSystems.ExecuteEvents.ExecuteHierarchy.html.
            </remarks>
            <param name="root">Start game object for search.</param>
            <param name="eventData">Data associated with the executing event.</param>
            <param name="callbackFunction">Function to execute on the game object components.</param>
            <typeparam name="T">An interface with methods for handling events.</typeparam>
            <returns>GameObject Game object that handled the event.</returns>
        </member>
        <member name="M:IGvrEventExecutor.GetEventHandler``1(UnityEngine.GameObject)">
            @note Traversal is performed upwards from the target object, not down.
            <summary>
            Traverse the object hierarchy starting at root, and return the game object which implements
            the event handler of type `T`.
            </summary>
            <param name="root">The root object to which to send event triggers.</param>
            <typeparam name="T">An interface with methods for handling events.</typeparam>
            <returns>The event handler.</returns>
        </member>
        <member name="T:IGvrInputModuleController">
            <summary>
            Interface for manipulating an input module used by `GvrPointerInputModuleImpl`.
            </summary>
        </member>
        <member name="P:IGvrInputModuleController.eventSystem">
            <summary>Gets a reference to the event system.</summary>
            <value>A reference to the event system.</value>
        </member>
        <member name="P:IGvrInputModuleController.RaycastResultCache">
            <summary>Gets the raycast result cache list.</summary>
            <value>The raycast result cache list.</value>
        </member>
        <member name="M:IGvrInputModuleController.ShouldActivate">
            <summary>Whether the controller should be activated.</summary>
            <returns>Returns `true` if the controller should be activated, `false` otherwise.</returns>
        </member>
        <member name="M:IGvrInputModuleController.Deactivate">
            <summary>Deactivate the controller.</summary>
        </member>
        <member name="M:IGvrInputModuleController.FindCommonRoot(UnityEngine.GameObject,UnityEngine.GameObject)">
            <summary>
            Given two game objects, return a common root game object, or null if there is no common
            root.
            </summary>
            <param name="g1">The first `GameObject`.</param>
            <param name="g2">The second `GameObject`.</param>
            <returns>The common root.</returns>
        </member>
        <member name="M:IGvrInputModuleController.GetBaseEventData">
            <summary>Gets a `BaseEventData` that can be used by the `EventSystem`.</summary>
            <returns>A `BaseEventData` that can be used by the `EventSystem`.</returns>
        </member>
        <member name="M:IGvrInputModuleController.FindFirstRaycast(System.Collections.Generic.List{UnityEngine.EventSystems.RaycastResult})">
            <summary>Return the first valid raycast result.</summary>
            <param name="candidates">
            The list of `RaycastResults` to search for the first Raycast.
            </param>
            <returns>The first raycast.</returns>
        </member>
        <member name="T:IGvrPointerHoverHandler">
            <summary>Interface to implement if you wish to receive `OnGvrPointerHover` callbacks.</summary>
        </member>
        <member name="M:IGvrPointerHoverHandler.OnGvrPointerHover(UnityEngine.EventSystems.PointerEventData)">
            <summary>Called when pointer is hovering over `GameObject`.</summary>
            <param name="eventData">The event data associated with the triggering event.</param>
        </member>
        <member name="T:IGvrScrollSettings">
            <summary>
            Interface to implement to override the global scroll settings in `GvrPointerScrollInput` for an
            object.
            </summary>
            <remarks><para>
            Must be implmented by a component. It will override the scroll settings for the
            `GameObject` that the component is attached to.
            </para><para>
            Can use `GvrScrollSettings` to override scroll settings for any existing UI type,
            or a custom UI component can implement this directly to override the scroll settings
            for the UI component's use case.
            </para></remarks>
        </member>
        <member name="P:IGvrScrollSettings.InertiaOverride">
            <summary>
            Gets a value indicating whether the interia is enabled via its override value.
            </summary>
            <remarks><para>
            This value will override the Inertia property in `GvrPointerScrollInput` for this object.
            </para><para>
            Inertia means that scroll events will continue for a while after the user stops
            touching the touchpad. It gradually slows down according to the deceleration rate.
            </para></remarks>
            <value>
            Gets whether the interia is enabled via its override value for the `GvrPointerScrollInput`.
            </value>
        </member>
        <member name="P:IGvrScrollSettings.DecelerationRateOverride">
            <summary>Gets the deceleration rate override value.</summary>
            <remarks><para>
            This value will override the deceleration rate in `GvrPointerScrollInput` for this object.
            </para><para>
            The deceleration rate is the speed reduction per second.  A value of 0.5 halves the speed
            each second.  The deceleration rate is only used when `inertia` is `true`.
            </para></remarks>
            <value>Gets the default deceleration rate for the `GvrPointerScrollInput`.</value>
        </member>
        <member name="T:InstantPreviewHelper">
            <summary>Helper methods for Instant preview.</summary>
        </member>
        <member name="F:InstantPreviewHelper.adbPath">
            <summary>Path to `adb` executable.</summary>
        </member>
        <member name="F:InstantPreviewHelper.aaptPath">
            <summary>Path to `aapt` executable.</summary>
        </member>
        <member name="T:IPointerHoverHandler">
            Handler for pointer is hovering over GameObject.
        </member>
        <member name="M:OVR.OpenVR.OpenVR.Init(OVR.OpenVR.EVRInitError@,OVR.OpenVR.EVRApplicationType,System.String)">
            Finds the active installation of vrclient.dll and initializes it 
        </member>
        <member name="M:OVR.OpenVR.OpenVR.Shutdown">
            unloads vrclient.dll. Any interface pointers from the interface are
            invalid after this point 
        </member>
        <member name="T:OVRBoundary">
            <summary>
            Provides access to the Oculus boundary system.
            </summary>
        </member>
        <member name="T:OVRBoundary.Node">
            <summary>
            Specifies a tracked node that can be queried through the boundary system.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:OVRBoundary.Node.HandRight" -->
        <!-- Badly formed XML comment ignored for member "F:OVRBoundary.Node.Head" -->
        <member name="T:OVRBoundary.BoundaryType">
            <summary>
            Specifies a boundary type surface.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:OVRBoundary.BoundaryType.PlayArea" -->
        <member name="T:OVRBoundary.BoundaryTestResult">
            <summary>
            Provides test results of boundary system queries.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:OVRBoundary.BoundaryTestResult.ClosestDistance" -->
        <!-- Badly formed XML comment ignored for member "F:OVRBoundary.BoundaryTestResult.ClosestPoint" -->
        <!-- Badly formed XML comment ignored for member "F:OVRBoundary.BoundaryTestResult.ClosestPointNormal" -->
        <member name="M:OVRBoundary.GetConfigured">
            <summary>
            Returns true if the boundary system is currently configured with valid boundary data.
            </summary>
        </member>
        <member name="M:OVRBoundary.TestNode(OVRBoundary.Node,OVRBoundary.BoundaryType)">
            <summary>
            Returns the results of testing a tracked node against the specified boundary type.
            All points are returned in local tracking space shared by tracked nodes and accessible through OVRCameraRig's trackingSpace anchor.
            </summary>
        </member>
        <member name="M:OVRBoundary.TestPoint(UnityEngine.Vector3,OVRBoundary.BoundaryType)">
            <summary>
            Returns the results of testing a 3d point against the specified boundary type.
            The test point is expected in local tracking space.
            All points are returned in local tracking space shared by tracked nodes and accessible through OVRCameraRig's trackingSpace anchor.
            </summary>
        </member>
        <member name="M:OVRBoundary.GetGeometry(OVRBoundary.BoundaryType)">
            <summary>
            Returns an array of 3d points (in clockwise order) that define the specified boundary type.
            All points are returned in local tracking space shared by tracked nodes and accessible through OVRCameraRig's trackingSpace anchor.
            </summary>
        </member>
        <member name="M:OVRBoundary.GetDimensions(OVRBoundary.BoundaryType)">
            <summary>
            Returns a vector that indicates the spatial dimensions of the specified boundary type. (x = width, y = height, z = depth)
            </summary>
        </member>
        <member name="M:OVRBoundary.GetVisible">
            <summary>
            Returns true if the boundary system is currently visible.
            </summary>
        </member>
        <member name="M:OVRBoundary.SetVisible(System.Boolean)">
            <summary>
            Requests that the boundary system visibility be set to the specified value.
            The actual visibility can be overridden by the system (i.e., proximity trigger) or by the user (boundary system disabled)
            </summary>
        </member>
        <member name="T:OVRCameraRig">
            <summary>
            A head-tracked stereoscopic virtual reality camera rig.
            </summary>
        </member>
        <member name="P:OVRCameraRig.leftEyeCamera">
            <summary>
            The left eye camera.
            </summary>
        </member>
        <member name="P:OVRCameraRig.rightEyeCamera">
            <summary>
            The right eye camera.
            </summary>
        </member>
        <member name="P:OVRCameraRig.trackingSpace">
            <summary>
            Provides a root transform for all anchors in tracking space.
            </summary>
        </member>
        <member name="P:OVRCameraRig.leftEyeAnchor">
            <summary>
            Always coincides with the pose of the left eye.
            </summary>
        </member>
        <member name="P:OVRCameraRig.centerEyeAnchor">
            <summary>
            Always coincides with average of the left and right eye poses.
            </summary>
        </member>
        <member name="P:OVRCameraRig.rightEyeAnchor">
            <summary>
            Always coincides with the pose of the right eye.
            </summary>
        </member>
        <member name="P:OVRCameraRig.leftHandAnchor">
            <summary>
            Always coincides with the pose of the left hand.
            </summary>
        </member>
        <member name="P:OVRCameraRig.rightHandAnchor">
            <summary>
            Always coincides with the pose of the right hand.
            </summary>
        </member>
        <member name="P:OVRCameraRig.leftControllerAnchor">
            <summary>
            Anchors controller pose to fix offset issues for the left hand.
            </summary>
        </member>
        <member name="P:OVRCameraRig.rightControllerAnchor">
            <summary>
            Anchors controller pose to fix offset issues for the right hand.
            </summary>
        </member>
        <member name="P:OVRCameraRig.trackerAnchor">
            <summary>
            Always coincides with the pose of the sensor.
            </summary>
        </member>
        <member name="E:OVRCameraRig.UpdatedAnchors">
            <summary>
            Occurs when the eye pose anchors have been set.
            </summary>
        </member>
        <member name="F:OVRCameraRig.usePerEyeCameras">
            <summary>
            If true, separate cameras will be used for the left and right eyes.
            </summary>
        </member>
        <member name="F:OVRCameraRig.useFixedUpdateForTracking">
            <summary>
            If true, all tracked anchors are updated in FixedUpdate instead of Update to favor physics fidelity.
            \note: If the fixed update rate doesn't match the rendering framerate (OVRManager.display.appFramerate), the anchors will visibly judder.
            </summary>
        </member>
        <member name="F:OVRCameraRig.disableEyeAnchorCameras">
            <summary>
            If true, the cameras on the eyeAnchors will be disabled.
            \note: The main camera of the game will be used to provide VR rendering. And the tracking space anchors will still be updated to provide reference poses.
            </summary>
        </member>
        <member name="T:OVRChromaticAberration">
            <summary>
            Allows you to toggle chromatic aberration correction with a gamepad button press.
            </summary>
        </member>
        <member name="F:OVRChromaticAberration.toggleButton">
            <summary>
            The button that will toggle chromatic aberration correction.
            </summary>
        </member>
        <member name="T:OVRExtensions">
            <summary>
            Miscellaneous extension methods that any script can use.
            </summary>
        </member>
        <member name="M:OVRExtensions.ToTrackingSpacePose(UnityEngine.Transform,UnityEngine.Camera)">
            <summary>
            Converts the given world-space transform to an OVRPose in tracking space.
            </summary>
        </member>
        <member name="M:OVRExtensions.ToWorldSpacePose(OVRPose)">
            <summary>
            Converts the given pose from tracking-space to world-space.
            </summary>
        </member>
        <member name="M:OVRExtensions.ToHeadSpacePose(UnityEngine.Transform,UnityEngine.Camera)">
            <summary>
            Converts the given world-space transform to an OVRPose in head space.
            </summary>
        </member>
        <member name="T:OVRPose">
            <summary>
            An affine transformation built from a Unity position and orientation.
            </summary>
        </member>
        <member name="P:OVRPose.identity">
            <summary>
            A pose with no translation or rotation.
            </summary>
        </member>
        <member name="F:OVRPose.position">
            <summary>
            The position.
            </summary>
        </member>
        <member name="F:OVRPose.orientation">
            <summary>
            The orientation.
            </summary>
        </member>
        <member name="M:OVRPose.op_Multiply(OVRPose,OVRPose)">
            <summary>
            Multiplies two poses.
            </summary>
        </member>
        <member name="M:OVRPose.Inverse">
            <summary>
            Computes the inverse of the given pose.
            </summary>
        </member>
        <member name="M:OVRPose.flipZ">
            <summary>
            Converts the pose from left- to right-handed or vice-versa.
            </summary>
        </member>
        <member name="T:OVRNativeBuffer">
            <summary>
            Encapsulates an 8-byte-aligned of unmanaged memory.
            </summary>
        </member>
        <member name="M:OVRNativeBuffer.#ctor(System.Int32)">
            <summary>
            Creates a buffer of the specified size.
            </summary>
        </member>
        <member name="M:OVRNativeBuffer.Finalize">
            <summary>
            Releases unmanaged resources and performs other cleanup operations before the <see cref="T:OVRNativeBuffer"/> is
            reclaimed by garbage collection.
            </summary>
        </member>
        <member name="M:OVRNativeBuffer.Reset(System.Int32)">
            <summary>
            Reallocates the buffer with the specified new size.
            </summary>
        </member>
        <member name="M:OVRNativeBuffer.GetCapacity">
            <summary>
            The current number of bytes in the buffer.
            </summary>
        </member>
        <member name="M:OVRNativeBuffer.GetPointer(System.Int32)">
            <summary>
            A pointer to the unmanaged memory in the buffer, starting at the given offset in bytes.
            </summary>
        </member>
        <member name="M:OVRNativeBuffer.Dispose">
            <summary>
            Releases all resource used by the <see cref="T:OVRNativeBuffer"/> object.
            </summary>
            <remarks>Call <see cref="M:OVRNativeBuffer.Dispose"/> when you are finished using the <see cref="T:OVRNativeBuffer"/>. The <see cref="M:OVRNativeBuffer.Dispose"/>
            method leaves the <see cref="T:OVRNativeBuffer"/> in an unusable state. After calling <see cref="M:OVRNativeBuffer.Dispose"/>, you must
            release all references to the <see cref="T:OVRNativeBuffer"/> so the garbage collector can reclaim the memory that
            the <see cref="T:OVRNativeBuffer"/> was occupying.</remarks>
        </member>
        <member name="T:OVRCubemapCapture">
            <summary>
            Helper script for capture cubemap and save it into PNG or JPG file
            </summary>
            <description>
            How it works:
            1) This script can be attached to a existing game object, you can also use prefab Assets\OVR\Prefabs\OVRCubemapCaptureProbe
            There are 2 ways to trigger a capture if you attached this script to a game object.
            	* Automatic capturing: if [autoTriggerAfterLaunch] is true, a automatic capturing will be triggered after [autoTriggerDelay] seconds.
            	* Keyboard trigger: press key [triggeredByKey], a capturing will be triggered.
            2) If you like to trigger the screen capture in your code logic, just call static function [OVRCubemapCapture.TriggerCubemapCapture] with proper input arguments.
            </description>
        </member>
        <member name="F:OVRCubemapCapture.autoTriggerAfterLaunch">
            <summary>
            Enable the automatic screenshot trigger, which will capture a cubemap after autoTriggerDelay (seconds)
            </summary>
        </member>
        <member name="F:OVRCubemapCapture.triggeredByKey">
            <summary>
            Trigger cubemap screenshot if user pressed key triggeredByKey
            </summary>
        </member>
        <member name="F:OVRCubemapCapture.pathName">
            <summary>
            The complete file path for saving the cubemap screenshot, including the filename and extension
            if pathName is blank, screenshots will be saved into %USERPROFILE%\Documents\OVR_ScreenShot360
            </summary>
        </member>
        <member name="F:OVRCubemapCapture.cubemapSize">
            <summary>
            The cube face resolution
            </summary>
        </member>
        <member name="M:OVRCubemapCapture.TriggerCubemapCapture(UnityEngine.Vector3,System.Int32,System.String)">
            <summary>
            Generate unity cubemap at specific location and save into JPG/PNG
            </summary>
            <description>
            Default save folder: your app's persistentDataPath
            Default file name: using current time OVR_hh_mm_ss.png
            Note1: this will take a few seconds to finish
            Note2: if you only want to specify path not filename, please end [pathName] with "/"
            </description>
        </member>
        <member name="M:OVRCubemapCapture.SaveCubemapCapture(UnityEngine.Cubemap,System.String)">
            <summary>
            Save unity cubemap into NPOT 6x1 cubemap/texture atlas in the following format PX NX PY NY PZ NZ
            </summary>
            <description>
            Supported format: PNG/JPG
            Default file name: using current time OVR_hh_mm_ss.png
            </description>
        </member>
        <member name="T:OVRDebugHeadController">
            <summary>
            This is a simple behavior that can be attached to a parent of the CameraRig in order
            to provide movement via the gamepad. This is useful when testing an application in
            the Unity editor without the HMD.
            To use it, create a game object in your scene and drag your CameraRig to be a child
            of the game object. Then, add the OVRDebugHeadController behavior to the game object.
            Alternatively, this behavior can be placed directly on the OVRCameraRig object, but
            that is not guaranteed to work if OVRCameraRig functionality changes in the future.
            In the parent case, the object with OVRDebugHeadController can be thougt of as a
            platform that your camera is attached to. When the platform moves or rotates, the
            camera moves or rotates, but the camera can still move independently while "on" the
            platform.
            In general, this behavior should be disabled when not debugging.
            </summary>
        </member>
        <member name="T:OVRDebugInfo">
            <summary>
            Shows debug information on a heads-up display.
            </summary>
        </member>
        <member name="F:OVRDebugInfo.updateInterval">
            <summary>
            Variables for FPS
            </summary>
        </member>
        <member name="F:OVRDebugInfo.initUIComponent">
            <summary>
            Managing for UI initialization
            </summary>
        </member>
        <member name="F:OVRDebugInfo.offsetY">
            <summary>
            UIs Y offset
            </summary>
        </member>
        <member name="F:OVRDebugInfo.riftPresentTimeout">
            <summary>
            Managing for rift detection UI
            </summary>
        </member>
        <member name="F:OVRDebugInfo.showVRVars">
            <summary>
            Turn on / off VR variables
            </summary>
        </member>
        <member name="M:OVRDebugInfo.Awake">
            <summary>
            Initialization
            </summary>
        </member>
        <member name="M:OVRDebugInfo.Update">
            <summary>
            Updating VR variables and managing UI present
            </summary>
        </member>
        <member name="M:OVRDebugInfo.OnDestroy">
            <summary>
            Initialize isInited value on OnDestroy
            </summary>
        </member>
        <member name="M:OVRDebugInfo.InitUIComponents">
            <summary>
            Initialize UI GameObjects
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateVariable">
            <summary>
            Update VR Variables
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateStrings">
            <summary>
            Update Strings
            </summary>
        </member>
        <member name="M:OVRDebugInfo.RiftPresentGUI(UnityEngine.GameObject)">
            <summary>
            It's for rift present GUI
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateDeviceDetection">
            <summary>
            Updates the device detection.
            </summary>
        </member>
        <member name="M:OVRDebugInfo.VariableObjectManager(UnityEngine.GameObject,System.String,System.Single,System.String,System.Int32)">
            <summary>
            Object Manager for Variables
            </summary>
            <returns> gameobject for each Variable </returns>
        </member>
        <member name="M:OVRDebugInfo.ComponentComposition(UnityEngine.GameObject)">
            <summary>
            Component composition
            </summary>
            <returns> Composed gameobject. </returns>
        </member>
        <member name="M:OVRDebugInfo.UpdateIPD">
            <summary>
            Updates the IPD.
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateEyeHeightOffset">
            <summary>
            Updates the eye height offset.
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateEyeDepthOffset">
            <summary>
            Updates the eye depth offset.
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateFOV">
            <summary>
            Updates the FOV.
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateResolutionEyeTexture">
            <summary>
            Updates resolution of eye texture
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateLatencyValues">
            <summary>
            Updates latency values
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateFPS">
            <summary>
            Updates the FPS.
            </summary>
        </member>
        <member name="T:OVRDisplay">
            <summary>
            Manages an Oculus Rift head-mounted display (HMD).
            </summary>
        </member>
        <member name="T:OVRDisplay.EyeFov">
            <summary>
            Contains full fov information per eye
            Under Symmetric Fov mode, UpFov == DownFov and LeftFov == RightFov.
            </summary>
        </member>
        <member name="T:OVRDisplay.EyeRenderDesc">
            <summary>
            Specifies the size and field-of-view for one eye texture.
            </summary>
        </member>
        <member name="F:OVRDisplay.EyeRenderDesc.resolution">
            <summary>
            The horizontal and vertical size of the texture.
            </summary>
        </member>
        <member name="F:OVRDisplay.EyeRenderDesc.fov">
            <summary>
            The angle of the horizontal and vertical field of view in degrees.
            For Symmetric FOV interface compatibility
            Note this includes the fov angle from both sides
            </summary>
        </member>
        <member name="F:OVRDisplay.EyeRenderDesc.fullFov">
            <summary>
            The full information of field of view in degrees.
            When Asymmetric FOV isn't enabled, this returns the maximum fov angle
            </summary>
        </member>
        <member name="T:OVRDisplay.LatencyData">
            <summary>
            Contains latency measurements for a single frame of rendering.
            </summary>
        </member>
        <member name="F:OVRDisplay.LatencyData.render">
            <summary>
            The time it took to render both eyes in seconds.
            </summary>
        </member>
        <member name="F:OVRDisplay.LatencyData.timeWarp">
            <summary>
            The time it took to perform TimeWarp in seconds.
            </summary>
        </member>
        <member name="F:OVRDisplay.LatencyData.postPresent">
            <summary>
            The time between the end of TimeWarp and scan-out in seconds.
            </summary>
        </member>
        <member name="M:OVRDisplay.#ctor">
            <summary>
            Creates an instance of OVRDisplay. Called by OVRManager.
            </summary>
        </member>
        <member name="M:OVRDisplay.Update">
            <summary>
            Updates the internal state of the OVRDisplay. Called by OVRManager.
            </summary>
        </member>
        <member name="E:OVRDisplay.RecenteredPose">
            <summary>
            Occurs when the head pose is reset.
            </summary>
        </member>
        <member name="M:OVRDisplay.RecenterPose">
            <summary>
            Recenters the head pose.
            </summary>
        </member>
        <member name="P:OVRDisplay.acceleration">
            <summary>
            Gets the current linear acceleration of the head.
            </summary>
        </member>
        <member name="P:OVRDisplay.angularAcceleration">
            <summary>
            Gets the current angular acceleration of the head in radians per second per second about each axis.
            </summary>
        </member>
        <member name="P:OVRDisplay.velocity">
            <summary>
            Gets the current linear velocity of the head in meters per second.
            </summary>
        </member>
        <member name="P:OVRDisplay.angularVelocity">
            <summary>
            Gets the current angular velocity of the head in radians per second about each axis.
            </summary>
        </member>
        <member name="M:OVRDisplay.GetEyeRenderDesc(UnityEngine.XR.XRNode)">
            <summary>
            Gets the resolution and field of view for the given eye.
            </summary>
        </member>
        <member name="P:OVRDisplay.latency">
            <summary>
            Gets the current measured latency values.
            </summary>
        </member>
        <member name="P:OVRDisplay.appFramerate">
            <summary>
            Gets application's frame rate reported by oculus plugin
            </summary>
        </member>
        <member name="P:OVRDisplay.recommendedMSAALevel">
            <summary>
            Gets the recommended MSAA level for optimal quality/performance the current device.
            </summary>
        </member>
        <member name="P:OVRDisplay.displayFrequenciesAvailable">
            <summary>
            Gets the list of available display frequencies supported by this hardware.
            </summary>
        </member>
        <member name="P:OVRDisplay.displayFrequency">
            <summary>
            Gets and sets the current display frequency.
            </summary>
        </member>
        <member name="T:OVRMRForegroundCameraManager">
            <summary>
            Helper internal class for foregroundCamera, don't call it outside
            </summary>
        </member>
        <member name="T:OVRGazePointer">
            <summary>
            UI pointer driven by gaze input.
            </summary>
        </member>
        <member name="F:OVRGazePointer.rayTransform">
            <summary>
            The gaze ray.
            </summary>
        </member>
        <member name="P:OVRGazePointer.hidden">
            <summary>
            Is gaze pointer current visible
            </summary>
        </member>
        <member name="P:OVRGazePointer.currentScale">
            <summary>
            Current scale applied to pointer
            </summary>
        </member>
        <member name="F:OVRGazePointer.depth">
            <summary>
            Current depth of pointer from camera
            </summary>
        </member>
        <member name="F:OVRGazePointer.positionSetsThisFrame">
            <summary>
            How many times position has been set this frame. Used to detect when there are no position sets in a frame.
            </summary>
        </member>
        <member name="F:OVRGazePointer.lastShowRequestTime">
            <summary>
            Last time code requested the pointer be shown. Usually when pointer passes over interactive elements.
            </summary>
        </member>
        <member name="F:OVRGazePointer.lastHideRequestTime">
            <summary>
            Last time pointer was requested to be hidden. Usually mouse pointer activity.
            </summary>
        </member>
        <member name="P:OVRGazePointer.visibilityStrength">
            <summary>
            Used to determine alpha level of gaze cursor. Could also be used to determine cursor size, for example, as the cursor fades out.
            </summary>
        </member>
        <member name="M:OVRGazePointer.SetCursorStartDest(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Set position and orientation of pointer
            </summary>
            <param name="pos"></param>
            <param name="normal"></param>
        </member>
        <member name="M:OVRGazePointer.RequestHide">
            <summary>
            Request the pointer be hidden
            </summary>
        </member>
        <member name="M:OVRGazePointer.RequestShow">
            <summary>
            Request the pointer be shown. Hide requests take priority
            </summary>
        </member>
        <member name="T:OVRGrabbable">
            <summary>
            An object that can be grabbed and thrown by OVRGrabber.
            </summary>
        </member>
        <member name="P:OVRGrabbable.allowOffhandGrab">
            <summary>
            If true, the object can currently be grabbed.
            </summary>
        </member>
        <member name="P:OVRGrabbable.isGrabbed">
            <summary>
            If true, the object is currently grabbed.
            </summary>
        </member>
        <member name="P:OVRGrabbable.snapPosition">
            <summary>
            If true, the object's position will snap to match snapOffset when grabbed.
            </summary>
        </member>
        <member name="P:OVRGrabbable.snapOrientation">
            <summary>
            If true, the object's orientation will snap to match snapOffset when grabbed.
            </summary>
        </member>
        <member name="P:OVRGrabbable.snapOffset">
            <summary>
            An offset relative to the OVRGrabber where this object can snap when grabbed.
            </summary>
        </member>
        <member name="P:OVRGrabbable.grabbedBy">
            <summary>
            Returns the OVRGrabber currently grabbing this object.
            </summary>
        </member>
        <member name="P:OVRGrabbable.grabbedTransform">
            <summary>
            The transform at which this object was grabbed.
            </summary>
        </member>
        <member name="P:OVRGrabbable.grabbedRigidbody">
            <summary>
            The Rigidbody of the collider that was used to grab this object.
            </summary>
        </member>
        <member name="P:OVRGrabbable.grabPoints">
            <summary>
            The contact point(s) where the object was grabbed.
            </summary>
        </member>
        <member name="M:OVRGrabbable.GrabBegin(OVRGrabber,UnityEngine.Collider)">
            <summary>
            Notifies the object that it has been grabbed.
            </summary>
        </member>
        <member name="M:OVRGrabbable.GrabEnd(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Notifies the object that it has been released.
            </summary>
        </member>
        <member name="T:OVRGrabber">
            <summary>
            Allows grabbing and throwing of objects with the OVRGrabbable component on them.
            </summary>
        </member>
        <member name="P:OVRGrabber.grabbedObject">
            <summary>
            The currently grabbed object.
            </summary>
        </member>
        <member name="T:OVRGridCube">
            <summary>
            Diagnostic display with a regular grid of cubes for visual testing of
            tracking and distortion.
            </summary>
        </member>
        <member name="F:OVRGridCube.GridKey">
            <summary>
            The key that toggles the grid of cubes.
            </summary>
        </member>
        <member name="M:OVRGridCube.Update">
            <summary>
            Update this instance.
            </summary>
        </member>
        <member name="M:OVRGridCube.SetOVRCameraController(OVRCameraRig@)">
            <summary>
            Sets the OVR camera controller.
            </summary>
            <param name="cameraController">Camera controller.</param>
        </member>
        <member name="M:OVRGridCube.CubeGridSwitchColor(System.Boolean)">
            <summary>
            Switch the Cube grid color.
            </summary>
            <param name="CubeSwitchColor">If set to <c>true</c> cube switch color.</param>
        </member>
        <member name="T:OVRHaptics">
            <summary>
            Plays tactile effects on a tracked VR controller.
            </summary>
        </member>
        <member name="T:OVRHaptics.Config">
            <summary>
            Determines the target format for haptics data on a specific device.
            </summary>
        </member>
        <member name="T:OVRHaptics.OVRHapticsChannel">
            <summary>
            A track of haptics data that can be mixed or sequenced with another track.
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsChannel.#ctor(System.UInt32)">
            <summary>
            Constructs a channel targeting the specified output.
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsChannel.Preempt(OVRHapticsClip)">
            <summary>
            Cancels any currently-playing clips and immediatly plays the specified clip instead.
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsChannel.Queue(OVRHapticsClip)">
            <summary>
            Enqueues the specified clip to play after any currently-playing clips finish.
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsChannel.Mix(OVRHapticsClip)">
            <summary>
            Adds the specified clip to play simultaneously to the currently-playing clip(s).
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsChannel.Clear">
            <summary>
            Cancels any currently-playing clips.
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsOutput.Process">
            <summary>
            The system calls this each frame to update haptics playback.
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsOutput.Preempt(OVRHapticsClip)">
            <summary>
            Immediately plays the specified clip without waiting for any currently-playing clip to finish.
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsOutput.Queue(OVRHapticsClip)">
            <summary>
            Enqueues the specified clip to play after any currently-playing clip finishes.
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsOutput.Mix(OVRHapticsClip)">
            <summary>
            Adds the samples from the specified clip to the ones in the currently-playing clip(s).
            </summary>
        </member>
        <member name="M:OVRHaptics.Process">
            <summary>
            The system calls this each frame to update haptics playback.
            </summary>
        </member>
        <member name="T:OVRHapticsClip">
            <summary>
            A PCM buffer of data for a haptics effect.
            </summary>
        </member>
        <member name="P:OVRHapticsClip.Count">
            <summary>
            The current number of samples in the clip.
            </summary>
        </member>
        <member name="P:OVRHapticsClip.Capacity">
            <summary>
            The maximum number of samples the clip can store.
            </summary>
        </member>
        <member name="P:OVRHapticsClip.Samples">
            <summary>
            The raw haptics data.
            </summary>
        </member>
        <member name="M:OVRHapticsClip.#ctor(System.Int32)">
            <summary>
            Creates a clip with the specified capacity.
            </summary>
        </member>
        <member name="M:OVRHapticsClip.#ctor(System.Byte[],System.Int32)">
            <summary>
            Creates a clip with the specified data.
            </summary>
        </member>
        <member name="M:OVRHapticsClip.#ctor(OVRHapticsClip,OVRHapticsClip)">
            <summary>
            Creates a clip by mixing the specified clips.
            </summary>
        </member>
        <member name="M:OVRHapticsClip.#ctor(UnityEngine.AudioClip,System.Int32)">
            <summary>
            Creates a haptics clip from the specified audio clip.
            </summary>
        </member>
        <member name="M:OVRHapticsClip.WriteSample(System.Byte)">
            <summary>
            Adds the specified sample to the end of the clip.
            </summary>
        </member>
        <member name="M:OVRHapticsClip.Reset">
            <summary>
            Clears the clip and resets its size to 0.
            </summary>
        </member>
        <member name="T:OVRInput">
            <summary>
            Provides a unified input system for Oculus controllers and gamepads.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.One" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Two" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Three" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Four" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Start" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Back" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryShoulder" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryHandTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryThumbstickUp" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryThumbstickDown" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryThumbstickLeft" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryThumbstickRight" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryTouchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryShoulder" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryHandTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryThumbstickUp" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryThumbstickDown" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryThumbstickLeft" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryThumbstickRight" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryTouchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.DpadUp" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.DpadDown" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.DpadLeft" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.DpadRight" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Up" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Down" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Left" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Right" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.A" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.B" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.X" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.Y" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.Start" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.Back" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LShoulder" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LHandTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LThumbstickUp" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LThumbstickDown" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LThumbstickLeft" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LThumbstickRight" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LTouchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RShoulder" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RHandTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RThumbstickUp" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RThumbstickDown" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RThumbstickLeft" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RThumbstickRight" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RTouchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.DpadUp" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.DpadDown" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.DpadLeft" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.DpadRight" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.One" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.Two" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.Three" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.Four" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.PrimaryIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.PrimaryThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.PrimaryThumbRest" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.PrimaryTouchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.SecondaryIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.SecondaryThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.SecondaryThumbRest" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.SecondaryTouchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.A" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.B" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.X" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.Y" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.LIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.LThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.LThumbRest" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.LTouchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.RIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.RThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.RThumbRest" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.RTouchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.NearTouch.PrimaryIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.NearTouch.PrimaryThumbButtons" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.NearTouch.SecondaryIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.NearTouch.SecondaryThumbButtons" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.NearTouch.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawNearTouch.LIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawNearTouch.LThumbButtons" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawNearTouch.RIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawNearTouch.RThumbButtons" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawNearTouch.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis1D.PrimaryIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis1D.PrimaryHandTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis1D.SecondaryIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis1D.SecondaryHandTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis1D.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis1D.LIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis1D.LHandTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis1D.RIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis1D.RHandTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis1D.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis2D.PrimaryThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis2D.PrimaryTouchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis2D.SecondaryThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis2D.SecondaryTouchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis2D.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis2D.LThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis2D.LTouchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis2D.RThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis2D.RTouchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis2D.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.LTouch" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.RTouch" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.Touch" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.Remote" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.Gamepad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.Touchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.LTrackedRemote" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.RTrackedRemote" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.Active" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.All" -->
        <member name="M:OVRInput.#cctor">
            <summary>
            Creates an instance of OVRInput.
            </summary>
        </member>
        <member name="M:OVRInput.Update">
            <summary>
            Updates the internal state of OVRInput. Must be called manually if used independently from OVRManager.
            </summary>
        </member>
        <member name="M:OVRInput.FixedUpdate">
            <summary>
            Updates the internal physics state of OVRInput. Must be called manually if used independently from OVRManager.
            </summary>
        </member>
        <member name="M:OVRInput.GetControllerOrientationTracked(OVRInput.Controller)">
            <summary>
            Returns true if the given Controller's orientation is currently tracked.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return false.
            </summary>
        </member>
        <member name="M:OVRInput.GetControllerOrientationValid(OVRInput.Controller)">
            <summary>
            Returns true if the given Controller's orientation is currently valid.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return false.
            </summary>
        </member>
        <member name="M:OVRInput.GetControllerPositionTracked(OVRInput.Controller)">
            <summary>
            Returns true if the given Controller's position is currently tracked.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return false.
            </summary>
        </member>
        <member name="M:OVRInput.GetControllerPositionValid(OVRInput.Controller)">
            <summary>
            Returns true if the given Controller's position is currently valid.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return false.
            </summary>
        </member>
        <member name="M:OVRInput.GetLocalControllerPosition(OVRInput.Controller)">
            <summary>
            Gets the position of the given Controller local to its tracking space.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return Vector3.zero.
            </summary>
        </member>
        <member name="M:OVRInput.GetLocalControllerVelocity(OVRInput.Controller)">
            <summary>
            Gets the linear velocity of the given Controller local to its tracking space.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return Vector3.zero.
            </summary>
        </member>
        <member name="M:OVRInput.GetLocalControllerAcceleration(OVRInput.Controller)">
            <summary>
            Gets the linear acceleration of the given Controller local to its tracking space.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return Vector3.zero.
            </summary>
        </member>
        <member name="M:OVRInput.GetLocalControllerRotation(OVRInput.Controller)">
            <summary>
            Gets the rotation of the given Controller local to its tracking space.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return Quaternion.identity.
            </summary>
        </member>
        <member name="M:OVRInput.GetLocalControllerAngularVelocity(OVRInput.Controller)">
            <summary>
            Gets the angular velocity of the given Controller local to its tracking space in radians per second around each axis.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return Vector3.zero.
            </summary>
        </member>
        <member name="M:OVRInput.GetLocalControllerAngularAcceleration(OVRInput.Controller)">
            <summary>
            Gets the angular acceleration of the given Controller local to its tracking space in radians per second per second around each axis.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return Vector3.zero.
            </summary>
        </member>
        <member name="M:OVRInput.GetDominantHand">
            <summary>
            Gets the dominant hand that the user has specified in settings, for mobile devices.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.Button,OVRInput.Controller)">
            <summary>
            Gets the current state of the given virtual button mask with the given controller mask.
            Returns true if any masked button is down on any masked controller.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.RawButton,OVRInput.Controller)">
            <summary>
            Gets the current state of the given raw button mask with the given controller mask.
            Returns true if any masked button is down on any masked controllers.
            </summary>
        </member>
        <member name="M:OVRInput.GetDown(OVRInput.Button,OVRInput.Controller)">
            <summary>
            Gets the current down state of the given virtual button mask with the given controller mask.
            Returns true if any masked button was pressed this frame on any masked controller and no masked button was previously down last frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetDown(OVRInput.RawButton,OVRInput.Controller)">
            <summary>
            Gets the current down state of the given raw button mask with the given controller mask.
            Returns true if any masked button was pressed this frame on any masked controller and no masked button was previously down last frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetUp(OVRInput.Button,OVRInput.Controller)">
            <summary>
            Gets the current up state of the given virtual button mask with the given controller mask.
            Returns true if any masked button was released this frame on any masked controller and no other masked button is still down this frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetUp(OVRInput.RawButton,OVRInput.Controller)">
            <summary>
            Gets the current up state of the given raw button mask with the given controller mask.
            Returns true if any masked button was released this frame on any masked controller and no other masked button is still down this frame.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.Touch,OVRInput.Controller)">
            <summary>
            Gets the current state of the given virtual touch mask with the given controller mask.
            Returns true if any masked touch is down on any masked controller.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.RawTouch,OVRInput.Controller)">
            <summary>
            Gets the current state of the given raw touch mask with the given controller mask.
            Returns true if any masked touch is down on any masked controllers.
            </summary>
        </member>
        <member name="M:OVRInput.GetDown(OVRInput.Touch,OVRInput.Controller)">
            <summary>
            Gets the current down state of the given virtual touch mask with the given controller mask.
            Returns true if any masked touch was pressed this frame on any masked controller and no masked touch was previously down last frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetDown(OVRInput.RawTouch,OVRInput.Controller)">
            <summary>
            Gets the current down state of the given raw touch mask with the given controller mask.
            Returns true if any masked touch was pressed this frame on any masked controller and no masked touch was previously down last frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetUp(OVRInput.Touch,OVRInput.Controller)">
            <summary>
            Gets the current up state of the given virtual touch mask with the given controller mask.
            Returns true if any masked touch was released this frame on any masked controller and no other masked touch is still down this frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetUp(OVRInput.RawTouch,OVRInput.Controller)">
            <summary>
            Gets the current up state of the given raw touch mask with the given controller mask.
            Returns true if any masked touch was released this frame on any masked controller and no other masked touch is still down this frame.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.NearTouch,OVRInput.Controller)">
            <summary>
            Gets the current state of the given virtual near touch mask with the given controller mask.
            Returns true if any masked near touch is down on any masked controller.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.RawNearTouch,OVRInput.Controller)">
            <summary>
            Gets the current state of the given raw near touch mask with the given controller mask.
            Returns true if any masked near touch is down on any masked controllers.
            </summary>
        </member>
        <member name="M:OVRInput.GetDown(OVRInput.NearTouch,OVRInput.Controller)">
            <summary>
            Gets the current down state of the given virtual near touch mask with the given controller mask.
            Returns true if any masked near touch was pressed this frame on any masked controller and no masked near touch was previously down last frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetDown(OVRInput.RawNearTouch,OVRInput.Controller)">
            <summary>
            Gets the current down state of the given raw near touch mask with the given controller mask.
            Returns true if any masked near touch was pressed this frame on any masked controller and no masked near touch was previously down last frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetUp(OVRInput.NearTouch,OVRInput.Controller)">
            <summary>
            Gets the current up state of the given virtual near touch mask with the given controller mask.
            Returns true if any masked near touch was released this frame on any masked controller and no other masked near touch is still down this frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetUp(OVRInput.RawNearTouch,OVRInput.Controller)">
            <summary>
            Gets the current up state of the given raw near touch mask with the given controller mask.
            Returns true if any masked near touch was released this frame on any masked controller and no other masked near touch is still down this frame.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.Axis1D,OVRInput.Controller)">
            <summary>
            Gets the current state of the given virtual 1-dimensional axis mask on the given controller mask.
            Returns the value of the largest masked axis across all masked controllers. Values range from 0 to 1.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.RawAxis1D,OVRInput.Controller)">
            <summary>
            Gets the current state of the given raw 1-dimensional axis mask on the given controller mask.
            Returns the value of the largest masked axis across all masked controllers. Values range from 0 to 1.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.Axis2D,OVRInput.Controller)">
            <summary>
            Gets the current state of the given virtual 2-dimensional axis mask on the given controller mask.
            Returns the vector of the largest masked axis across all masked controllers. Values range from -1 to 1.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.RawAxis2D,OVRInput.Controller)">
            <summary>
            Gets the current state of the given raw 2-dimensional axis mask on the given controller mask.
            Returns the vector of the largest masked axis across all masked controllers. Values range from -1 to 1.
            </summary>
        </member>
        <member name="M:OVRInput.GetConnectedControllers">
            <summary>
            Returns a mask of all currently connected controller types.
            </summary>
        </member>
        <member name="M:OVRInput.IsControllerConnected(OVRInput.Controller)">
            <summary>
            Returns true if the specified controller type is currently connected.
            </summary>
        </member>
        <member name="M:OVRInput.GetActiveController">
            <summary>
            Returns the current active controller type.
            </summary>
        </member>
        <member name="M:OVRInput.SetOpenVRLocalPose(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Quaternion)">
            <summary>
            Sets OpenVR left and right controller poses local to tracking space
            </summary>
        </member>
        <member name="M:OVRInput.GetOpenVRStringProperty(OVR.OpenVR.ETrackedDeviceProperty,System.UInt32)">
            <summary>
            Accesses OpenVR properties about a given deviceID. Especially useful for differentiating per type of OpenVR device (i.e. Oculus, Vive)
            </summary>
        </member>
        <member name="M:OVRInput.UpdateXRControllerNodeIds">
            <summary>
            Associates OpenVR device IDs with left and right motion controllers, for later haptic playback.
            </summary>
        </member>
        <member name="M:OVRInput.UpdateXRControllerHaptics">
            <summary>
            Runs once a frame to update cross-platform haptic playback
            </summary>
        </member>
        <member name="M:OVRInput.SetControllerVibration(System.Single,System.Single,OVRInput.Controller)">
            <summary>
            Activates vibration with the given frequency and amplitude with the given controller mask.
            Ignored on controllers that do not support vibration. Expected values range from 0 to 1.
            </summary>
        </member>
        <member name="M:OVRInput.RecenterController(OVRInput.Controller)">
            <summary>
            Triggers a recenter to realign the specified controller's virtual pose with the user's real-world pose.
            Only applicable to controllers that require recentering, such as the GearVR Controller.
            Ignored for controllers that do not require recentering.
            </summary>
        </member>
        <member name="M:OVRInput.GetControllerWasRecentered(OVRInput.Controller)">
            <summary>
            Returns true if the specified controller was recentered this frame.
            Only applicable to controllers that require recentering, such as the GearVR Controller.
            Returns false for controllers that do not require recentering.
            </summary>
        </member>
        <member name="M:OVRInput.GetControllerRecenterCount(OVRInput.Controller)">
            <summary>
            Returns the number of times the controller has been recentered this session.
            Useful for detecting recenter events and resetting state such as arm model simulations, etc.
            Wraps around to 0 after 255.
            Only applicable to controllers that require recentering, such as the GearVR Controller.
            Returns 0 for controllers that do not require recentering.
            </summary>
        </member>
        <member name="M:OVRInput.GetControllerBatteryPercentRemaining(OVRInput.Controller)">
            <summary>
            Returns the battery percentage remaining for the specified controller. Values range from 0 to 100.
            Only applicable to controllers that report battery level, such as the GearVR Controller.
            Returns 0 for controllers that do not report battery level.
            </summary>
        </member>
        <member name="T:OVRInput.OVRControllerGamepadMac.AxisGPC">
            <summary> An axis on the gamepad. </summary>
        </member>
        <member name="T:OVRInput.OVRControllerGamepadMac.ButtonGPC">
            <summary> A button on the gamepad. </summary>
        </member>
        <member name="T:UnityEngine.EventSystems.OVRInputModule">
            <summary>
            VR extension of PointerInputModule which supports gaze and controller pointing.
            </summary>
        </member>
        <member name="F:UnityEngine.EventSystems.OVRInputModule.m_VerticalAxis">
            <summary>
            Name of the vertical axis for movement (if axis events are used).
            </summary>
        </member>
        <member name="F:UnityEngine.EventSystems.OVRInputModule.m_SubmitButton">
            <summary>
            Name of the submit button.
            </summary>
        </member>
        <member name="F:UnityEngine.EventSystems.OVRInputModule.m_CancelButton">
            <summary>
            Name of the submit button.
            </summary>
        </member>
        <member name="P:UnityEngine.EventSystems.OVRInputModule.horizontalAxis">
            <summary>
            Name of the horizontal axis for movement (if axis events are used).
            </summary>
        </member>
        <member name="P:UnityEngine.EventSystems.OVRInputModule.verticalAxis">
            <summary>
            Name of the vertical axis for movement (if axis events are used).
            </summary>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.SendSubmitEventToSelectedObject">
            <summary>
            Process submit keys.
            </summary>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.SendMoveEventToSelectedObject">
            <summary>
            Process keyboard events.
            </summary>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.ProcessMousePress(UnityEngine.EventSystems.PointerInputModule.MouseButtonEventData)">
            <summary>
            Process the current mouse press.
            </summary>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.ProcessMouseEvent(UnityEngine.EventSystems.PointerInputModule.MouseState)">
            <summary>
            Process all mouse events. This is the same as the StandaloneInputModule version except that
            it takes MouseState as a parameter, allowing it to be used for both Gaze and Mouse
            pointerss.
            </summary>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.Process">
            <summary>
            Process this InputModule. Same as the StandaloneInputModule version, except that it calls
            ProcessMouseEvent twice, once for gaze pointers, and once for mouse pointers.
            </summary>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.UseMouse(System.Boolean,System.Boolean,UnityEngine.EventSystems.PointerEventData)">
            <summary>
            Decide if mouse events need to be processed this frame. Same as StandloneInputModule except
            that the IsPointerMoving method from this class is used, instead of the method on PointerEventData
            </summary>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.CopyFromTo(UnityEngine.EventSystems.OVRPointerEventData,UnityEngine.EventSystems.OVRPointerEventData)">
            <summary>
            Convenience function for cloning PointerEventData
            </summary>
            <param name="from">Copy this value</param>
            <param name="to">to this object</param>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.CopyFromTo(UnityEngine.EventSystems.PointerEventData,UnityEngine.EventSystems.PointerEventData)">
            <summary>
            Convenience function for cloning PointerEventData
            </summary>
            <param name="from">Copy this value</param>
            <param name="to">to this object</param>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.ClearSelection">
            <summary>
            Clear pointer state for both types of pointer
            </summary>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.GetRectTransformNormal(UnityEngine.RectTransform)">
            <summary>
            For RectTransform, calculate it's normal in world space
            </summary>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.GetGazePointerData">
            <summary>
            State for a pointer controlled by a world space ray. E.g. gaze pointer
            </summary>
            <returns></returns>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.GetCanvasPointerData">
            <summary>
            Get state for pointer which is a pointer moving in world space across the surface of a world space canvas.
            </summary>
            <returns></returns>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.ShouldStartDrag(UnityEngine.EventSystems.PointerEventData)">
            <summary>
            New version of ShouldStartDrag implemented first in PointerInputModule. This version differs in that
            for ray based pointers it makes a decision about whether a drag should start based on the angular change
            the pointer has made so far, as seen from the camera. This also works when the world space ray is
            translated rather than rotated, since the beginning and end of the movement are considered as angle from
            the same point.
            </summary>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.IsPointerMoving(UnityEngine.EventSystems.PointerEventData)">
             <summary>
             The purpose of this function is to allow us to switch between using the standard IsPointerMoving
             method for mouse driven pointers, but to always return true when it's a ray based pointer.
             All real-world ray-based input devices are always moving so for simplicity we just return true
             for them.
            
             If PointerEventData.IsPointerMoving was virtual we could just override that in
             OVRRayPointerEventData.
             </summary>
             <param name="pointerEvent"></param>
             <returns></returns>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.ProcessDrag(UnityEngine.EventSystems.PointerEventData)">
             <summary>
             Exactly the same as the code from PointerInputModule, except that we call our own
             IsPointerMoving.
            
             This would also not be necessary if PointerEventData.IsPointerMoving was virtual
             </summary>
             <param name="pointerEvent"></param>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.GetGazeButtonState">
            <summary>
            Get state of button corresponding to gaze pointer
            </summary>
            <returns></returns>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.GetExtraScrollDelta">
            <summary>
            Get extra scroll delta from gamepad
            </summary>
        </member>
        <member name="T:UnityEngine.EventSystems.OVRPhysicsRaycaster">
            <summary>
            Simple event system using physics raycasts. Very closely based on UnityEngine.EventSystems.PhysicsRaycaster
            </summary>
        </member>
        <member name="F:UnityEngine.EventSystems.OVRPhysicsRaycaster.kNoEventMaskSet">
            <summary>
            Const to use for clarity when no event mask is set
            </summary>
        </member>
        <member name="F:UnityEngine.EventSystems.OVRPhysicsRaycaster.m_EventMask">
            <summary>
            Layer mask used to filter events. Always combined with the camera's culling mask if a camera is used.
            </summary>
        </member>
        <member name="P:UnityEngine.EventSystems.OVRPhysicsRaycaster.depth">
            <summary>
            Depth used to determine the order of event processing.
            </summary>
        </member>
        <member name="P:UnityEngine.EventSystems.OVRPhysicsRaycaster.finalEventMask">
            <summary>
            Event mask used to determine which objects will receive events.
            </summary>
        </member>
        <member name="P:UnityEngine.EventSystems.OVRPhysicsRaycaster.eventMask">
            <summary>
            Layer mask used to filter events. Always combined with the camera's culling mask if a camera is used.
            </summary>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRPhysicsRaycaster.Raycast(UnityEngine.EventSystems.PointerEventData,System.Collections.Generic.List{UnityEngine.EventSystems.RaycastResult})">
            <summary>
            Perform a raycast using the worldSpaceRay in eventData.
            </summary>
            <param name="eventData"></param>
            <param name="resultAppendList"></param>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRPhysicsRaycaster.Spherecast(UnityEngine.EventSystems.PointerEventData,System.Collections.Generic.List{UnityEngine.EventSystems.RaycastResult},System.Single)">
            <summary>
             Perform a Spherecast using the worldSpaceRay in eventData.
            </summary>
            <param name="eventData"></param>
            <param name="resultAppendList"></param>
            <param name="radius">Radius of the sphere</param>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRPhysicsRaycaster.GetScreenPos(UnityEngine.Vector3)">
            <summary>
            Get screen position of this world position as seen by the event camera of this OVRPhysicsRaycaster
            </summary>
            <param name="worldPosition"></param>
            <returns></returns>
        </member>
        <member name="T:UnityEngine.EventSystems.OVRPointerEventData">
            <summary>
            Extension of Unity's PointerEventData to support ray based pointing and also touchpad swiping
            </summary>
        </member>
        <member name="T:UnityEngine.EventSystems.PointerEventDataExtension">
            <summary>
            Static helpers for OVRPointerEventData.
            </summary>
        </member>
        <member name="T:OVRLayerAttribute">
            <summary>
            Dummy subtype of PropertyAttribute for custom inspector to use.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:OVRLint" -->
        <member name="F:OVRLint.mRecords">
            Use of ONSP reflections (Gear)
            Use of LoadLevelAsync / LoadLevelAdditiveAsync (on Gear, this kills frame rate so dramatically it's probably better to just go to black and load synchronously)
            Use of Linq in non-editor assemblies (common cause of GCs).  Minor: use of foreach.
            Use of Unity WWW (exceptionally high overhead for large file downloads, but acceptable for tiny gets).
            Declared but empty Awake/Start/Update/OnCollisionEnter/OnCollisionExit/OnCollisionStay.  Also OnCollision* star methods that declare the Collision  argument but do not reference it (omitting it short-circuits the collision contact calculation).
        </member>
        <member name="T:OVRManager">
            <summary>
            Configuration data for Oculus virtual reality.
            </summary>
        </member>
        <member name="P:OVRManager.instance">
            <summary>
            Gets the singleton instance.
            </summary>
        </member>
        <member name="P:OVRManager.display">
            <summary>
            Gets a reference to the active display.
            </summary>
        </member>
        <member name="P:OVRManager.tracker">
            <summary>
            Gets a reference to the active sensor.
            </summary>
        </member>
        <member name="P:OVRManager.boundary">
            <summary>
            Gets a reference to the active boundary system.
            </summary>
        </member>
        <member name="P:OVRManager.profile">
            <summary>
            Gets the current profile, which contains information about the user's settings and body dimensions.
            </summary>
        </member>
        <member name="E:OVRManager.HMDAcquired">
            <summary>
            Occurs when an HMD attached.
            </summary>
        </member>
        <member name="E:OVRManager.HMDLost">
            <summary>
            Occurs when an HMD detached.
            </summary>
        </member>
        <member name="E:OVRManager.HMDMounted">
            <summary>
            Occurs when an HMD is put on the user's head.
            </summary>
        </member>
        <member name="E:OVRManager.HMDUnmounted">
            <summary>
            Occurs when an HMD is taken off the user's head.
            </summary>
        </member>
        <member name="E:OVRManager.VrFocusAcquired">
            <summary>
            Occurs when VR Focus is acquired.
            </summary>
        </member>
        <member name="E:OVRManager.VrFocusLost">
            <summary>
            Occurs when VR Focus is lost.
            </summary>
        </member>
        <member name="E:OVRManager.InputFocusAcquired">
            <summary>
            Occurs when Input Focus is acquired.
            </summary>
        </member>
        <member name="E:OVRManager.InputFocusLost">
            <summary>
            Occurs when Input Focus is lost.
            </summary>
        </member>
        <member name="E:OVRManager.AudioOutChanged">
            <summary>
            Occurs when the active Audio Out device has changed and a restart is needed.
            </summary>
        </member>
        <member name="E:OVRManager.AudioInChanged">
            <summary>
            Occurs when the active Audio In device has changed and a restart is needed.
            </summary>
        </member>
        <member name="E:OVRManager.TrackingAcquired">
            <summary>
            Occurs when the sensor gained tracking.
            </summary>
        </member>
        <member name="E:OVRManager.TrackingLost">
            <summary>
            Occurs when the sensor lost tracking.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "E:OVRManager.HSWDismissed" -->
        <member name="P:OVRManager.isHmdPresent">
            <summary>
            If true, a head-mounted display is connected and present.
            </summary>
        </member>
        <member name="P:OVRManager.audioOutId">
            <summary>
            Gets the audio output device identifier.
            </summary>
            <description>
            On Windows, this is a string containing the GUID of the IMMDevice for the Windows audio endpoint to use.
            </description>
        </member>
        <member name="P:OVRManager.audioInId">
            <summary>
            Gets the audio input device identifier.
            </summary>
            <description>
            On Windows, this is a string containing the GUID of the IMMDevice for the Windows audio endpoint to use.
            </description>
        </member>
        <member name="P:OVRManager.hasVrFocus">
            <summary>
            If true, the app has VR Focus.
            </summary>
        </member>
        <member name="P:OVRManager.hasInputFocus">
            <summary>
            If true, the app has Input Focus.
            </summary>
        </member>
        <member name="P:OVRManager.chromatic">
            <summary>
            If true, chromatic de-aberration will be applied, improving the image at the cost of texture bandwidth.
            </summary>
        </member>
        <member name="F:OVRManager.useRecommendedMSAALevel">
            <summary>
            If true, Unity will use the optimal antialiasing level for quality/performance on the current hardware.
            </summary>
        </member>
        <member name="F:OVRManager._monoscopic">
            <summary>
            If true, both eyes will see the same image, rendered from the center eye pose, saving performance.
            </summary>
        </member>
        <member name="F:OVRManager.enableAdaptiveResolution">
            <summary>
            If true, dynamic resolution will be enabled
            </summary>
        </member>
        <member name="M:OVRManager.IsAdaptiveResSupportedByEngine">
            <summary>
            Adaptive Resolution is based on Unity engine's renderViewportScale/eyeTextureResolutionScale feature
            But renderViewportScale was broken in an array of Unity engines, this function help to filter out those broken engines
            </summary>
        </member>
        <member name="F:OVRManager.minRenderScale">
            <summary>
            Min RenderScale the app can reach under adaptive resolution mode ( enableAdaptiveResolution = true );
            </summary>
        </member>
        <member name="F:OVRManager.maxRenderScale">
            <summary>
            Max RenderScale the app can reach under adaptive resolution mode ( enableAdaptiveResolution = true );
            </summary>
        </member>
        <member name="F:OVRManager._headPoseRelativeOffsetRotation">
            <summary>
            Set the relative offset rotation of head poses
            </summary>
        </member>
        <member name="F:OVRManager._headPoseRelativeOffsetTranslation">
            <summary>
            Set the relative offset translation of head poses
            </summary>
        </member>
        <member name="F:OVRManager.profilerTcpPort">
            <summary>
            The TCP listening port of Oculus Profiler Service, which will be activated in Debug/Developerment builds
            When the app is running on editor or device, open "Tools/Oculus/Oculus Profiler Panel" to view the realtime system metrics
            </summary>
        </member>
        <member name="F:OVRManager.expandMixedRealityCapturePropertySheet">
            <summary>
            If true, the MixedRealityCapture properties will be displayed
            </summary>
        </member>
        <member name="F:OVRManager.enableMixedReality">
            <summary>
            If true, Mixed Reality mode will be enabled
            </summary>
        </member>
        <member name="F:OVRManager.compositionMethod">
            <summary>
            Composition method
            </summary>
        </member>
        <member name="F:OVRManager.extraHiddenLayers">
            <summary>
            Extra hidden layers
            </summary>
        </member>
        <member name="F:OVRManager.externalCompositionBackdropColor">
            <summary>
            The backdrop color will be used when rendering the foreground frames. It only applies to External Composition.
            </summary>
        </member>
        <member name="T:OVRManager.CameraDevice">
            <summary>
            If true, Mixed Reality mode will use direct composition from the first web camera
            </summary>
        </member>
        <member name="F:OVRManager.capturingCameraDevice">
            <summary>
            The camera device for direct composition
            </summary>
        </member>
        <member name="F:OVRManager.flipCameraFrameHorizontally">
            <summary>
            Flip the camera frame horizontally
            </summary>
        </member>
        <member name="F:OVRManager.flipCameraFrameVertically">
            <summary>
            Flip the camera frame vertically
            </summary>
        </member>
        <member name="F:OVRManager.handPoseStateLatency">
            <summary>
            Delay the touch controller pose by a short duration (0 to 0.5 second) to match the physical camera latency
            </summary>
        </member>
        <member name="F:OVRManager.sandwichCompositionRenderLatency">
            <summary>
            Delay the foreground / background image in the sandwich composition to match the physical camera latency. The maximum duration is sandwichCompositionBufferedFrames / {Game FPS}
            </summary>
        </member>
        <member name="F:OVRManager.sandwichCompositionBufferedFrames">
            <summary>
            The number of frames are buffered in the SandWich composition. The more buffered frames, the more memory it would consume.
            </summary>
        </member>
        <member name="F:OVRManager.chromaKeyColor">
            <summary>
            Chroma Key Color
            </summary>
        </member>
        <member name="F:OVRManager.chromaKeySimilarity">
            <summary>
            Chroma Key Similarity
            </summary>
        </member>
        <member name="F:OVRManager.chromaKeySmoothRange">
            <summary>
            Chroma Key Smooth Range
            </summary>
        </member>
        <member name="F:OVRManager.chromaKeySpillRange">
            <summary>
             Chroma Key Spill Range
            </summary>
        </member>
        <member name="F:OVRManager.useDynamicLighting">
            <summary>
            Use dynamic lighting (Depth sensor required)
            </summary>
        </member>
        <member name="F:OVRManager.depthQuality">
            <summary>
            The quality level of depth image. The lighting could be more smooth and accurate with high quality depth, but it would also be more costly in performance.
            </summary>
        </member>
        <member name="F:OVRManager.dynamicLightingSmoothFactor">
            <summary>
            Smooth factor in dynamic lighting. Larger is smoother
            </summary>
        </member>
        <member name="F:OVRManager.dynamicLightingDepthVariationClampingValue">
            <summary>
            The maximum depth variation across the edges. Make it smaller to smooth the lighting on the edges.
            </summary>
        </member>
        <member name="F:OVRManager.virtualGreenScreenType">
            <summary>
            Set the current type of the virtual green screen
            </summary>
        </member>
        <member name="F:OVRManager.virtualGreenScreenTopY">
            <summary>
            Top Y of virtual screen
            </summary>
        </member>
        <member name="F:OVRManager.virtualGreenScreenBottomY">
            <summary>
            Bottom Y of virtual screen
            </summary>
        </member>
        <member name="F:OVRManager.virtualGreenScreenApplyDepthCulling">
            <summary>
            When using a depth camera (e.g. ZED), whether to use the depth in virtual green screen culling.
            </summary>
        </member>
        <member name="F:OVRManager.virtualGreenScreenDepthTolerance">
            <summary>
            The tolerance value (in meter) when using the virtual green screen with a depth camera. Make it bigger if the foreground objects got culled incorrectly.
            </summary>
        </member>
        <member name="F:OVRManager.mrcActivationMode">
            <summary>
            (Quest-only) control if the mixed reality capture mode can be activated automatically through remote network connection.
            </summary>
        </member>
        <member name="P:OVRManager.vsyncCount">
            <summary>
            The number of expected display frames per rendered frame.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:OVRManager.batteryLevel" -->
        <!-- Badly formed XML comment ignored for member "P:OVRManager.batteryTemperature" -->
        <!-- Badly formed XML comment ignored for member "P:OVRManager.batteryStatus" -->
        <!-- Badly formed XML comment ignored for member "P:OVRManager.volumeLevel" -->
        <member name="P:OVRManager.cpuLevel">
            <summary>
            Gets or sets the current CPU performance level (0-2). Lower performance levels save more power.
            </summary>
        </member>
        <member name="P:OVRManager.gpuLevel">
            <summary>
            Gets or sets the current GPU performance level (0-2). Lower performance levels save more power.
            </summary>
        </member>
        <member name="P:OVRManager.isPowerSavingActive">
            <summary>
            If true, the CPU and GPU are currently throttled to save power and/or reduce the temperature.
            </summary>
        </member>
        <member name="P:OVRManager.eyeTextureFormat">
            <summary>
            Gets or sets the eye texture format.
            </summary>
        </member>
        <member name="P:OVRManager.fixedFoveatedRenderingSupported">
            <summary>
            Gets if tiled-based multi-resolution technique is supported
            This feature is only supported on QCOMM-based Android devices
            </summary>
        </member>
        <member name="P:OVRManager.fixedFoveatedRenderingLevel">
            <summary>
            Gets or sets the tiled-based multi-resolution level
            This feature is only supported on QCOMM-based Android devices
            </summary>
        </member>
        <member name="P:OVRManager.gpuUtilSupported">
            <summary>
            Gets if the GPU Utility is supported
            This feature is only supported on QCOMM-based Android devices
            </summary>
        </member>
        <member name="P:OVRManager.gpuUtilLevel">
            <summary>
            Gets the GPU Utilised Level (0.0 - 1.0)
            This feature is only supported on QCOMM-based Android devices
            </summary>
        </member>
        <member name="M:OVRManager.SetColorScaleAndOffset(UnityEngine.Vector4,UnityEngine.Vector4,System.Boolean)">
            <summary>
            Sets the Color Scale and Offset which is commonly used for effects like fade-to-black.
            In our compositor, once a given frame is rendered, warped, and ready to be displayed, we then multiply
            each pixel by colorScale and add it to colorOffset, whereby newPixel = oldPixel * colorScale + colorOffset.
            Note that for mobile devices (Quest, Go, etc.), colorOffset is not supported, so colorScale is all that can
            be used. A colorScale of (1, 1, 1, 1) and colorOffset of (0, 0, 0, 0) will lead to an identity multiplication
            and have no effect.
            </summary>
        </member>
        <member name="M:OVRManager.SetOpenVRLocalPose(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Quaternion)">
            <summary>
            Specifies OpenVR pose local to tracking space
            </summary>
        </member>
        <member name="M:OVRManager.GetOpenVRControllerOffset(UnityEngine.XR.XRNode)">
            <summary>
            Specifies the pose offset required to make an OpenVR controller's reported pose match the virtual pose.
            Currently we only specify this offset for Oculus Touch on OpenVR.
            </summary>
        </member>
        <member name="P:OVRManager.trackingOriginType">
            <summary>
            Defines the current tracking origin type.
            </summary>
        </member>
        <member name="F:OVRManager.usePositionTracking">
            <summary>
            If true, head tracking will affect the position of each OVRCameraRig's cameras.
            </summary>
        </member>
        <member name="F:OVRManager.useRotationTracking">
            <summary>
            If true, head tracking will affect the rotation of each OVRCameraRig's cameras.
            </summary>
        </member>
        <member name="F:OVRManager.useIPDInPositionTracking">
            <summary>
            If true, the distance between the user's eyes will affect the position of each OVRCameraRig's cameras.
            </summary>
        </member>
        <member name="F:OVRManager.resetTrackerOnLoad">
            <summary>
            If true, each scene load will cause the head pose to reset.
            </summary>
        </member>
        <member name="F:OVRManager.AllowRecenter">
            <summary>
            If true, the Reset View in the universal menu will cause the pose to be reset. This should generally be
            enabled for applications with a stationary position in the virtual world and will allow the View Reset
            command to place the person back to a predefined location (such as a cockpit seat).
            Set this to false if you have a locomotion system because resetting the view would effectively teleport
            the player to potentially invalid locations.
            </summary>
        </member>
        <member name="P:OVRManager.reorientHMDOnControllerRecenter">
            <summary>
            Defines the recentering mode specified in the tooltip above.
            </summary>
        </member>
        <member name="P:OVRManager.isSupportedPlatform">
            <summary>
            True if the current platform supports virtual reality.
            </summary>
        </member>
        <member name="P:OVRManager.isUserPresent">
            <summary>
            True if the user is currently wearing the display.
            </summary>
        </member>
        <member name="M:OVRManager.ReturnToLauncher">
            <summary>
            Leaves the application/game and returns to the launcher/dashboard
            </summary>
        </member>
        <member name="T:OVRMixedReality">
            <summary>
            Manages mix-reality elements
            </summary>
        </member>
        <member name="F:OVRMixedReality.useFakeExternalCamera">
            <summary>
            For Debugging purpose, we can use preset parameters to fake a camera when external camera is not available
            </summary>
        </member>
        <member name="F:OVRMixedReality.currentComposition">
            <summary>
            Composition object
            </summary>
        </member>
        <member name="M:OVRMixedReality.Update(UnityEngine.GameObject,UnityEngine.Camera,OVRManager.CompositionMethod,System.Boolean,OVRManager.CameraDevice,OVRManager.DepthQuality)">
            <summary>
            Updates the internal state of the Mixed Reality Camera. Called by OVRManager.
            </summary>
        </member>
        <member name="T:OVRModeParms">
            <summary>
            Logs when the application enters power save mode and allows you to a low-power CPU/GPU level with a button press.
            </summary>
        </member>
        <member name="F:OVRModeParms.resetButton">
            <summary>
            The gamepad button that will switch the application to CPU level 0 and GPU level 1.
            </summary>
        </member>
        <member name="M:OVRModeParms.Start">
            <summary>
            Invoke power state mode test.
            </summary>
        </member>
        <member name="M:OVRModeParms.Update">
            <summary>
            Change default vr mode parms dynamically.
            </summary>
        </member>
        <member name="M:OVRModeParms.TestPowerStateMode">
            <summary>
            Check current power state mode.
            </summary>
        </member>
        <member name="T:OVRMonoscopic">
            <summary>
            Allows you to toggle monoscopic rendering with a gamepad button press.
            </summary>
        </member>
        <member name="F:OVRMonoscopic.toggleButton">
            <summary>
            The gamepad button that will toggle monoscopic rendering.
            </summary>
        </member>
        <member name="M:OVRMonoscopic.Update">
            <summary>
            Check input and toggle monoscopic rendering mode if necessary
            See the input mapping setup in the Unity Integration guide
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:OVROverlay" -->
        <member name="T:OVROverlay.OverlayShape">
            <summary>
            Determines the on-screen appearance of a layer.
            </summary>
        </member>
        <member name="T:OVROverlay.OverlayType">
            <summary>
            Whether the layer appears behind or infront of other content in the scene.
            </summary>
        </member>
        <member name="F:OVROverlay.currentOverlayType">
            <summary>
            Specify overlay's type
            </summary>
        </member>
        <member name="F:OVROverlay.isDynamic">
            <summary>
            If true, the texture's content is copied to the compositor each frame.
            </summary>
        </member>
        <member name="F:OVROverlay.isProtectedContent">
            <summary>
            If true, the layer would be used to present protected content (e.g. HDCP). The flag is effective only on PC.
            </summary>
        </member>
        <member name="F:OVROverlay.isExternalSurface">
            <summary>
            If true, the layer will be created as an external surface. externalSurfaceObject contains the Surface object. It's effective only on Android.
            </summary>
        </member>
        <member name="F:OVROverlay.externalSurfaceWidth">
            <summary>
            The width which will be used to create the external surface. It's effective only on Android.
            </summary>
        </member>
        <member name="F:OVROverlay.externalSurfaceHeight">
            <summary>
            The height which will be used to create the external surface. It's effective only on Android.
            </summary>
        </member>
        <member name="F:OVROverlay.compositionDepth">
            <summary>
            The compositionDepth defines the order of the OVROverlays in composition. The overlay/underlay with smaller compositionDepth would be composited in the front of the overlay/underlay with larger compositionDepth.
            </summary>
        </member>
        <member name="F:OVROverlay.noDepthBufferTesting">
            <summary>
            The noDepthBufferTesting will stop layer's depth buffer compositing even if the engine has "Depth buffer sharing" enabled on Rift.
            </summary>
        </member>
        <member name="F:OVROverlay.currentOverlayShape">
            <summary>
            Specify overlay's shape
            </summary>
        </member>
        <member name="F:OVROverlay.textures">
            <summary>
            The left- and right-eye Textures to show in the layer.
            \note If you need to change the texture on a per-frame basis, please use OverrideOverlayTextureInfo(..) to avoid caching issues.
            </summary>
        </member>
        <member name="F:OVROverlay.externalSurfaceObject">
            <summary>
            The Surface object (Android only).
            </summary>
        </member>
        <member name="F:OVROverlay.externalSurfaceObjectCreated">
            <summary>
            Will be triggered after externalSurfaceTextueObject get created.
            </summary>
        </member>
        <member name="M:OVROverlay.OverrideOverlayTextureInfo(UnityEngine.Texture,System.IntPtr,UnityEngine.XR.XRNode)">
            <summary>
            Use this function to set texture and texNativePtr when app is running
            GetNativeTexturePtr is a slow behavior, the value should be pre-cached
            </summary>
        </member>
        <member name="M:OVROverlay.SetSrcDestRects(UnityEngine.Rect,UnityEngine.Rect,UnityEngine.Rect,UnityEngine.Rect)">
            <summary>
            Sets the source and dest rects for both eyes. Source explains what portion of the source texture is used, and
            dest is what portion of the destination texture is rendered into.
            </summary>
        </member>
        <member name="T:OVRPlatformMenu">
            <summary>
            Shows the Oculus plaform UI.
            </summary>
        </member>
        <member name="F:OVRPlatformMenu.inputCode">
            <summary>
            The key code.
            </summary>
        </member>
        <member name="F:OVRPlatformMenu.OnShortPress">
            <summary>
            Callback to handle short press. Returns true if ConfirmQuit menu should be shown.
            </summary>
        </member>
        <member name="M:OVRPlatformMenu.Awake">
            <summary>
            Instantiate the cursor timer
            </summary>
        </member>
        <member name="M:OVRPlatformMenu.ShowConfirmQuitMenu">
            <summary>
            Show the confirm quit menu
            </summary>
        </member>
        <member name="M:OVRPlatformMenu.RetreatOneLevel">
            <summary>
            Sample handler for short press which retreats to the previous scene that used OVRPlatformMenu.
            </summary>
        </member>
        <member name="M:OVRPlatformMenu.Update">
            <summary>
            Tests for long-press and activates global platform menu when detected.
            as per the Unity integration doc, the back button responds to "mouse 1" button down/up/etc
            </summary>
        </member>
        <member name="T:OVRPlayerController">
            <summary>
            Controls the player's movement in virtual reality.
            </summary>
        </member>
        <member name="F:OVRPlayerController.Acceleration">
            <summary>
            The rate acceleration during movement.
            </summary>
        </member>
        <member name="F:OVRPlayerController.Damping">
            <summary>
            The rate of damping on movement.
            </summary>
        </member>
        <member name="F:OVRPlayerController.BackAndSideDampen">
            <summary>
            The rate of additional damping when moving sideways or backwards.
            </summary>
        </member>
        <member name="F:OVRPlayerController.JumpForce">
            <summary>
            The force applied to the character when jumping.
            </summary>
        </member>
        <member name="F:OVRPlayerController.RotationAmount">
            <summary>
            The rate of rotation when using a gamepad.
            </summary>
        </member>
        <member name="F:OVRPlayerController.RotationRatchet">
            <summary>
            The rate of rotation when using the keyboard.
            </summary>
        </member>
        <member name="F:OVRPlayerController.SnapRotation">
            <summary>
            The player will rotate in fixed steps if Snap Rotation is enabled.
            </summary>
        </member>
        <member name="F:OVRPlayerController.FixedSpeedSteps">
            <summary>
            How many fixed speeds to use with linear movement? 0=linear control
            </summary>
        </member>
        <member name="F:OVRPlayerController.HmdResetsY">
            <summary>
            If true, reset the initial yaw of the player controller when the Hmd pose is recentered.
            </summary>
        </member>
        <member name="F:OVRPlayerController.HmdRotatesY">
            <summary>
            If true, tracking data from a child OVRCameraRig will update the direction of movement.
            </summary>
        </member>
        <member name="F:OVRPlayerController.GravityModifier">
            <summary>
            Modifies the strength of gravity.
            </summary>
        </member>
        <member name="F:OVRPlayerController.useProfileData">
            <summary>
            If true, each OVRPlayerController will use the player's physical height.
            </summary>
        </member>
        <member name="F:OVRPlayerController.CameraHeight">
            <summary>
            The CameraHeight is the actual height of the HMD and can be used to adjust the height of the character controller, which will affect the
            ability of the character to move into areas with a low ceiling.
            </summary>
        </member>
        <member name="E:OVRPlayerController.TransformUpdated">
            <summary>
            This event is raised after the character controller is moved. This is used by the OVRAvatarLocomotion script to keep the avatar transform synchronized
            with the OVRPlayerController.
            </summary>
        </member>
        <member name="F:OVRPlayerController.Teleported">
            <summary>
            This bool is set to true whenever the player controller has been teleported. It is reset after every frame. Some systems, such as
            CharacterCameraConstraint, test this boolean in order to disable logic that moves the character controller immediately
            following the teleport.
            </summary>
        </member>
        <member name="E:OVRPlayerController.CameraUpdated">
            <summary>
            This event is raised immediately after the camera transform has been updated, but before movement is updated.
            </summary>
        </member>
        <member name="E:OVRPlayerController.PreCharacterMove">
            <summary>
            This event is raised right before the character controller is actually moved in order to provide other systems the opportunity to
            move the character controller in response to things other than user input, such as movement of the HMD. See CharacterCameraConstraint.cs
            for an example of this.
            </summary>
        </member>
        <member name="F:OVRPlayerController.EnableLinearMovement">
            <summary>
            When true, user input will be applied to linear movement. Set this to false whenever the player controller needs to ignore input for
            linear movement.
            </summary>
        </member>
        <member name="F:OVRPlayerController.EnableRotation">
            <summary>
            When true, user input will be applied to rotation. Set this to false whenever the player controller needs to ignore input for rotation.
            </summary>
        </member>
        <member name="F:OVRPlayerController.RotationEitherThumbstick">
            <summary>
            Rotation defaults to secondary thumbstick. You can allow either here. Note that this won't behave well if EnableLinearMovement is true.
            </summary>
        </member>
        <member name="M:OVRPlayerController.UpdateTransform(OVRCameraRig)">
            <summary>
            Invoked by OVRCameraRig's UpdatedAnchors callback. Allows the Hmd rotation to update the facing direction of the player.
            </summary>
        </member>
        <member name="M:OVRPlayerController.Jump">
            <summary>
            Jump! Must be enabled manually.
            </summary>
        </member>
        <member name="M:OVRPlayerController.Stop">
            <summary>
            Stop this instance.
            </summary>
        </member>
        <member name="M:OVRPlayerController.GetMoveScaleMultiplier(System.Single@)">
            <summary>
            Gets the move scale multiplier.
            </summary>
            <param name="moveScaleMultiplier">Move scale multiplier.</param>
        </member>
        <member name="M:OVRPlayerController.SetMoveScaleMultiplier(System.Single)">
            <summary>
            Sets the move scale multiplier.
            </summary>
            <param name="moveScaleMultiplier">Move scale multiplier.</param>
        </member>
        <member name="M:OVRPlayerController.GetRotationScaleMultiplier(System.Single@)">
            <summary>
            Gets the rotation scale multiplier.
            </summary>
            <param name="rotationScaleMultiplier">Rotation scale multiplier.</param>
        </member>
        <member name="M:OVRPlayerController.SetRotationScaleMultiplier(System.Single)">
            <summary>
            Sets the rotation scale multiplier.
            </summary>
            <param name="rotationScaleMultiplier">Rotation scale multiplier.</param>
        </member>
        <member name="M:OVRPlayerController.GetSkipMouseRotation(System.Boolean@)">
            <summary>
            Gets the allow mouse rotation.
            </summary>
            <param name="skipMouseRotation">Allow mouse rotation.</param>
        </member>
        <member name="M:OVRPlayerController.SetSkipMouseRotation(System.Boolean)">
            <summary>
            Sets the allow mouse rotation.
            </summary>
            <param name="skipMouseRotation">If set to <c>true</c> allow mouse rotation.</param>
        </member>
        <member name="M:OVRPlayerController.GetHaltUpdateMovement(System.Boolean@)">
            <summary>
            Gets the halt update movement.
            </summary>
            <param name="haltUpdateMovement">Halt update movement.</param>
        </member>
        <member name="M:OVRPlayerController.SetHaltUpdateMovement(System.Boolean)">
            <summary>
            Sets the halt update movement.
            </summary>
            <param name="haltUpdateMovement">If set to <c>true</c> halt update movement.</param>
        </member>
        <member name="M:OVRPlayerController.ResetOrientation">
            <summary>
            Resets the player look rotation when the device orientation is reset.
            </summary>
        </member>
        <member name="F:OVRPlugin.Result.Success">
            Success
        </member>
        <member name="F:OVRPlugin.Result.Failure">
            Failure
        </member>
        <member name="T:OVRProfile">
            <summary>
            (Deprecated) Contains information about the user's preferences and body dimensions.
            </summary>
        </member>
        <member name="T:OVRProgressIndicator">
            <summary>
            Visualizes progress for operations such as loading.
            </summary>
        </member>
        <member name="T:OVRRaycaster">
            <summary>
            Extension of GraphicRaycaster to support ray casting with world space rays instead of just screen-space
            pointer positions
            </summary>
        </member>
        <member name="F:OVRRaycaster.m_RaycastResults">
            <summary>
            For the given ray, find graphics on this canvas which it intersects and are not blocked by other
            world objects
            </summary>
        </member>
        <member name="M:OVRRaycaster.Raycast(UnityEngine.EventSystems.PointerEventData,System.Collections.Generic.List{UnityEngine.EventSystems.RaycastResult})">
            <summary>
            Performs a raycast using eventData.worldSpaceRay
            </summary>
            <param name="eventData"></param>
            <param name="resultAppendList"></param>
        </member>
        <member name="M:OVRRaycaster.RaycastPointer(UnityEngine.EventSystems.PointerEventData,System.Collections.Generic.List{UnityEngine.EventSystems.RaycastResult})">
            <summary>
            Performs a raycast using the pointer object attached to this OVRRaycaster
            </summary>
            <param name="eventData"></param>
            <param name="resultAppendList"></param>
        </member>
        <member name="F:OVRRaycaster.s_SortedGraphics">
            <summary>
            Perform a raycast into the screen and collect all graphics underneath it.
            </summary>
        </member>
        <member name="M:OVRRaycaster.GetScreenPosition(UnityEngine.EventSystems.RaycastResult)">
            <summary>
            Get screen position of worldPosition contained in this RaycastResult
            </summary>
            <param name="worldPosition"></param>
            <returns></returns>
        </member>
        <member name="M:OVRRaycaster.RayIntersectsRectTransform(UnityEngine.RectTransform,UnityEngine.Ray,UnityEngine.Vector3@)">
            <summary>
            Detects whether a ray intersects a RectTransform and if it does also
            returns the world position of the intersection.
            </summary>
            <param name="rectTransform"></param>
            <param name="ray"></param>
            <param name="worldPos"></param>
            <returns></returns>
        </member>
        <member name="M:OVRRaycaster.IsFocussed">
            <summary>
            Is this the currently focussed Raycaster according to the InputModule
            </summary>
            <returns></returns>
        </member>
        <member name="T:OVRResetOrientation">
            <summary>
            Allows you to reset VR input tracking with a gamepad button press.
            </summary>
        </member>
        <member name="F:OVRResetOrientation.resetButton">
            <summary>
            The gamepad button that will reset VR input tracking.
            </summary>
        </member>
        <member name="M:OVRResetOrientation.Update">
            <summary>
            Check input and reset orientation if necessary
            See the input mapping setup in the Unity Integration guide
            </summary>
        </member>
        <member name="T:OVRSceneSampleController">
            <summary>
            Sample that allows you to play with various VR settings.
            </summary>
        </member>
        <member name="F:OVRSceneSampleController.quitKey">
            <summary>
            The key that quits the application.
            </summary>
        </member>
        <member name="F:OVRSceneSampleController.fadeInTexture">
            <summary>
            An optional texture that appears before the menu fades in.
            </summary>
        </member>
        <member name="F:OVRSceneSampleController.speedRotationIncrement">
            <summary>
            Controls how quickly the player's speed and rotation change based on input.
            </summary>
        </member>
        <member name="F:OVRSceneSampleController.layerName">
            <summary>
            We can set the layer to be anything we want to, this allows
            a specific camera to render it.
            </summary>
        </member>
        <member name="M:OVRSceneSampleController.Awake">
            <summary>
            Awake this instance.
            </summary>
        </member>
        <member name="M:OVRSceneSampleController.Start">
            <summary>
            Start this instance.
            </summary>
        </member>
        <member name="M:OVRSceneSampleController.Update">
            <summary>
            Update this instance.
            </summary>
        </member>
        <member name="M:OVRSceneSampleController.UpdateVisionMode">
            <summary>
            Updates the vision mode.
            </summary>
        </member>
        <member name="M:OVRSceneSampleController.UpdateSpeedAndRotationScaleMultiplier">
            <summary>
            Updates the speed and rotation scale multiplier.
            </summary>
        </member>
        <member name="M:OVRSceneSampleController.UpdateRecenterPose">
            <summary>
            Recenter pose
            </summary>
        </member>
        <member name="T:OVRScreenFade">
            <summary>
            Fades the screen from black after a new scene is loaded. Fade can also be controlled mid-scene using SetUIFade and SetFadeLevel
            </summary>
        </member>
        <member name="F:OVRScreenFade.renderQueue">
            <summary>
            The render queue used by the fade mesh. Reduce this if you need to render on top of it.
            </summary>
        </member>
        <member name="M:OVRScreenFade.FadeOut">
            <summary>
            Start a fade out
            </summary>
        </member>
        <member name="M:OVRScreenFade.OnLevelFinishedLoading(System.Int32)">
            <summary>
            Starts a fade in when a new level is loaded
            </summary>
        </member>
        <member name="M:OVRScreenFade.Start">
            <summary>
            Automatically starts a fade in
            </summary>
        </member>
        <member name="M:OVRScreenFade.OnDestroy">
            <summary>
            Cleans up the fade material
            </summary>
        </member>
        <member name="M:OVRScreenFade.SetUIFade(System.Single)">
            <summary>
            Set the UI fade level - fade due to UI in foreground
            </summary>
        </member>
        <member name="M:OVRScreenFade.SetFadeLevel(System.Single)">
            <summary>
            Override current fade level
            </summary>
            <param name="level"></param>
        </member>
        <member name="M:OVRScreenFade.Fade(System.Single,System.Single)">
            <summary>
            Fades alpha from 1.0 to 0.0
            </summary>
        </member>
        <member name="M:OVRScreenFade.SetMaterialAlpha">
            <summary>
            Update material alpha. UI fade and the current fade due to fade in/out animations (or explicit control)
            both affect the fade. (The max is taken)
            </summary>
        </member>
        <member name="T:OVRControllerHelper">
            <summary>
            Simple helper script that conditionally enables rendering of a controller if it is connected.
            </summary>
        </member>
        <member name="F:OVRControllerHelper.m_modelGearVrController">
            <summary>
            The root GameObject that represents the GearVr Controller model.
            </summary>
        </member>
        <member name="F:OVRControllerHelper.m_modelOculusGoController">
            <summary>
            The root GameObject that represents the Oculus Go Controller model.
            </summary>
        </member>
        <member name="F:OVRControllerHelper.m_modelOculusTouchQuestAndRiftSLeftController">
            <summary>
            The root GameObject that represents the Oculus Touch for Quest And RiftS Controller model (Left).
            </summary>
        </member>
        <member name="F:OVRControllerHelper.m_modelOculusTouchQuestAndRiftSRightController">
            <summary>
            The root GameObject that represents the Oculus Touch for Quest And RiftS Controller model (Right).
            </summary>
        </member>
        <member name="F:OVRControllerHelper.m_modelOculusTouchRiftLeftController">
            <summary>
            The root GameObject that represents the Oculus Touch for Rift Controller model (Left).
            </summary>
        </member>
        <member name="F:OVRControllerHelper.m_modelOculusTouchRiftRightController">
            <summary>
            The root GameObject that represents the Oculus Touch for Rift Controller model (Right).
            </summary>
        </member>
        <member name="F:OVRControllerHelper.m_controller">
            <summary>
            The controller that determines whether or not to enable rendering of the controller model.
            </summary>
        </member>
        <member name="T:OVRTracker">
            <summary>
            An infrared camera that tracks the position of a head-mounted display.
            </summary>
        </member>
        <member name="T:OVRTracker.Frustum">
            <summary>
            The (symmetric) visible area in front of the sensor.
            </summary>
        </member>
        <member name="F:OVRTracker.Frustum.nearZ">
            <summary>
            The sensor's minimum supported distance to the HMD.
            </summary>
        </member>
        <member name="F:OVRTracker.Frustum.farZ">
            <summary>
            The sensor's maximum supported distance to the HMD.
            </summary>
        </member>
        <member name="F:OVRTracker.Frustum.fov">
            <summary>
            The sensor's horizontal and vertical fields of view in degrees.
            </summary>
        </member>
        <member name="P:OVRTracker.isPresent">
            <summary>
            If true, a sensor is attached to the system.
            </summary>
        </member>
        <member name="P:OVRTracker.isPositionTracked">
            <summary>
            If true, the sensor is actively tracking the HMD's position. Otherwise the HMD may be temporarily occluded, the system may not support position tracking, etc.
            </summary>
        </member>
        <member name="P:OVRTracker.isEnabled">
            <summary>
            If this is true and a sensor is available, the system will use position tracking when isPositionTracked is also true.
            </summary>
        </member>
        <member name="P:OVRTracker.count">
            <summary>
            Returns the number of sensors currently connected to the system.
            </summary>
        </member>
        <member name="M:OVRTracker.GetFrustum(System.Int32)">
            <summary>
            Gets the sensor's viewing frustum.
            </summary>
        </member>
        <member name="M:OVRTracker.GetPose(System.Int32)">
            <summary>
            Gets the sensor's pose, relative to the head's pose at the time of the last pose recentering.
            </summary>
        </member>
        <member name="M:OVRTracker.GetPoseValid(System.Int32)">
            <summary>
            If true, the pose of the sensor is valid and is ready to be queried.
            </summary>
        </member>
        <member name="T:OVRWaitCursor">
            <summary>
            Rotates this GameObject at a given speed.
            </summary>
        </member>
        <member name="M:OVRWaitCursor.Update">
            <summary>
            Auto rotates the attached cursor.
            </summary>
        </member>
        <member name="T:Pose3D">
            <summary>
            Encapsulates a rotation and a translation.  This is a convenience class that allows
            construction and value access either by Matrix4x4 or Quaternion + Vector3 types.
            </summary>
        </member>
        <member name="F:Pose3D.FLIP_Z">
            <summary>Right-handed to left-handed matrix converter (and vice versa).</summary>
        </member>
        <member name="M:Pose3D.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Pose3D" /> class.</summary>
            <remarks>
            Initializes position to the origin and orientation to the identity rotation.
            </remarks>
        </member>
        <member name="M:Pose3D.#ctor(UnityEngine.Vector3,UnityEngine.Quaternion)">
            <summary>Initializes a new instance of the <see cref="T:Pose3D" /> class.</summary>
            <param name="position">The position to initialize.</param>
            <param name="orientation">The orientation to initialize.</param>
        </member>
        <member name="M:Pose3D.#ctor(UnityEngine.Matrix4x4)">
            <summary>Initializes a new instance of the <see cref="T:Pose3D" /> class.</summary>
            <param name="matrix">The matrix to initialize.</param>
        </member>
        <member name="P:Pose3D.Position">
            <summary>Gets or sets the translation component of the pose.</summary>
            <value>The translation component of the pose.</value>
        </member>
        <member name="P:Pose3D.Orientation">
            <summary>Gets or sets the rotation component of the pose.</summary>
            <value>The rotation component of the pose.</value>
        </member>
        <member name="P:Pose3D.Matrix">
            <summary>Gets or sets the pose as a matrix in Unity gameobject convention.</summary>
            <remarks>GVR contention is right-handed, while Unity convention is left-handed.</remarks>
            <value>The pose as a matrix in Unity gameobject convention.</value>
        </member>
        <member name="P:Pose3D.RightHandedMatrix">
            <summary>Gets the pose as a matrix in right-handed coordinates.</summary>
            <value>The pose as a matrix in right-handed coordinates.</value>
        </member>
        <member name="M:Pose3D.FlipHandedness(UnityEngine.Matrix4x4)">
            <summary>Flip the handedness of a matrix.</summary>
            <param name="matrix">The Matrix4x4 to flip.</param>
            <returns>A handedness-flipped Matrix4x4.</returns>
        </member>
        <member name="M:Pose3D.Set(UnityEngine.Vector3,UnityEngine.Quaternion)">
            <summary>Sets a Pose3D according to the provided values.</summary>
            <param name="position">The position to set.</param>
            <param name="orientation">The orientation to set.</param>
        </member>
        <member name="M:Pose3D.Set(UnityEngine.Matrix4x4)">
            <summary>Sets a Pose3D according to the provided values.</summary>
            <param name="matrix">The matrix to set.</param>
        </member>
        <member name="T:MutablePose3D">
            <summary>Mutable version of Pose3D.</summary>
        </member>
        <member name="M:MutablePose3D.Set(UnityEngine.Vector3,UnityEngine.Quaternion)">
            <summary>Sets the position and orientation from a Vector3 + Quaternion.</summary>
            <param name="position">The position to set.</param>
            <param name="orientation">The orientation to set.</param>
        </member>
        <member name="M:MutablePose3D.Set(UnityEngine.Matrix4x4)">
            <summary>Sets the position and orientation from a Matrix4x4.</summary>
            <param name="matrix">The matrix to set.</param>
        </member>
        <member name="M:MutablePose3D.SetRightHanded(UnityEngine.Matrix4x4)">
            <summary>Sets the position and orientation from a right-handed Matrix4x4.</summary>
            <param name="matrix">The right-handed matrix to set.</param>
        </member>
        <member name="T:Pvr_UnitySDKAPI.Pvr_KeyCode">
            <summary>
            controller key value
            </summary>
        </member>
        <member name="T:Pvr_UnitySDKAPI.SwipeDirection">
            <summary>
            The controller Touchpad slides in the direction.
            </summary>
        </member>
        <member name="T:Pvr_UnitySDKAPI.TouchPadClick">
            <summary>
            The controller Touchpad click the direction.
            </summary>
        </member>
        <member name="M:Pvr_UnitySDKAPI.Controller.UPvr_GetControllerQUA(System.Int32)">
            <summary>
            Get the controller rotation data.
            </summary>
            <param name="hand">0,1</param>
            <returns></returns>
        </member>
        <member name="M:Pvr_UnitySDKAPI.Controller.UPvr_GetControllerPOS(System.Int32)">
            <summary>
            Get the controller position data.
            </summary>
            <param name="hand">0,1</param>
            <returns></returns>
        </member>
        <member name="M:Pvr_UnitySDKAPI.Controller.UPvr_GetControllerTriggerValue(System.Int32)">
            <summary>
            Get the value of the trigger key 
            </summary>
            <param name="hand"></param>
            <returns>Neo:0-255,Goblin2:0/1</returns>
        </member>
        <member name="M:Pvr_UnitySDKAPI.Controller.UPvr_GetControllerPower(System.Int32)">
            <summary>
            Get the power of the controller, neo power is 1-10, goblin/goblin2 power is 1-4.
            </summary>
        </member>
        <member name="M:Pvr_UnitySDKAPI.Controller.UPvr_GetSwipeDirection(System.Int32)">
            <summary>
            Get the sliding direction of the touchpad.
            </summary>
            <param name="hand"></param>
            <returns></returns>
        </member>
        <member name="M:Pvr_UnitySDKAPI.Controller.UPvr_GetTouchPadClick(System.Int32)">
            <summary>
            Get the click direction of the touchpad.
            </summary>
            <param name="hand"></param>
            <returns></returns>
        </member>
        <member name="M:Pvr_UnitySDKAPI.Controller.UPvr_GetKey(System.Int32,Pvr_UnitySDKAPI.Pvr_KeyCode)">
            <summary>
            Get the key state
            </summary>
            <param name="hand">0,1</param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Pvr_UnitySDKAPI.Controller.UPvr_GetKeyDown(System.Int32,Pvr_UnitySDKAPI.Pvr_KeyCode)">
            <summary>
            Get the pressed state of the key
            </summary>
            <param name="hand">0,1</param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Pvr_UnitySDKAPI.Controller.UPvr_GetKeyUp(System.Int32,Pvr_UnitySDKAPI.Pvr_KeyCode)">
            <summary>
            Gets the lift state of the key.
            </summary>
            <param name="hand"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Pvr_UnitySDKAPI.Controller.UPvr_GetKeyLongPressed(System.Int32,Pvr_UnitySDKAPI.Pvr_KeyCode)">
            <summary>
            Gets the long press state of the Key.
            </summary>
        </member>
        <member name="M:Pvr_UnitySDKAPI.Controller.UPvr_GetPreferenceDevice">
            <summary>
            The service type that currently needs bind.
            </summary>
            <returns>1：Goblin service 2:Neo service </returns>
        </member>
        <member name="M:Pvr_UnitySDKAPI.Controller.UPvr_GetDeviceType">
             <summary>
            Gets the controller type of the current connection.
             </summary>
             <returns>0: no connection 1：goblin1 2:Neo 3:goblin2 </returns>
        </member>
        <member name="M:Pvr_UnitySDKAPI.Controller.UPvr_GetMainHandNess">
            <summary>
            Gets the current master hand for which 0/1.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Pvr_UnitySDKAPI.Controller.UPvr_SetMainHandNess(System.Int32)">
            <summary>
            Set the current controller as the master controller.
            </summary>
        </member>
        <member name="M:Pvr_UnitySDKAPI.Controller.UPvr_GetControllerAbility(System.Int32)">
            <summary>
            Ability to obtain the current controller (3dof/6dof)
            </summary>
            <param name="hand">0/1</param>
            <returns>-1:error 0：6dof  1：3dof 2:6dof </returns>
        </member>
        <member name="T:Pvr_UnitySDKConfigProfile.MaxFOV">
            <summary>
            MaxFOV
            </summary>
        </member>
        <member name="T:RenderEventType">
            <summary>
            Matches the events in the native plugin.
            </summary>
        </member>
        <member name="T:Pvr_UnitySDKPluginEvent">
            <summary>
            Communicates with native plugin functions that run on the rendering thread.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Pvr_UnitySDKPluginEvent.Issue(RenderEventType)" -->
        <!-- Badly formed XML comment ignored for member "M:Pvr_UnitySDKPluginEvent.IssueWithData(RenderEventType,System.Int32)" -->
        <member name="M:Pvr_UnitySDKPluginEvent.EncodeData(System.Int32,System.Int32,System.Int32)">
            <param name="eventId"></param>
            <param name="eventData"></param>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:Pvr_UnitySDKPluginEvent.DecodeData(System.Int32)">
            <summary>
            
            </summary>
            <param name="eventData"></param>
            <returns></returns>
        </member>
        <member name="M:WaveVR_Controller.Input(wvr.WVR_DeviceType)">
            <summary>
            Get the controller by device index.
            </summary>
            <param name="deviceIndex">The index of the controller.</param>
            <returns></returns>
        </member>
        <member name="P:WaveVR_Controller.Device.connected">
            Whether is the device connected.
        </member>
        <member name="P:WaveVR_Controller.Device.transform">
            Gets the RigidTransform {pos=Vector3, rot=Rotation}
        </member>
        <member name="M:WaveVR_Controller.Device.GetPress(wvr.WVR_InputId)">
            <summary>
            Check if button state is equivallent to specified state.
            </summary>
            <returns><c>true</c>, equal, <c>false</c> otherwise.</returns>
            <param name="_id">input button</param>
        </member>
        <member name="M:WaveVR_Controller.Device.GetPressDown(wvr.WVR_InputId)">
            <summary>
            If true, button with _id is pressed, else unpressed.
            </summary>
            <returns><c>true</c>, if press down was gotten, <c>false</c> otherwise.</returns>
            <param name="_id">WVR_ButtonId, id of button</param>
        </member>
        <member name="M:WaveVR_Controller.Device.GetPressUp(wvr.WVR_InputId)">
            <summary>
            If true, button with _id is unpressed, else pressed.
            </summary>
            <returns><c>true</c>, if unpress up was gotten, <c>false</c> otherwise.</returns>
            <param name="_id">WVR_ButtonId, id of button</param>
        </member>
        <member name="M:WaveVR_Controller.Device.GetTouch(wvr.WVR_InputId)">
            <summary>
            If true, button with _id is touched, else untouched..
            </summary>
            <returns><c>true</c>, if touch was gotten, <c>false</c> otherwise.</returns>
            <param name="_id">WVR_ButtonId, id of button</param>
        </member>
        <member name="M:WaveVR_Controller.Device.GetTouchDown(wvr.WVR_InputId)">
            <summary>
            If true, button with _id is touched, else untouched..
            </summary>
            <returns><c>true</c>, if touch was gotten, <c>false</c> otherwise.</returns>
            <param name="_id">WVR_ButtonId, id of button</param>
        </member>
        <member name="M:WaveVR_Controller.Device.GetTouchUp(wvr.WVR_InputId)">
            <summary>
            If true, button with _id is touched, else untouched..
            </summary>
            <returns><c>true</c>, if touch was gotten, <c>false</c> otherwise.</returns>
            <param name="_id">WVR_ButtonId, id of button</param>
        </member>
        <member name="M:WaveVR_ControllerInputModule.GetIntersectionPosition(UnityEngine.Camera,UnityEngine.EventSystems.RaycastResult)">
             @brief get intersection position in world space
            
        </member>
        <member name="M:WaveVR_ControllerListener.Input(wvr.WVR_DeviceType)">
            <summary>
            Get the controller by device index.
            </summary>
            <param name="deviceIndex">The index of the controller.</param>
            <returns></returns>
        </member>
        <member name="M:WaveVR_ControllerListener.Device.GetPress(wvr.WVR_InputId)">
            <summary>
            Check if button state is equivallent to specified state.
            </summary>
            <returns><c>true</c>, equal, <c>false</c> otherwise.</returns>
            <param name="_id">input button</param>
        </member>
        <member name="M:WaveVR_ControllerListener.Device.GetTouch(wvr.WVR_InputId)">
            <summary>
            If true, button with _id is touched, else untouched..
            </summary>
            <returns><c>true</c>, if touch was gotten, <c>false</c> otherwise.</returns>
            <param name="_id">WVR_ButtonId, id of button</param>
        </member>
        <member name="T:WaveVR_ControllerPointer">
            <summary>
            Draws a pointer in front of any object that the controller point at.
            The circle dilates if the object is clickable.
            </summary>
        </member>
        <member name="F:WaveVR_ControllerPointer.pointerGrowthSpeed">
            <summary>
            Growth speed multiplier for the pointer.
            </summary>
        </member>
        <member name="F:WaveVR_ControllerPointer.reticleSegments">
            <summary>
            Color of the pointer.
            </summary>
        </member>
        <member name="F:WaveVR_ControllerPoseTracker.ElbowRaiseYaxis">
            Height of the elbow  (m).
        </member>
        <member name="F:WaveVR_ControllerPoseTracker.ElbowRaiseZaxis">
            Depth of the elbow  (m).
        </member>
        <member name="F:WaveVR_ControllerPoseTracker.pointerTiltAngle">
            The Downward tilt or pitch of the laser pointer relative to the controller (degrees).
        </member>
        <member name="P:WaveVR_ControllerPoseTracker.PointerRotationFromController">
            Quaternion to represent the pointer's rotation relative to
            the controller.
        </member>
        <member name="F:WaveVR_ControllerPoseTracker.controllerSimulatedPosition">
            Vector to present the arm model position of controller.
            NOTE: This is in meatspace coordinates.
        </member>
        <member name="F:WaveVR_ControllerPoseTracker.controllerSimulatedRotation">
            Quaternion to present the arm model rotation of controller.
            NOTE: This is in meatspace coordinates.
        </member>
        <member name="F:WaveVR_ControllerPoseTracker.smoothMoveSpeed">
            controller lerp speed for smooth movement between with head position case and without head position case
        </member>
        <member name="F:WaveVR_ControllerPoseTracker.v3ChangeArmXAxis">
            X axis of arm is reverse in left / right arm.
        </member>
        <member name="F:WaveVR_ControllerPoseTracker.headRotation">
            Head's real rotation, not local rotation.
        </member>
        <member name="F:WaveVR_ControllerPoseTracker.bodyDirection">
            Vector to present the body's rotation.
        </member>
        <member name="F:WaveVR_ControllerPoseTracker.bodyRotation">
            Quaternion to present the shoulder's rotation.
            NOTE: This is in meatspace coordinates.
        </member>
        <member name="F:WaveVR_ControllerPoseTracker.wristOrientation">
            Simulated direction of wrist.
        </member>
        <member name="F:WaveVR_ControllerPoseTracker.HEADTOELBOW_OFFSET">
            Offset (position) related to view center. (meters)
        </member>
        <member name="F:WaveVR_ControllerPoseTracker.ELBOW_TO_XYPLANE_LERP_MIN">
            The elbow curve in XY-plane is not smooth.
            The lerp value increases much rapider when elbow raises up.
        </member>
        <member name="F:WaveVR_ControllerPoseTracker.ELBOW_ANGLE_PITCH_MIN">
            Pitch angle ranges (degrees) of elbow (from head).
        </member>
        <member name="F:WaveVR_ControllerPoseTracker.GRAVITY_CALIB_STRENGTH">
            Strength of the acceleration filter (unitless).
        </member>
        <member name="F:WaveVR_ControllerPoseTracker.VELOCITY_FILTER_SUPPRESS">
            Strength of the velocity suppression (unitless).
        </member>
        <member name="F:WaveVR_ControllerPoseTracker.LOW_ACCEL_VELOCITY_SUPPRESS">
            Strength of the velocity suppression during low acceleration (unitless).
        </member>
        <member name="F:WaveVR_ControllerPoseTracker.LOW_VELOCITY_ACCEL_SUPPRESS">
            Strength of the acceleration suppression during low velocity (unitless).
        </member>
        <member name="F:WaveVR_ControllerPoseTracker.MIN_ACCEL">
            The minimum allowable accelerometer reading before zeroing (m/s^2).
        </member>
        <member name="F:WaveVR_ControllerPoseTracker.GRAVITY_FORCE">
            The expected force of gravity (m/s^2).
        </member>
        <member name="F:WaveVR_ControllerPoseTracker.DELTA_ALPHA">
            Amount of normalized alpha transparency to change per second.
        </member>
        <member name="M:WaveVR_ControllerPoseTracker.GetRelativeControllerRotation(UnityEngine.Quaternion)">
            <summary>
            Gets the relative controller rotation.
            <para></para>
            <para>When user moves controller and body concurrently,
            the controller rotation seen by user is not real rotation of controller in world space.</para>
            The rotation related to body is
            <para></para>
            (angle of controller rotation) - (angle of body rotation).
            </summary>
            <returns>The relative controller rotation.</returns>
            <param name="rot">rotation of controller in world space.</param>
        </member>
        <member name="M:WaveVR_ControllerPoseTracker.ComputeControllerPose2(wvr.WVR_DevicePosePair_t,WaveVR_Utils.RigidTransform)">
            <summary>
            Get the position of controller in Arm Model
            
            Consider the parts construct controller position:
            Parts contain elbow, wrist and controller and each part has default offset from head.
            1. simulated elbow offset = default elbow offset apply body rotation = body rotation (Quaternion) * elbow offset (Vector3)
            2. simulated wrist offset = default wrist offset apply elbow rotation = elbow rotation (Quaternion) * wrist offset (Vector3)
            3. simulated controller offset = default controller offset apply wrist rotation = wrist rotation (Quat) * controller offset (V3)
            head + 1 + 2 + 3 = controller position.
            </summary>
            <param name="pose">WVR_DevicePosePair_t</param>
            <param name="rtPose">WaveVR_Utils.RigidTransform</param>
        </member>
        <member name="F:WaveVR_DevicePoseTracker.type">
            <summary>
            The type of this controller device, it should be unique.
            </summary>
        </member>
        <member name="M:WaveVR_DevicePoseTracker.OnNewPoses(System.Object[])">
            if device connected, get new pose, then update new position and rotation of transform
        </member>
        <member name="M:WaveVR_ExecuteEvents.HoverExecutor(IPointerHoverHandler,UnityEngine.EventSystems.BaseEventData)">
            Use ExecuteEvents.Execute (GameObject, BaseEventData, WaveVR_ExecuteEvents.pointerHoverHandler)
        </member>
        <member name="P:WaveVR_Init.Instance">
            <summary>
            The singleton instance of the <see cref="T:WaveVR_Init"/> class, there only be one instance in a scene.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:WaveVR_PoseTrackerManager.showTrackedObject" -->
        <member name="T:WaveVR_Raycast">
            <summary>
            This class mainly draws a ray cast of associated tracked object.
            </summary>
        </member>
        <member name="F:WaveVR_Raycast.index">
             @brief index of controller device.
            
        </member>
        <member name="F:WaveVR_Render.CameraGaze">
            <summary>
            While enabling, 3D objects (eq. Cube) is touchable for EventSystem.
            </summary>
        </member>
        <member name="M:WaveVR_Render.createLoadingBlack">
                 * The loading black is used to block the other camera or UI drawing on the display.
                 * The native render will use the screen after WaitForEndOfFrame.  And the
                 * native render need time to be ready for sync with Android's flow.  Therefore, the
                 * Screen or HMD may show othehr camera or UI's drawing.  For example, the graphic
                 * raycast need the camera has real output on screen.  We draw it, and cover it by
                 * binocular vision.  It let the gaze or the controller work well.  If we don't
                 * have a black canvas and the native render is delayed, the screen may show a BG
                 * color or the raycast image on the screen for a while.
                *
        </member>
        <member name="T:WaveVR_Reticle">
            <summary>
            Draws a circular reticle in front of any object that the user gazes at.
            The circle dilates if the object is clickable.
            </summary>
        </member>
        <member name="F:WaveVR_Reticle.reticleSegments">
            <summary>
            Number of segments making the reticle circle.
            </summary>
        </member>
        <member name="F:WaveVR_Reticle.reticleGrowthSpeed">
            <summary>
            Growth speed multiplier for the reticle.
            </summary>
        </member>
        <member name="F:WaveVR_Reticle.reticleColor">
            <summary>
            Color of reticle pointer.
            </summary>
        </member>
        <member name="F:WaveVR_Reticle.colorFlickerPerSecond">
            <summary>
            The color flicker flag of reticle pointer
            </summary>
        </member>
        <member name="F:WaveVR_Reticle.deepeningColorRotation">
            <summary>
            The color deepening flag of reticle pointer during rotation status
            </summary>
        </member>
        <member name="F:WaveVR_Reticle.rotationSpeed">
            <summary>
            The rotation of reticle pointer
            </summary>
        </member>
        <member name="T:WaveVR_Utils">
            This class is mainly for common handling:
            including event handling and pose data handling.
        </member>
        <member name="F:wvr.WVR_EventType.WVR_EventType_Quit">
            common event region 
        </member>
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_SystemInteractionModeChanged" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_SystemGazeTriggerTypeChanged" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_TrackingModeChanged" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_DeviceConnected" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_DeviceDisconnected" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_DeviceStatusUpdate" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_DeviceSuspend" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_DeviceResume" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_IpdChanged" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_DeviceRoleChanged" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_BatteryStatusUpdate" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_ChargeStatusUpdate" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_DeviceErrorStatusUpdate" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_BatteryTemperatureStatusUpdate" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_RecenterSuccess" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_RecenterFail" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_RecenterSuccess3DoF" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_RecenterFail3DoF" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_ButtonPressed" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_ButtonUnpressed" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_TouchTapped" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_TouchUntapped" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_LeftToRightSwipe" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_RightToLeftSwipe" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_DownToUpSwipe" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_EventType.WVR_EventType_UpToDownSwipe" -->
        <!-- Badly formed XML comment ignored for member "F:wvr.WVR_ScreenshotMode.WVR_ScreenshotMode_Raw" -->
    </members>
</doc>
